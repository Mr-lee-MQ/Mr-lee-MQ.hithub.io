<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3</title>
    <url>/Mr-lee-MQ.hithub.io/2020/07/15/CSS3/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS<a id="more"></a></h1><h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><ul>
<li>CSS1.0</li>
<li>CSS2.0   DIV（块） +   CSS，HTML 和CSS结构分离的思想，网页变得简单，SEO</li>
<li>CSS2.1   浮动，定位</li>
<li>CSS3.0   圆角，阴影，动画    浏览器兼容性</li>
</ul>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>style    存放CSS代码<ul>
<li>选择器{ 声明1；声明2…….   }</li>
<li>单独写一个CSS文件，在HTML中用link引入</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;h1&gt;
     我是标题
&lt;/h1&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;CSS/CSS1.css&quot;&gt;</code></pre>
<pre><code class="css">h1{
    color: aquamarine;
}</code></pre>
<h2 id="CSS的优势"><a href="#CSS的优势" class="headerlink" title="CSS的优势"></a>CSS的优势</h2><ul>
<li>内容和表现分离</li>
<li>网页结构表现统一，可以实现复用</li>
<li>样式十分的丰富</li>
<li>建立使用独立于html的css文件</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ul>
<h2 id="CSS的四种引入方式"><a href="#CSS的四种引入方式" class="headerlink" title="CSS的四种引入方式"></a>CSS的四种引入方式</h2><p>优先级：就近原则，谁离代码近，谁的优先级越高</p>
<ul>
<li>行内样式：在元素标签中，编写一个style属性，编写样式即可</li>
</ul>
<pre><code class="html">&lt;h1 style=&quot;color: red&quot; &gt;我是标题&lt;/h1&gt;</code></pre>
<ul>
<li>内部样式：</li>
</ul>
<pre><code class="html">&lt;h1&gt;我是标题&lt;/h1&gt;

&lt;style&gt;
    h1 {
       color: pink;
    }
&lt;/style&gt;</code></pre>
<ul>
<li>外部样式</li>
</ul>
<pre><code class="html">&lt;h1&gt;
     我是标题
&lt;/h1&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;CSS/CSS1.css&quot;&gt;


h1{
    color: aquamarine;
}</code></pre>
<p>拓展：外部样式两种写法</p>
<ul>
<li>链接式</li>
</ul>
<pre><code class="html">&lt;h1&gt;
     我是标题
&lt;/h1&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;CSS/CSS1.css&quot;&gt;


h1{
    color: aquamarine;
}</code></pre>
<ul>
<li>导入式</li>
</ul>
<pre><code class="html">&lt;style&gt;
    @import url &quot;CSS/CSS1.css&quot;;
&lt;/style&gt;
&lt;h1&gt;lalalal&lt;/h1&gt;
h1{
    color: aquamarine;
}</code></pre>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>作用：选择页面上的某一个或者某一类元素</p>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><p>不遵循就近原则。id选择器&gt;类选择器&gt;标签选择器</p>
<ul>
<li>标签选择器：选择同种类型标签，只能对同一类标签进行操作</li>
</ul>
<pre><code class="html">&lt;style&gt;
    h1{
        color: pink;
    }
    p{
        color: aqua;
    }
&lt;/style&gt;

&lt;h1&gt;
    第一行
&lt;/h1&gt;
&lt;h1&gt;
    第二行
&lt;/h1&gt;
&lt;p&gt;
  第三行
&lt;/p&gt;</code></pre>
<ul>
<li>类选择器： （.class名称{})      为标签定义class    可以多个标签归类，是同一个class，可以复用。</li>
</ul>
<pre><code class="html">&lt;style&gt;
    .one{
        color: aqua;
    }
    .two{
        color: pink;
    }
    .three{
        color: red;
    }
&lt;/style&gt;
&lt;h1 class=&quot;two&quot;&gt;
    第二行
&lt;/h1&gt;
&lt;h1 class=&quot;three&quot;&gt;
    第三行
&lt;/h1&gt;
&lt;p class=&quot;one&quot;&gt;
    第一行
&lt;/p&gt;</code></pre>
<ul>
<li>id选择器：    (#id名称{})     id保证全局唯一</li>
</ul>
<pre><code class="html">&lt;style&gt;
    #abc{
        color: red;
    }
    #bca{
        color: pink;
    }
    #cba{
        color: aqua;
    }
&lt;/style&gt;
&lt;h1 id=&quot;abc&quot;&gt;第一行&lt;/h1&gt;
&lt;h1 id=&quot;bca&quot;&gt;第一行&lt;/h1&gt;
&lt;h1 id=&quot;cba&quot;&gt;第一行&lt;/h1&gt;</code></pre>
<h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><ul>
<li>后代选择器：在某个元素的后面。<ul>
<li>body（层次） 标签{    }</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;style&gt;
    body h1{
        color: pink;
    }
&lt;/style&gt;</code></pre>
<ul>
<li>子选择器：只有一代（仅下一个层次）<ul>
<li>body（层次）&gt;标签{      }</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;style&gt;
    body &gt;h1{
        color: aqua;
    }
&lt;/style&gt;</code></pre>
<ul>
<li>相邻兄弟选择器：同一层次，只有一个（仅对下）</li>
</ul>
<pre><code class="html">&lt;style&gt;
    .active +h1{
        color: red;
    }
&lt;/style&gt;</code></pre>
<ul>
<li><p>.（class值） +  标签{         }</p>
</li>
<li><p>通用兄弟选择器：同一层次，向下所有</p>
</li>
</ul>
<pre><code class="html">&lt;style&gt;
    .active~ h1{
        color: red;
    }
&lt;/style&gt;</code></pre>
<ul>
<li>.(class值) ~  标签{        }</li>
</ul>
<h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><p>伪类：条件</p>
<pre><code class="html">选取第一个li元素
&lt;style&gt;
        ul li:first-child{
            background: red;
        }
选取最后一个li元素
        ul li:last-child{
            background: aqua;
        }
选中第一个p元素

    p:nth-child(1){
       background: red;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;P&gt;第一行&lt;/P&gt;
    &lt;P&gt;第二行&lt;/P&gt;
    &lt;P&gt;第三行&lt;/P&gt;
        &lt;ul&gt;
            &lt;li&gt;122o&lt;/li&gt;
            &lt;li&gt;2ih&lt;/li&gt;
            &lt;li&gt;3pkom&lt;/li&gt;
        &lt;/ul&gt;
&lt;/body&gt;</code></pre>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><pre><code class="html">&lt;style&gt;
        .damo a{
            float: left;
            display: block;
            height: 50px;
            width: 50px;
            border-radius: 10px;
            background: aquamarine;
            text-align: center;
            color: pink;
            text-decoration: none;
            margin-right: 5px;
            font: bold 20px/52px Arial;
        }
        /* 属性值，属性值 = 属性值（正则）
        =绝对等于
        *=包含这个元素
        ^=以这个开头
        $=以这个结尾
         */


        /*
        存在id属性的元素   a[]{}*/
        a[id]{
            background: aqua;
        }
        /*id=first的元素*/
        a[id=first]{
            background: red;
        }
        /*class中有links的元素*/
        a[class*=&quot;links&quot;]{
            background: antiquewhite;
        }
        /*选中href中以http开头的元素*/
        a[href^=http]{
            background: cornflowerblue;
        }
        /*选中href中以为jpg结尾的元素*/
        a[href$=jpg]{
            background: cyan;
        }
    &lt;/style&gt;
&lt;/head&gt;



&lt;body&gt;
&lt;p class=&quot;damo&quot;&gt;
    &lt;a href=&quot;http://www.baidu.com&quot;class=&quot;links check-menu-item first&quot;id=&quot;first&quot;&gt;1&lt;/a&gt;
    &lt;a href=&quot;http://blog.kuangstudy.com&quot;class=&quot;links item active&quot;target=&quot;_blank&quot;title=&quot;text&quot;&gt;2&lt;/a&gt;
    &lt;a href=&quot;images/123.html&quot;class=&quot;links item&quot;&gt;3&lt;/a&gt;
    &lt;a href=&quot;images/123.png&quot;class=&quot;links item&quot;&gt;4&lt;/a&gt;
    &lt;a href=&quot;images/123.jpg&quot;class=&quot;links item&quot;&gt;5&lt;/a&gt;
    &lt;a href=&quot;abc&quot;class=&quot;links item&quot;&gt;6&lt;/a&gt;
    &lt;a href=&quot;/a.pdf&quot;class=&quot;links item&quot;&gt;7&lt;/a&gt;
    &lt;a href=&quot;/abc.pdf&quot;class=&quot;links item&quot;&gt;8&lt;/a&gt;
    &lt;a href=&quot;abc.doc&quot;class=&quot;links item&quot;&gt;9&lt;/a&gt;
    &lt;a href=&quot;abcd.doc&quot;class=&quot;links item last&quot;&gt;10&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;</code></pre>
<h2 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h2><h3 id="为什么要美化网页"><a href="#为什么要美化网页" class="headerlink" title="为什么要美化网页"></a>为什么要美化网页</h3><ul>
<li>有效的传递页面信息</li>
<li>美化页面，页面漂亮，才能吸引用户</li>
<li>凸显页面主题</li>
<li>提高用户的体验</li>
</ul>
<p>span标签:重点突出的字，用span套起来。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

    &lt;style&gt;
        #sp {
            font-size: 20px;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
欢迎学习&lt;span id=&quot;sp&quot;&gt;JAVA&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><ul>
<li>font-family: “Adobe 楷体 Std R”;       字体风格</li>
<li>font-size: 20px;        字号</li>
<li>font-weight: 100;      字体粗细</li>
<li>color: aqua;          字体颜色</li>
</ul>
<pre><code class="html">&lt;style&gt;
       body{
           font-family: &quot;Adobe 楷体 Std R&quot;;
           font-size: 20px;
           }
        .zw{
          color: aqua;
            font-weight: 100;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;这是标题&lt;/h1&gt;
&lt;p class=&quot;zw&quot;&gt;正文第一段&lt;/p&gt;

&lt;/body&gt;</code></pre>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><ul>
<li><p>颜色   color</p>
<ul>
<li>单词</li>
<li>RGB  0~F</li>
<li>RGBA     A：透明度   0~1</li>
</ul>
</li>
<li><p>对齐的方式   text-align   </p>
<ul>
<li>center    排版，居中</li>
</ul>
</li>
<li><p>首行缩进</p>
<ul>
<li>text-indent：2em；  段落首行缩进2字母    </li>
</ul>
</li>
<li><p>行高</p>
<ul>
<li>hight    块的高度 </li>
<li>line-height     行高</li>
<li>块的高度和行高相同，就可以上下居中</li>
</ul>
</li>
<li><p>装饰  text-decoration</p>
<ul>
<li>下划线    underline</li>
<li>中划线     line-through</li>
<li>上划线      overline</li>
<li>超链接去下划线      a   { text-decoration :    none}</li>
</ul>
</li>
<li><p>文本图片水平对齐    参照物 a，b</p>
</li>
</ul>
<pre><code class="html">&lt;style&gt;
    a,b{
        vertical-align:middle
    }
&lt;/style&gt;</code></pre>
<h3 id="文本阴影和超链接伪类"><a href="#文本阴影和超链接伪类" class="headerlink" title="文本阴影和超链接伪类"></a>文本阴影和超链接伪类</h3><ul>
<li>超链接去下划线      </li>
</ul>
<pre><code class="html">text-decoration：none            
color:#000;</code></pre>
<ul>
<li>鼠标悬浮状态</li>
</ul>
<pre><code class="css">a:hover{
    color:orange;
    font-size:50px
}</code></pre>
<ul>
<li>鼠标按住未释放的状态</li>
</ul>
<pre><code class="css">a:active{
color:green;
}
a:visited{
color:#ff008a;
}</code></pre>
<ul>
<li>阴影颜色(阴影颜色，水平偏移，垂直偏移，阴影半径)</li>
</ul>
<pre><code class="html">text-shadow:#3cc7f5 10px 10px  2px</code></pre>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>去掉列表前的点</li>
</ul>
<pre><code class="CSS">list-style: none    去掉原点
            circle    空心圆
            decimal    数字
            square    正方形</code></pre>
<h3 id="背景图像应用及渐变"><a href="#背景图像应用及渐变" class="headerlink" title="背景图像应用及渐变"></a>背景图像应用及渐变</h3><ul>
<li>背景图片</li>
</ul>
<pre><code class="css">background-image:url(&quot;    &quot;);图片地址
background-repeat:repeat-x    在x轴上平铺
background-repeat:repeat-y      在y轴上平铺
background-repeat:none-repeat 不平铺 </code></pre>
<ul>
<li>颜色，图片，图片位置</li>
</ul>
<pre><code class="css">background: red url(&quot;    &quot;) 250px,100px no-repeat</code></pre>
<ul>
<li>渐变</li>
</ul>
<pre><code class="css">background-color:#21D4FD;
background-image:linear-gradient(19deg,#21D4FD 0%，#B721FF 100%);</code></pre>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul>
<li><p>#box   {  }</p>
</li>
<li><p>margin：外边距  （body有默认的外边距）</p>
</li>
<li><p>padding：内边距</p>
</li>
<li><p>border：边框      border：1px,solid,red;</p>
<ul>
<li>边框的粗细（width）</li>
<li>边框的样式（solid虚线      deshed实线）</li>
<li>边框的颜色</li>
</ul>
</li>
</ul>
<h3 id="内外边距及div居中"><a href="#内外边距及div居中" class="headerlink" title="内外边距及div居中"></a>内外边距及div居中</h3><p>盒子的计算方式：margin + border + padding + 内容宽度</p>
<ul>
<li>内外边距   上右下左（顺时针）</li>
</ul>
<pre><code class="css">padding:0 0 0 0;(上右下左)
margin:0 0 0 0;</code></pre>
<ul>
<li>div居中</li>
</ul>
<pre><code class="css">margin:0 aoto;   居中</code></pre>
<p>要求：块元素，块元素有固定的宽度</p>
<pre><code class="css">&lt;div style=&quot;width: 50px;
display: block;     
text-align: center&quot;&gt;
&lt;/div&gt;</code></pre>
<h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><p>4个角</p>
<pre><code class="css">&lt;style&gt;
        div{
            width: 200px;
            height: 200px;
            border: 1px solid red;
            border-radius: 50px 20px 10px 5px;
        }</code></pre>
<p>左上右上      右下左下（主次对角线）顺时针方向</p>
<ul>
<li>圆： border-radius: 50px                      圆角   =   半径<ul>
<li>100*100 则四个角设置为50；</li>
</ul>
</li>
</ul>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul>
<li>box-shadow:10px    10px    100px    yellow;</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>标准文档流</li>
</ul>
<p>块级元素：独占一行</p>
<pre><code>h1~h6    p     div  列表</code></pre><p>行内元素：不独占一行</p>
<pre><code>span   a    img  </code></pre><p>行内元素可以被包含在块级元素中。</p>
<ul>
<li><p>display</p>
<ul>
<li>block：    块元素</li>
<li>inline       行内元素</li>
<li>inline-block     是块元素，但可以内联，在一行    </li>
<li>none     </li>
</ul>
</li>
<li><p>浮动     float</p>
</li>
</ul>
<pre><code class="css">float: right;
float: left;</code></pre>
<ul>
<li>clear</li>
</ul>
<pre><code class="css">clear:right;      右侧不允许有浮动元素
clear:left;       左侧不允许有浮动元素
clear:both;       两侧都不允许有</code></pre>
<h3 id="父级边框塌陷问题-解决方案："><a href="#父级边框塌陷问题-解决方案：" class="headerlink" title="父级边框塌陷问题    解决方案："></a>父级边框塌陷问题    解决方案：</h3><ul>
<li>增加父级元素的高度</li>
</ul>
<pre><code class="css">#father{
    bored:1px #000 solid;
    height:800px;
}</code></pre>
<ul>
<li>增加一个空的div标签，清除浮动</li>
</ul>
<pre><code class="css">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;

.clear{
    clear:both;
    margin:0;
    padding:0;
}</code></pre>
<ul>
<li>在父级元素中加一个   overflow（自动溢出）<ul>
<li>hidden   隐藏</li>
</ul>
</li>
<li>父类增加一个伪类：after</li>
</ul>
<pre><code class="css">#father:after{
    content:&#39;&#39;;
    display:block;
    clear:both;
}</code></pre>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>浮动元素后面加空div</li>
</ul>
<p>简单，代码中尽量避免空div</p>
<ul>
<li>设置父级元素的高度</li>
</ul>
<p>简单，元素假设有了固定的高度，就会被限制</p>
<ul>
<li>overflow</li>
</ul>
<p>简单，下拉的一些场景避免使用</p>
<ul>
<li>父级添加一个伪类：after（推荐）</li>
</ul>
<p>写法稍微复杂，但是没有缺点</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>display</li>
</ul>
<p>方向不可控制</p>
<ul>
<li>float</li>
</ul>
<p>浮动起来会脱离标准文档流</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>position:relative;</p>
<ul>
<li>相对于自己原来的位置进行偏移,仍然在标准文档流中。原来的位置会被保留。</li>
</ul>
<pre><code class="css">top:-20px;
left:20px;
bottom:-10px;
right:20px;</code></pre>
<pre><code class="css">position:relative;   /*相对定位：上下左右*/

&lt;style&gt;
        body{
           padding:20px;
       }
        div{
            padding: 5px;
            margin: 10px;
            border:1px solid #0000ff;
        }
        #first{
            border:1px solid #0000ff;
            background-color: aqua;
            position:relative;   /*相对定位：上下左右*/
            top:-20px;
            left:20px;
        }
        #second{
            border:1px solid #0000ff;
            background-color: cyan;
            position:relative;
            left:20px;
        }
        #third{
            border:1px solid #0000ff;
            background-color: antiquewhite;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;first&quot;&gt;第一个盒子&lt;/div&gt;
    &lt;div id=&quot;second&quot;&gt;第二个盒子&lt;/div&gt;
    &lt;div id=&quot;third&quot;&gt;第三个盒子&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;</code></pre>
<p><a href="https://www.wailian.work/image/QfcpF0" target="_blank" rel="noopener"><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/07/15/CSS3/sp200723_182303.png" alt="sp200723_182303.png"></a></p>
<pre><code class="html">&lt;style&gt;
        #box{
            border: 1px solid red;
            height: 300px;
            width: 300px;
            padding: 10px;

        }
        a{
            height: 100px;
            width: 100px;
            background: #ff55fa;
            text-align: center;
            line-height: 100px;
            text-decoration: none;
            display: block;
            color: white;
        }
        a:hover{
            background: rgba(0, 0, 255, 0.98);
        }
        .a2{
            position: relative;
            left: 200px;
            top: -100px;
        }
        .a4{
            position: relative;
            right: -200px;
            top: -100px;
        }
        .a5{
            position: relative;
            right:-100px;
            top: -300px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;box&quot;&gt;
    &lt;a class=&quot;a1&quot; href=&quot;#&quot;&gt;链接一&lt;/a&gt;
    &lt;a class=&quot;a2&quot; href=&quot;#&quot;&gt;链接二&lt;/a&gt;
    &lt;a class=&quot;a3&quot; href=&quot;#&quot;&gt;链接三&lt;/a&gt;
    &lt;a class=&quot;a4&quot; href=&quot;#&quot;&gt;链接四&lt;/a&gt;
    &lt;a class=&quot;a5&quot; href=&quot;#&quot;&gt;链接五&lt;/a&gt;
&lt;/div&gt;
&lt;/body&gt;</code></pre>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>position:absolute</p>
<ul>
<li>定位：基于xxx定位，上下左右<ul>
<li>没有父级元素定位的前提下，相对于浏览器定位</li>
<li>假设父级元素存在定位，我们通常会相对于父级元素进行偏移</li>
<li>在父级元素范围内移动</li>
</ul>
</li>
<li>相对于父级或浏览器的位置，进行指定的偏移，绝对定位的话，他不在标准文档流中，原来的位置也不会被保留。</li>
</ul>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>position:fixed;</p>
<p>元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动。fixed表示脱离了正常的文档流。</p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>层级:最低是0，最高无限</p>
<pre><code> z-index:max;</code></pre><p>opactity:0.5      背景透明度</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>GUI</title>
    <url>/Mr-lee-MQ.hithub.io/2020/10/05/GUI/</url>
    <content><![CDATA[<h1 id="GUI编程"><a href="#GUI编程" class="headerlink" title="GUI编程"></a>GUI编程<a id="more"></a></h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>窗口</li>
<li>弹窗</li>
<li>面板</li>
<li>文本框</li>
<li>列表框</li>
<li>按钮</li>
<li>图片</li>
<li>监听事件</li>
<li>鼠标事件</li>
<li>键盘事件</li>
<li>破解工具</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Gui的核心技术：Swing   AWT</p>
<ul>
<li>因为界面不美观</li>
<li>需要Jre环境</li>
</ul>
<p>为何学习</p>
<ul>
<li>可以写出自己的小工具</li>
<li>工作时候，也可能需要维护swing界面，概率极小。</li>
<li>了解MVC架构，了解监听。</li>
</ul>
<h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><h3 id="Awt介绍"><a href="#Awt介绍" class="headerlink" title="Awt介绍"></a>Awt介绍</h3><ul>
<li><p>包含了很多类和接口。Gui：图形界面编程</p>
</li>
<li><p>元素：窗口，按钮，文本框</p>
</li>
<li><p>java.awt包</p>
</li>
</ul>
<p><a href="https://www.wailian.work/image/QmMZi5" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp201005_135135.png" alt="sp201005_135135.png"></a> </p>
<h3 id="组件和容器"><a href="#组件和容器" class="headerlink" title="组件和容器"></a>组件和容器</h3><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><pre><code class="java">public class TestFrame{
    public static void main(String[] args){
        //Frame.JDK。
        Frame frame = new Frame(&quot;我的第一个Java图像界面窗口&quot;);
        //需要设置可见性
        frame.setVisible(true);

        //设置窗口大小
        frame.setSize(400,400);

        //设置背景颜色
        frame.setBackground(new Color(85, 159, 68));

        //弹出的初始位置
        frame.setLocation(200, 200);

        //设置大小固定
        frame.setResizable(false);
    }
}</code></pre>
<pre><code class="java">//封装上面的窗口
public class TestFrame2 {
    public static void mian (String[] args){
        //展示多个窗口
        MyFrame myFrame1 = new MyFrame(100, 100, 200, 200, Color.blue);

    }
}
class MyFrame extends Frame{
    static int id = 0;  //可能存在多个窗口，我们需要一个计数器
    public MyFrame (int x, int y, int w, int h, Color color){
        super(&quot;Myframe+&quot;+(++id));
        setBackground(color);
        setBound(x, y, w, h);
        setVisble(true);
    }
}</code></pre>
<h3 id="面板Panel"><a href="#面板Panel" class="headerlink" title="面板Panel"></a>面板Panel</h3><p>Panel可以看成一个空间，但是不能单独存在</p>
<p>解决了关闭事件</p>
<pre><code class="java">//Panel可以看成一个空间，但是不能单独存在
public class TestPanel{
    public static void main(String[] args){
        Frame frame = new Frame();
        Panel panel = new Panel();
        //设置布局
        frame.setLayout(null);

        //坐标
        frame.setBounts(300, 300, 500, 500);
        frame.setbackground(new Color(193, 161, 35));

        //panel设置坐标，相对于frame
        panel.setBounds(50, 50, 400, 400);
        panel.setBackground(newColor(193, 15, 60));

        //frame.add(panel)
        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听窗口关闭事件 System.exit(0)
        //适配器模式:
        frame.addWindowListener(new WindowAdapter){
            //窗口点击关闭的时候需要做的事情
            @override
            public void windowCloseing(WindowEvent e){
                //结束程序
                System.exit(0);
            }
        }
    }
}</code></pre>
<h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><ul>
<li>流式布局</li>
<li>东西南北中</li>
<li>表格布局</li>
</ul>
<pre><code class="java">//流式布局
public class TestFlowLayout{
    publiic static void main(String[] args){
        Frame frame = new Frame();

        //组件-按钮
        Button button1 = new Button(&quot;button1&quot;);
        Button button2 = new Button(&quot;button2&quot;);
        Button button3 = new Button(&quot;button3&quot;);

        //设置流式布局
        frame.setLayout(new FlowLayout());
        frame.setLayout(new FlowLayout(FlowLayle.LEFT));
         frame.setLayout(new FlowLayout(FlowLayle.RIGHT));

        frame.setSize(200, 200);

        //添加按钮
        frame.add(button1);
        frame.add(button2);
        frame.add(button3);

        frame.setVisible(true);

    }
}</code></pre>
<pre><code class="java">//东西南北中布局
public class TestBorderLayout {
    public static void main(String[] args){
        Frame frame = new Frame(&quot;TestBorderLayout&quot;);

        Button east = new Button(&quot;East&quot;);
        Button west = new Button(&quot;West&quot;);
        Button south = new Button(&quot;South&quot;);
        Button north = new Button(&quot;North&quot;);
        Button center = new Button(&quot;Center&quot;);


        frame.add(east.BorderLayout.EAST);
        frame.add(west.BorderLayout.WEST);
        frame.add(south.BorderLayout.SOUTH);
        frame.add(north.BorderLayout.NORTH);
        frame.add(cencer.BorderLayout.CENCER);

        frame.setSize(200,200);
        frame.setVisible(true);


    }
}</code></pre>
<pre><code class="java">//表格布局
public class TestGridLayout {
    public static void main(String[] args){
        Frame frame = new Frame(&quot;TestGridLayout&quot;);

        Button btn1 = new Button(&quot;btn1&quot;);
        Button btn2 = new Button(&quot;btn2&quot;);
        Button btn3 = new Button(&quot;btn3&quot;);
        Button btn4 = new Button(&quot;btn4&quot;);
        Button btn5 = new Button(&quot;btn5&quot;);
        Button btn6 = new Button(&quot;btn6&quot;);


        frame.add(btn1);
        frame.add(btn2);
        frame.add(btn3);
        frame.add(btn4);
        frame.add(btn5);
        frame.add(btn6);

        frame.pack();//java函数
        frame.setVisible(true);
</code></pre>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><pre><code class="java">public class TestActionEvent {
    public static void main (String[] args){
      //按下按钮，触发一些事件
    Frame frame = new Frame();
    Button button = new Button();
    //因为，addActionListener()需要一个ActionListener,所以我们需要构造一个ActionListener

    MyActionListener myActionListener = new MyActionListener();
    button.addActionListener(myActionLIstener);

    frame.add(button,BorderLayout.CENTER);
    frame.pack();

    windowClose(frame);//关闭窗口    
    frame.setVisible(true);  
    }

    //关闭窗体事件
    private static void windowClose(Frame frame){
        frame.addWindowListener(new WindowAdapter()) {
           @Override
            public void windowClosing(windowEvent e){
                System.exit(0);
            }
        }
    }

}

class MyActionListrener implements ActionListener{
    @Override
    public void actionPerformd(ActionEvent e){
        System.out.println(&quot;aaa&quot;);
    }
}
</code></pre>
<pre><code class="java">//两个按钮，实现一个监听
//开始，  停止

public class TestActionTwo{
    public static void main(String[] args){
        Frame frame = new Frame(&quot;开始-停止&quot;);
        Button button1 = new Button(&quot;start&quot;);
        Button button2 = new Button(&quot;stop&quot;);

        button2.setActionCommand(&quot;button2-stop&quot;);

        MyMonitor myMonitor = new MyMonitor();

        button1.addActionListener(myMonitor);
        button2.addActionListener(myMonitor);

        frame.add(button1,BorderLayout.NORTH);
        frame.add(button2,BorderLayout.SOUTH);

        frame.pack();
        frame.setVisible(true);

    }
}

class MyMonitor implement ActionListener{
    @Override
    public void actionPerformed(ActionEvent e){
        System.out.println(&quot;按钮被点击了: msg&quot;+e.getActionCommand());
    }
}</code></pre>
<h3 id="输入框事件监听"><a href="#输入框事件监听" class="headerlink" title="输入框事件监听"></a>输入框事件监听</h3><pre><code class="java">//
public class TestText01{
    public static void main(String[] args){
        //启动
        new MyFrame();

    }
}

class MyFrame extends Frame{
    public MyFrame(){
        TextField textField = new TestField();
        add(tsxtField);

        //监听这个文本框输入的文字
        MyActionListener2 myActionListener2 = new MyActionListener2();
        textField.addActionListener(myActionListener2);

        //设置替换编码
        textField.setEchoChar(&#39;*&#39;);

        setVIsible(true);
        pack();
    }
}

class MyActionListener2 implements ActionListener{
    @OVerride
    public void actionPerformed(ActionEvent e){
        TextField field = (TextField) e.getSource();
        //获得一些资源，返回一个对象
        System.out.println(field.getText());//获得输入框的文本
    }

}</code></pre>
<h3 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h3><pre><code class="java">public class TestPaint {
    public static void mian(String[] args){
        new MyPint().loadFrame();

    }
}

class MyPaint extends Frame{

    public void loadFrame(){
        setBounds(200, 200, 600, 500);
        setVisible(true);

    }
    //画笔
    @Override
    public void paint(Graphics g){
        //画笔，需要有颜色，画笔可以画画
        g.setColor(Color.red);
        g.drawOval(100, 100, 100, 100);

        g.fillOval(100, 100, 100, 100);//实心的圆
    }
}</code></pre>
<h3 id="鼠标监听"><a href="#鼠标监听" class="headerlink" title="鼠标监听"></a>鼠标监听</h3><p>目的：想要使用鼠标画画</p>
<pre><code class="java">//鼠标监听事件

public class TestMouseListener{
    public static void main(String[] args){

    }
}

//自己的类
class MyFrame extends Frame{
    //画画需要画笔，需要监听鼠标当前的位置，需要集合来存储这个点

    public MyFrame(String title){
        super(title);
        setBounds(200, 200, 400, 300);
        //存鼠标点击的点
        points = new ArrayList&lt;&gt;();

        //鼠标监听器,对于这个窗口
        this.addMouselistener(new MymouseListener());

        setVisible(true);
    }
    @Override
    public void paint(Graphics g){
        //画画，监听鼠标的事件
        Iterator iterator = points.iterator();
        while (iterator.hasNext()){
            Point point = (Point) iterator.next();
            g.setColor(Color.BLUE);
            g.fillOval(point.x, point.y, 10, 10);
        }
    }
    //添加一个点到界面上
    public void addPaint(Point point){
        points.add(point);
    }

    @Override
    public void psint(Graphics g){
        //画画，监听鼠标的事件
    }

    //适配器模式
    private class MyMouseListener extends MouseAdapter{
        //鼠标  按下，弹起，按住不放
        @Override
        public void mousePressed(MouseEvent e){
            MyFream fream = (MyFream) e.getSource();
            //这个我们点击的时候，就会在界面上产生一个点
            //这个点就是鼠标的点
            frame.addPaint(new Point(e.getX(),e.getY()));

            fream.addPaint(new Point(e.getX(),e.getY()));

            //每次点击鼠标都需要重新画一遍
            fream.repaint();//刷新
        }
    }

    }
}</code></pre>
<h3 id="键盘监听"><a href="#键盘监听" class="headerlink" title="键盘监听"></a>键盘监听</h3><pre><code class="java">//键
public class TestKeyListener{
    public static void main(String[] args){
        new KeyFream();
    }
}
class KeyFream extends Fream{
    public KeyFream(){
        setBounds(1, 2, 100, 100);
        setVisible(true);

        this.addKeyListener(new KeyAdapter){
            //键盘按下
            @Override
            public void keyPressed(KeyEvent e){
                //获得键盘下的键是哪一个，当前的码
                int keyCode = e.getKeyCode();
                //不需要去记录这个数值，直接使用静态属性 VK_XXX
                System.out.println(keyCode);
                if(keyCode == keyEvent.VK_UP){
                    System.out.println(&quot;你按下了上键&quot;);
                }
                //根据按下不同的操作，选择不同的结果
            }
        }

    }
}</code></pre>
<h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><h3 id="窗口，面板"><a href="#窗口，面板" class="headerlink" title="窗口，面板"></a>窗口，面板</h3><pre><code class="java">public class JFreamDemo{
    //init(); 初始化
    public void init(){
        JFream jf = new JFream(&quot;这是一个JFream窗口&quot;);
        jf.setVisible(true);
        jf.setBounds(100, 100, 100, 200);
        jf.setBackground(Color.cyan);
        //设置文字 JLabel
        JLabel label = new JLabel(&quot;我们来到狂神说Java节目&quot;);

        jf.add(label);

        //容器实例化


        //关闭事件
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

}
    public static void main(String[] args){
        //建立一个窗口
        new JFreamDemo().init();
    }</code></pre>
<pre><code class="java">//容器实例化
public class JframeDemo02{
    public static void main(String[] args){
        new MyJframe2().init();
    }
}

class MyJframe2 extends JFrame{
    public void init(){
        this.setBounds(10, 10, 200, 300);
        this.setVisible(true);
        JLabel label = new JLabel(&quot;欢迎来到狂神说Java系列节目&quot;);
        this.add(label);

        //让文本标签居中
        label.setHorizontalAlignment(SwingConstants.CENTER);

        //获得一个容器
        Container container = this.getContentPane();
        container.setBackground(Color.BLUE);
    }
}</code></pre>
<h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><pre><code class="java">//JDialog   弹窗 默认就有关闭事件

//主窗口
public class DialogDemo extends JFrame{

    public DialogDemo(){
        this.setVisible(true);
        this.setSize(700, 500);
                              this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        //Jframe 放东西 容器
        Container container = this.getContentPane();
        //绝对布局
        container.setLayout(null);

        //按钮
        JButton button = new JButton(&quot;点击弹出一个对话框&quot;);//创建
        button.setBounds(30, 30, 200, 50);

        //点击这个按钮的时候，弹出一个弹窗
        button.addActionLIstener(new ActionListener {
            //监听器
            @Override
            public void actionPerformed(ActionEvent e){
                //弹窗
            }
        });

        container.add(button);

    }

    public static void main(String[] args){

    }
}

//弹窗的窗口
class MyDialogDemo extends JDialog{
    public MyDialogDemo(){
        this.setVisible(true);
        this.setBounds(100, 100, 500, 500);

        Container container = this.getContentPane();
        container.setLayout(null);

        container.add(new Label(&quot;秦老师带你学Java&quot;)); 
    }
}</code></pre>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>label</p>
<pre><code class="java">new JLabel(&quot;XXXX&quot;);</code></pre>
<p>图标  icon</p>
<pre><code class="java">//图标，需要实现类，Fream继承
public class IconDemo extends Fream implements Icon{

    private int width;
    private int height;

    public IconDemo(){}//无参构造

    public IconDemo(int width, int height){...}


    public void init(){
        IconDemo icondemo = new IconDemo(15, 15);
        //图标放在标签，也可以放在按钮上
        JLabel label = new JLabel(&quot;icontest&quot;,iconDemo,SwingConstants.CENTER);

        Container container = getContentPane();
        container.add(label);

        this.setVisible(true);
        this.setDefaultCloseOpenation(WindowConstsnts.EXIT_ON_CLOSE);
    }



    public static void main(String[] args){
        new IconDemo().init();
    }

    @Override
    public void paintIcon(Component c, Graphics g, int x, int y){
        g.fillOval(x, y, width, height);
    }

    @Override
    public void getIconWidth(){
        return this.width;
    }

    @Override
    public int getIconHeight(){
        return this.height;
    }
}</code></pre>
<pre><code class="java">//图标为一个图片

public class ImageIconDemo extends JFrame{

    public ImageIconDemo(){
        //获取图片的地址
        JLabel label = new JLabel(&quot;ImageIcon&quot;);
        URL url = ImageIconDemo.class.getResource(&quot;图片名称.格式&quot;);

        ImageIcon imageIcon = new imageIcon(url);//注意命名不要冲突
        label.setIcon(imageIcon);
        label.setHorizontalAlignment(SwingConstants.CENTER);

        Container container = getContentPane();
        container.add(label);

        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setBounds(100, 100, 200, 200);
    }
    public static void main(String[] args){
        new ImageIconDemo();
    }
}</code></pre>
<h3 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h3><p>JPanel</p>
<pre><code class="java">public class JPanelDemo extends JFrame{
    public JPanelDemo(){
        Container container = this.getContentPane();

        container.setLayout(new GridLayout(2, 1, 10, 10));
        //后面的两个参数的意思是，每个面板间的间距

        JPanel panel = new JPanel(new GridLayout(1, 3));

        panel.add(new JButton(&quot;1&quot;));
        panel.add(new JButton(&quot;1&quot;));
        panel.add(new JButton(&quot;1&quot;));

        container.add(panel1);

        this.setVisible(ture);
        this.setSize(500, 500);
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    public static void main(String[] args){
        new JPanelDemo();
    }



}</code></pre>
<p>JScroll</p>
<pre><code class="java">public class JScrollDemo extends JFrame{
    public JScrollDemo(){
        Container container = this.getContentPane();

        //文本域
        JTextArea textArea = new JTextArea(20, 50);
        textArea.setText(&quot;欢迎学习Java&quot;);

        //Scorll面板

        JScrollPane scrollPane = new JScrollPane(textArea);
        container.add(scrollPane);

        this.setVisible(true);
        this.setBounds(100, 100, 300, 350);
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
        new JscrollDemo();
    }
}</code></pre>
<p>图片按钮</p>
<pre><code class="java">public  class JButtonDemo01(){
    public JbuttonDemo01(){
        Container container = this.getContenPane();
        //将一个图片变成图标
        URL resource = JButtonDemo01.class.getResource(&quot;图片名称&quot;);
        Icon icon = new ImageIcon(resource);

        //把这个图标放在按钮上
        JButton button = new JButton();
        button.setIcon(icon);
        button.setToolTipText(&quot;图片按钮&quot;);

        //add
        container.add(button);

        this.setVisible(true);
        this.setSize(500,500);
        this.setDefualtCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    }

    public static void main(String[] args){
       new JButtonDemo01(); 
    }
}

</code></pre>
<p>单选框</p>
<pre><code class="java">public  class JButtonDemo02(){
    public JbuttonDemo02(){
        Container container = this.getContenPane();
        //将一个图片变成图标
        URL resource = JButtonDemo01.class.getResource(&quot;图片名称&quot;);
        Icon icon = new ImageIcon(resource);

        //单选框
        JRadioButton radioButton1 = new JRadioButton(&quot;JRadioButton01&quot;);
        JRadioButton radioButton2 = new JRadioButton(&quot;JRadioButton02&quot;);
        JRadioButton radioButton3 = new JRadioButton(&quot;JRadioButton03&quot;);

        //由于单选框只能选择一个，分组,一个组中只能选一个
         ButtonGroup group = new ButtonGroup();
        group.add(radioButton1);
        group.add(radioButton2);
        group.add(radioButton3);

        //设置位置
        container.add(radioButton1,BorderLayout.CENTER);
        container.add(raidoButton2,BorderLayout.NORTH);
        container.add(raidoButton3,BorderLayout.SOUTH);

        this.setVisible(true);
        this.setSize(500,500);
        this.setDefualtCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    }

    public static void main(String[] args){
       new JButtonDemo02(); 
    }
}

</code></pre>
<p>复选框</p>
<pre><code class="java">public  class JButtonDemo03(){
    public JbuttonDemo03(){
        Container container = this.getContenPane();
        //将一个图片变成图标
        URL resource = JButtonDemo01.class.getResource(&quot;图片名称&quot;);
        Icon icon = new ImageIcon(resource);

        //复选框
        JChockBox checkBox01 = new JChockBox(&quot;checkBox01&quot;);
        JChockBox chockBox02 = new JChockBox(&quot;checkBox02&quot;);

        container.add(checkBox01, BorderLayout.NORTH);
        container.add(chockBox02, BorderLayout.SOUTH);


        this.setVisible(true);
        this.setSize(500,500);
        this.setDefualtCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    }

    public static void main(String[] args){
       new JButtonDemo03(); 
    }
}

</code></pre>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>下拉框</p>
<pre><code class="java">//下拉框
public class TestComboboxDemo01 extends JFrame{
    public TestComboboxDemo01(){
        Container container = this.getContentPane();

        JComboBox status = new JComboBox();

        status.addItem(null);
        status.addItem(&quot;正在热映&quot;);
        status.addItem(&quot;已下架&quot;);
        atatus.addItem(&quot;即将上映&quot;);

        container.add(status);

        this.setVisible(true);
        this.setSize(500, 350);
        this.setDefaultCloseOperation(WindowConstats.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
       new TestComboboxDemo01(); 
    }
}</code></pre>
<p>列表框</p>
<pre><code class="java">//列表框
public class TestComboboxDemo02 extends JFrame{
    public TestComboboxDemo02(){
        Container container = this.getContentPane();

        //生成列表的内容
        String[] contents = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};                

        //列表中需要放入内容
        JList jList = new JList(contents);

        contens.add(&quot;张三&quot;);
        contens.add(&quot;李四&quot;);
        contens.add(&quot;王五&quot;);

        container.add(jList);
        this.setVisible(true);
        this.setSize(500, 350);
        this.setDefaultCloseOperation(WindowConstats.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
       new TestComboboxDemo02(); 
    }
}</code></pre>
<h3 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h3><ul>
<li>文本框</li>
<li>密码框</li>
<li>文本域</li>
</ul>
<pre><code class="java">//文本框 
public class TestTextDemo01 extends JFrame{
    public TestTextDemo01(){
        Container container = this.getContentPane();


        JTextField textFried = new JTextField(&quot;hello&quot;);
        JTextField textFried2 = new JTextField(&quot;World&quot;,20);

        container.add(textField, BorderLayout.NORTH);
        container.add(textField2, BorderLayout.SOUTH);

        this.setVisible(true);
        this.setSize(500, 350);
        this.setDefaultCloseOperation(WindowConstats.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
       new TextTextDemo01(); 
    }
}</code></pre>
<pre><code class="java">//密码框
public class TestTextDemo02 extends JFrame{
    public TestTextDemo02(){
        Container container = this.getContentPane();

        JPassworldField passworldField = new JPassworldField();//默认为...
        passworldField.setEchoChar(&#39;*&#39;);

        container.add(passworldField);

        this.setVisible(true);
        this.setSize(500, 350);
        this.setDefaultCloseOperation(WindowConstats.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
       new TextTextDemo02(); 
    }
}</code></pre>
<pre><code class="java">//文本域
public class JScrollDemo extends JFrame{
    public JScrollDemo(){
        Container container = this.getContentPane();

        //文本域
        JTextArea textArea = new JTextArea(20, 50);
        textArea.setText(&quot;欢迎学习Java&quot;);

        //Scorll面板

        JScrollPane scrollPane = new JScrollPane(textArea);
        container.add(scrollPane);

        this.setVisible(true);
        this.setBounds(100, 100, 300, 350);
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }

    public static void main(String[] args){
        new JscrollDemo();
    }
}</code></pre>
<h2 id="贪吃蛇实战"><a href="#贪吃蛇实战" class="headerlink" title="贪吃蛇实战"></a>贪吃蛇实战</h2><p>帧，如果时间碎片足够小，就是动画，一秒是30帧 60帧。连起来就是动画，拆开就是静态的图片。</p>
<pre><code class="java">//游戏的主启动类
public class StartGame{
    public static void main(String[] args){
        JFrameframe = new JFrame();


        frame.setBounds(10, 10, 900, 720);
        frame.setResizable(flase);//窗口大小不可变

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        //正常游戏界面应该在面板上
        frame.setVisible(true);
    }
}</code></pre>
<pre><code class="java">//游戏的面板
public class GamePanel extends Jpanel implements KeyListener,ActionListener{

    //定义蛇的数据结构
    int length;//蛇的长度
    int[] snakeX = new int [600];//蛇的x坐标 25*25
    int[] snakeY = new int [500];//蛇的Y坐标 25*25
    String fx;

    //食物的坐标
    int foodx;
    int foody;
    Random random = new Ramdom();
    //游戏当前的状态: 开始，停止
    boolean isStart = false;//默认是不开始

    //定时器  以毫秒为单位
    Timer timer = new Timer(100, this);//100毫秒监听一次

    //构造器
    public GamePanel(){
        init();
        //获得焦点和键盘事件
        this.setfocusable(true);//获得焦点事件
        this.addKeyListener(this);//获得键盘监听事件
        timer.start();//游戏一开始定时器就启动
    }

    //初始化方法
    public void init(){
        length = 3;
        snakeX[0] = 100;snakeY[0] = 100;//脑袋的坐标
        snakeX[1] = 75;snakeY[1] = 100;//第一个身体的坐标
        snakeX[2] = 50;snakeY[2] = 100;//第二个身体的坐标
        fx = &quot;R&quot;;//初始化方向向右
        //把食物随机分布在界面上
        foodx = 25 + 25*random.nextInt(34);
        foody = 75 + 25*random.nextInt(24);


    }


    //绘制面板，我们游戏中的所有东西，都是用这个画笔来画
    @Override
    protected void paintComponent(Graphics g){
        super.paintComponent(g);//清屏
        this.setBackground(Color.BLACK);
        Data.header.paintIcon(this,g,25,11);//头部广告栏
        g.fillRect(25, 75, 850, 600);//默认的游戏界面

        //把蛇画上去
        //蛇头初始化向右,需要通过方向来判断
        if(fx.equals(&quot;R&quot;)){
Date.right.paintIcon(this,g,snakeX[0],snakeY[0]); 
        }else if (fx.equals(&quot;L&quot;)){
Date.left.paintIcon(this,g,snakeX[0],snakeY[0]); 
        }else if (fx.equals(&quot;U&quot;)){
Date.up.paintIcon(this,g,snakeX[0],snakeY[0]); 
        }else if (fx.equals(&quot;D&quot;)){
Date.down.paintIcon(this,g,snakeX[0],snakeY[0]); 
        }

        for(int i = 1; i &lt; length; i++){
           Data.body.paintIcon(this,g,snakeX[i],snakeY[i]);
            //第一个身体的坐标
        }
        //画食物
        Data.food.paintIcon(this,g,foodx,foody);
        //游戏状态
        if(isStart==false){
            //设置字体
            g.setColor(Color.white);
            g.setfount(new Fount(&quot;微软雅黑&quot;, Fount.BOLD, 40));
            g.drawString(&quot;按下空格开始游戏&quot;,300,300);
        }

        if(isFail){
            g.setColor(Color.red);
            g.setfount(new Fount(&quot;微软雅黑&quot;, Fount.BOLD, 40));
            g.drawString(&quot;失败，按下空格重新开始&quot;,300,300);
        }
    }
    //键盘监听事件
    @Override
    public void keyPressed(KeyEvent e){
        int keyCode = e.getKeyCode();//获得键盘按键是哪一个


        if(keyCode == KeyEvent.VK_SPACE){
            //如果按下的是空格键
            if(isFail){
                //重新开始
                isfail = false;
                init();
            }else{
                isStart = !isStart;//取反
            }
            reoaint();
        }
        //小蛇移动,头部图片转换
        if(keyCode == KeyEvent.VK_UP){
            fx = &quot;U&quot;;
        }else if(keyCode == KeyEvent.VK_DOWN){
            fx = &quot;D&quot;;
        }else if(keyCode == KeyEvent.VK_LEFT){
            fx = &quot;L&quot;;
        }else if(keyCode == KeyEvent.VK_RIGHT){
            fx = &quot;R&quot;;
        }
    }

    //事件监听————需要通过固定的事件来刷新，1s = 10次
    @Override
    public void actionPerformed(ActionEvent e){
        if(isStart &amp;&amp; isFail == false){
            //如果游戏时开始状态，就让小蛇动起来
            //吃食物
            if(snakeX[0] == foodX &amp;&amp; foodY[0] == foody){
                length++;//长度+1
                //食物再次随机生成
                foodx = 25 + 25*random.nextInt(34);
                foody = 75 + 25*random.nextInt(24);
            }
            //移动
            for(int i = length-1; i &gt; 0; i--){
                snakeX[i] = snackX[i-1];
                snackY[i] = snackY[i-1];
            }
            //走向
            if(fx.equals(&quot;R&quot;)){
                snakeX[0] = snakeX[0]+25;
                if(snakeX[0]&gt;850){snakeX[0] = 25;}//边界判断
            }else if(fx.equals(&quot;L&quot;)){
                snakeX[0] = snakeX[0]-25;
                if(snakeX[0]&lt;25){snakeX[0] = 850;}//边界判断
            }else if(fx.equals(&quot;U&quot;)){
                snakeY[0] = snakeY[0]-25;
                if(snakeY[0]&lt;75){snakeY[0] = 650;}//边界判断
            }elae if(fx.equals(&quot;D&quot;)){
                snakeY[0] = snakeY[0]+25;
                if(snakeX[0]&gt;650){snakeX[0] = 75;}//边界判断
            }

            //失败判定，撞到自己就算失败
            for(int i = 1; i &lt; length; i++){
                if(snakeX[0]==snakeX[i] &amp;&amp; snakeY[0] == snakeY[i]){
                    isFail = true;
                }
            }



            repaint();//重画页面
        }
        timer.start();//定时器开启
    }
}
</code></pre>
<pre><code class="java">//数据中心
public class Data{

    //相对路径  XX.jpg
    //绝对路径  /   相当于当前的项目

    //头部
    public static URL headerURL = Data.class.getResource(&quot;statics/header.png&quot;);
    public static ImageIcon header = new ImageIcon(headerURL);

    //上下左右
    public static URL upURL = Data.class.getResource(&quot;statics/up.png&quot;);
    public static URL downURL = Data.class.getResource(&quot;statics/down.png&quot;);
    public static URL leftURL = Data.class.getResource(&quot;statics/left.png&quot;);
    public static URL rightURL = Data.class.getResource(&quot;statics/right.png&quot;);
    public static ImageIcon up = new ImageIcon(upURL);
    public static ImageIcon down = new ImageIcon(downURL);
    public static ImageIcon left = new ImageIcon(leftURL);
    public static ImageIcon right = new ImageIcon(rightURL);

    //身体
        public static URL bodyURL = Data.class.getResource(&quot;statics/body.png&quot;);
        public static ImageIcon body = new ImageIcon(bodyURL);

    //食物
     public static URL foodURL = Data.class.getResource(&quot;statics/food.png&quot;);
        public static ImageIcon food = new ImageIcon(foodURL);




}</code></pre>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>定义数据</li>
<li>画上去</li>
<li>监听事件<ul>
<li>键盘</li>
<li>事件</li>
</ul>
</li>
</ul>
<h2 id="GUI编程-1"><a href="#GUI编程-1" class="headerlink" title="GUI编程"></a>GUI编程</h2><ul>
<li>GUI</li>
<li>AWT<ul>
<li>组件</li>
<li>容器</li>
<li>画板</li>
<li>事件监听</li>
<li>文本框监听</li>
<li>画图类paint</li>
<li>鼠标监听器</li>
<li>窗口监听器</li>
<li>键盘监听器</li>
</ul>
</li>
<li>SWing<ul>
<li>容器</li>
<li>面板   可以带滚动条</li>
<li>label<ul>
<li>普通标签</li>
<li>图片标签</li>
<li>图像标签</li>
</ul>
</li>
<li>按钮<ul>
<li>普通按钮</li>
<li>带图片的</li>
<li>单选框</li>
<li>多选框</li>
</ul>
</li>
<li>列表<ul>
<li>下拉框</li>
<li>列表框</li>
</ul>
</li>
<li>文本框<ul>
<li>普通文本</li>
<li>密码框</li>
<li>文本域</li>
</ul>
</li>
</ul>
</li>
<li>贪吃蛇</li>
</ul>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/Mr-lee-MQ.hithub.io/2020/06/10/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git "></a>Git <a id="more"></a></h1><h1 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Git（读音为/gɪt/）是一个<strong>开源的分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 <strong>Linux 内核开发</strong>而开发的一个开放源码的版本控制软件。</p>
<p><strong>更多简介：</strong></p>
<p>参考：<a href="https://www.cnblogs.com/randysun/p/11524711.html" target="_blank" rel="noopener">https://www.cnblogs.com/randysun/p/11524711.html</a></p>
<p>和：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000</a></p>
<h2 id="2-官网"><a href="#2-官网" class="headerlink" title="2. 官网"></a>2. 官网</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h2 id="3-Git与SVN的主要区别"><a href="#3-Git与SVN的主要区别" class="headerlink" title="3. Git与SVN的主要区别"></a>3. Git与SVN的主要区别</h2><p><strong>SVN是集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><strong>Git是分布式版本控制系统</strong>，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<h2 id="4-Git的历史"><a href="#4-Git的历史" class="headerlink" title="4. Git的历史"></a>4. Git的历史</h2><p>1、同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>2、Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>3、Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>
<p>4、到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>
<p>5、Git是目前世界上最先进的分布式版本控制系统。</p>
<p>6、Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>
<p>7、Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>
<h1 id="第二章：安装"><a href="#第二章：安装" class="headerlink" title="第二章：安装"></a>第二章：安装</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p>打开 [git官网] <a href="https://git-scm.com/，下载git对应操作系统的版本。" target="_blank" rel="noopener">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<h2 id="2-Windows安装"><a href="#2-Windows安装" class="headerlink" title="2. Windows安装"></a>2. Windows安装</h2><p>傻瓜式安装</p>
<p>选择下一步下一步，可以选择安装位置。</p>
<h2 id="3-Liunx安装"><a href="#3-Liunx安装" class="headerlink" title="3. Liunx安装"></a>3. Liunx安装</h2><p>1、如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p>2、老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p>
<p>3、如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<h1 id="第三章：基础-重点"><a href="#第三章：基础-重点" class="headerlink" title="第三章：基础(重点)"></a>第三章：基础(重点)</h1><h2 id="1、学习一下Liunx基本命令"><a href="#1、学习一下Liunx基本命令" class="headerlink" title="1、学习一下Liunx基本命令"></a>1、学习一下Liunx基本命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>查看当前目录下所有的文件</td>
</tr>
<tr>
<td>ll</td>
<td>同上也是查看当前目录下所有文件，但是会显示文件的权限信息</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>touch</td>
<td>创建文本文件</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建文件夹</td>
</tr>
<tr>
<td>rm -r</td>
<td>删除文件夹</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前目录路径信息</td>
</tr>
<tr>
<td>clear</td>
<td>清除屏幕的内容</td>
</tr>
<tr>
<td>vi</td>
<td>编辑文件内容，a 进入编辑模式 esc+：+wq！保存并退出</td>
</tr>
</tbody></table>
<h2 id="2、启动"><a href="#2、启动" class="headerlink" title="2、启动"></a>2、启动</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyf96e2b66-cb3b-4143-a756-07df142f188a.png" alt="img"></p>
<p><strong>点击Git Base来启动这个git，或者鼠标右键选择Git Base来启动</strong></p>
<h2 id="3-Git配置"><a href="#3-Git配置" class="headerlink" title="3. Git配置"></a>3. Git配置</h2><h4 id="1-查看配置"><a href="#1-查看配置" class="headerlink" title="1 查看配置"></a>1 查看配置</h4><p>所有的配置文件，其实都保存在本地！</p>
<p>查看配置 git config -l</p>
<h4 id="2-查看不同级别的配置文件："><a href="#2-查看不同级别的配置文件：" class="headerlink" title="2 查看不同级别的配置文件："></a>2 查看不同级别的配置文件：</h4><p><strong>查看系统config</strong> git config —system —list　　</p>
<p><strong>查看当前用户（global）配置</strong>git config —global —list</p>
<h4 id="3-Git相关的配置文件"><a href="#3-Git相关的配置文件" class="headerlink" title="3 Git相关的配置文件"></a>3 Git相关的配置文件</h4><p>1）、(git<code>安装目录</code>) \etc\gitconfig ：Git 安装目录下的 gitconfig —system 系统级</p>
<p>2）、C:\Users\Administrator\ .gitconfig 只适用于当前登录用户的配置 —global 全局</p>
<p><strong>这里可以直接编辑配置文件，通过命令设置后会响应到这里。下一章节就是</strong></p>
<h2 id="4-设置用户名与邮箱"><a href="#4-设置用户名与邮箱" class="headerlink" title="4. 设置用户名与邮箱"></a>4. 设置用户名与邮箱</h2><p>git config —global user.name “qinjiang” <strong>#名称</strong></p>
<p>git config —global user.email <a href="mailto:616326125@qq.com">616326125@qq.com</a> <strong>#邮箱</strong></p>
<p>只需要做一次这个设置，如果你传递了—global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要—global选项。总之—global为全局配置，不加为某个项目的特定配置。</p>
<h2 id="5-代码托管中心"><a href="#5-代码托管中心" class="headerlink" title="5. 代码托管中心"></a>5. 代码托管中心</h2><p>代码托管中心的任务：维护远程库</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy47cab5d5-8e23-4e36-8fc4-b90cf00f5913.png" alt="img"></p>
<h2 id="6-三个工作区域"><a href="#6-三个工作区域" class="headerlink" title="6. 三个工作区域"></a>6. 三个工作区域</h2><p>Git本地有三个工作区域：<strong>工作目录（Working Directory）</strong>、<strong>暂存区(Stage/Index)</strong>、<strong>资源库(Repository或Git Directory)</strong>。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudybaa79e79-43fe-4907-82ff-7407540dc177.png" alt="img"></p>
<h1 id="第四章：命令行操作"><a href="#第四章：命令行操作" class="headerlink" title="第四章：命令行操作"></a>第四章：命令行操作</h1><h2 id="4-1-、仓库"><a href="#4-1-、仓库" class="headerlink" title="4.1 、仓库"></a>4.1 、仓库</h2><pre><code># 在当前目录新建一个Git代码库
$ git init
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
# 下载一个项目和它的整个代码历史
$ git clone [url]</code></pre><h2 id="4-2、配置"><a href="#4-2、配置" class="headerlink" title="4.2、配置"></a>4.2、配置</h2><pre><code># 显示当前的Git配置
$ git config --list
# 编辑Git配置文件
$ git config -e [--global]
# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="4-3、增加-删除文件"><a href="#4-3、增加-删除文件" class="headerlink" title="4.3、增加/删除文件"></a>4.3、增加/删除文件</h2><pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
# 添加当前目录的所有文件到暂存区
$ git add .
# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p
shell
# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...
# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]
# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]</code></pre><h2 id="4-4、代码提交"><a href="#4-4、代码提交" class="headerlink" title="4.4、代码提交"></a>4.4、代码提交</h2><pre><code># 提交暂存区到仓库区
$ git commit -m [message]
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a
# 提交时显示所有diff信息
$ git commit -v
# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]
# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...</code></pre><h2 id="4-5、分支"><a href="#4-5、分支" class="headerlink" title="4.5、分支"></a>4.5、分支</h2><pre><code># 列出所有本地分支
$ git branch
# 列出所有远程分支
$ git branch -r
# 列出所有本地分支和远程分支
$ git branch -a
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
# 新建一个分支，指向指定commit
$ git branch [branch] [commit]
# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
# 切换到上一个分支
$ git checkout -
# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
# 合并指定分支到当前分支
$ git merge [branch]
# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]</code></pre><h2 id="4-6、标签"><a href="#4-6、标签" class="headerlink" title="4.6、标签"></a>4.6、标签</h2><pre><code># 列出所有tag
$ git tag
# 新建一个tag在当前commit
$ git tag [tag]
# 新建一个tag在指定commit
$ git tag [tag] [commit]
# 删除本地tag
$ git tag -d [tag]
# 删除远程tag
$ git push origin :refs/tags/[tagName]
# 查看tag信息
$ git show [tag]
# 提交指定tag
$ git push [remote] [tag]
# 提交所有tag
$ git push [remote] --tags
# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]</code></pre><h2 id="4-7、查看信息"><a href="#4-7、查看信息" class="headerlink" title="4.7、查看信息"></a>4.7、查看信息</h2><pre><code># 显示有变更的文件
$ git status
# 显示当前分支的版本历史
$ git log
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
# 搜索提交历史，根据关键词
$ git log -S [keyword]
# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s
# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature
# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]
# 显示指定文件相关的每一次diff
$ git log -p [file]
# 显示过去5次提交
$ git log -5 --pretty --oneline
# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn
# 显示指定文件是什么人在什么时间修改过
$ git blame [file]
# 显示暂存区和工作区的差异
$ git diff
# 显示暂存区和上一个commit的差异
$ git diff --cached [file]
# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD
# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]
# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;
# 显示某次提交的元数据和内容变化
$ git show [commit]
# 显示某次提交发生变化的文件
$ git show --name-only [commit]
# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]
# 显示当前分支的最近几次提交
$ git reflog</code></pre><h2 id="4-8、远程同步"><a href="#4-8、远程同步" class="headerlink" title="4.8、远程同步"></a>4.8、远程同步</h2><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]
# 显示所有远程仓库
$ git remote -v
# 显示某个远程仓库的信息
$ git remote show [remote]
# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]
# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]
# 上传本地指定分支到远程仓库
$ git push [remote] [branch]
# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force
# 推送所有分支到远程仓库
$ git push [remote] --all</code></pre><h2 id="4-9、撤消"><a href="#4-9、撤消" class="headerlink" title="4.9、撤消"></a>4.9、撤消</h2><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]
# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]
# 恢复暂存区的所有文件到工作区
$ git checkout .
# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]
# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard
# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]
# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]
# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]
# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop</code></pre><h2 id="4-10-、-其它"><a href="#4-10-、-其它" class="headerlink" title="4.10 、 其它"></a>4.10 、 其它</h2><pre><code># 生成一个可供发布的压缩包
$ git archive</code></pre><h1 id="第五章：分支"><a href="#第五章：分支" class="headerlink" title="第五章：分支"></a>第五章：分支</h1><h2 id="5-1、理解暂缓区域"><a href="#5-1、理解暂缓区域" class="headerlink" title="5.1、理解暂缓区域"></a>5.1、理解暂缓区域</h2><p>文件.git/index是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名和文件的状态信息。以便快速检测文件的变化。 索引中还包含所有Blob类型的SHA-1标识符。文件的内容没有存储在其中， 而是保存在Git对象库.git/objects目录中，文件索引建立了文件和对象库中对象实体之间的对应，</p>
<p>如图，展示了工作区、版本库中的暂存区和版本库之间的关系。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy435a4d4f-e1b0-43e4-8886-360c6a6d5b1b.png" alt="img"></p>
<p>- 图中左侧为工作区，右侧为版本库。在版本库中标记为index的区域是暂存区，标记为master的是master分支代表的目录树。</p>
<p>- HEAD实际是指向master分支的一个“游标”，所以图示的命令中出现的HEAD的地方可以用master来替代。</p>
<p>- objects标志的区域为Git的对象库，实际位于.git/objects目录下。</p>
<p>- 工作区修改（或新增）文件执行git add命令时，暂存区的目录树将被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的索引文件中。</p>
<p>- 执行提交操作（git commit）时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</p>
<p>- 执行git reset HEAD命令时，暂存区的目录树会被重写，会被master分支指向的目录树替换，但是工作区不受影响。</p>
<p>- 执行 git rm —cached <file>命令时，会直接从暂存区删除文件，工作区不做改变。</file></p>
<p>- 执行 git checkout. 或 git checkout — <file>命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</file></p>
<p>- 执行 git checkout HEAD ,或 git checkout HEAD <file> 命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件，这个命令也是极具危险性的，因为不但会清除工作 区中未提交的改动，也会清楚暂存区中为提交的改动。</file></p>
<h2 id="5-2、分支"><a href="#5-2、分支" class="headerlink" title="5.2、分支"></a>5.2、分支</h2><p>　Git 在进行提交操作时，会创建<strong>一个提交对象（commit object）</strong>。该提交对象会包含一个指向提交内容<strong>快照的指针、作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针</strong>。首次<strong>提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象</strong>。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudye097b242-c22b-4055-b170-fdbc776c0cfd.png" alt="img"></p>
<p>假设一个工作目录，包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后把当前版本的文件快照保存到Git 仓库中（objects，Git 使用 blob 对象来保存它们），将校验和加入到暂存区域等待提交：</p>
<p>当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git 仓库中这些校验和保存为树对象。Git 会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyfddc4adb-c73c-4b5c-95d4-b278e9c614be.png" alt="img"></p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 <font color="red"><strong>Git 的默认分支名字是 master</strong></font>。 在多次提交操作之后，你其实已经有一个指向最后<br>那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy6e09d36e-a0f0-43f4-a43f-3009d5cff505.png" alt="img"></p>
<h2 id="5-3、简单的来说"><a href="#5-3、简单的来说" class="headerlink" title="5.3、简单的来说"></a>5.3、简单的来说</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！如果一个平行宇宙有错误了，我们把他毁灭了就可以了。</p>
<p>如下图：</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy26f9ea9e-f377-43d2-b950-b686476cab1e.png" alt="img"></p>
<p><strong>三条分支：master是我们的主分支，其余两个是我们的自己创建的分支</strong></p>
<h2 id="5-4、默认分支"><a href="#5-4、默认分支" class="headerlink" title="5.4、默认分支"></a>5.4、默认分支</h2><p><strong>Git有一个默认的分支：他是master</strong></p>
<p><strong>我们在初始化本地库仓库后他就会出现，自己创建</strong></p>
<h2 id="5-7、常用命令"><a href="#5-7、常用命令" class="headerlink" title="5.7、常用命令"></a>5.7、常用命令</h2><pre><code># 列出所有本地分支
git branch
# 列出所有本地分支加版本信息
git branch -v
# 列出所有远程分支
git branch -r
# 切换分支 
git checkout 分支名
# 新建一个分支，但依然停留在当前分支
git branch [分支名]
# 新建一个分支，并切换到该分支
git checkout -b [分支名]
# 合并指定分支到当前分支 
git merge [分支名]
# 删除分支 
git branch -d [分支名]
# 删除远程分支 
git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="5-8、创建远程分支"><a href="#5-8、创建远程分支" class="headerlink" title="5.8、创建远程分支"></a>5.8、创建远程分支</h2><pre><code>## 1、在当前分支下（一般是master分支），创建muscleape的本地分支分
$ git checkout -b muscleape
Switched to a new branch &#39;muscleape&#39;
## 2、将muscleape分支推送到远程
$ git push origin muscleape
Everything up-to-date
## 3、将本地分支muscleape关联到远程分支muscleape上  
$ git branch --set-upstream-to=origin/muscleape
......
......
......
Branch &#39;muscleape&#39; set up to track remote branch &#39;muscleape&#39; from &#39;origin&#39;
## 4、查看本地分支和远程分支的映射关系
$ git branch -vv
muscleape         f938a3d8e9 [origin/muscleape: gone] 测试test
## 5、查看远程分支
$ git branch -r
origin/muscleape
## 6、查看本地各个分支目前最新的提交
$ git branch -v
muscleape         f938a3d8e9 测试test
## 7、查看远程各个分支目前最新的提交
$ git branch -r -v
origin/muscleape         f938a3d8e9 测试test</code></pre><h2 id="5-9-、冲突解决"><a href="#5-9-、冲突解决" class="headerlink" title="5.9 、冲突解决"></a>5.9 、冲突解决</h2><h3 id="1-、前言"><a href="#1-、前言" class="headerlink" title="1 、前言"></a>1 、前言</h3><p>和svn一样我们写代码的时候我们肯定会去修改同一个文件，那么肯定会出现冲突，git里面的分支冲突怎么解决呢？</p>
<h3 id="2、-解决方式"><a href="#2、-解决方式" class="headerlink" title="2、 解决方式"></a>2、 解决方式</h3><ul>
<li>第一步：编辑文件，删除特殊符号</li>
<li>第二步：把文件修改到满意的程度，保存退出</li>
<li>第三步：git ad [文件名]</li>
<li>第四步：git comit -m “日志信息”  注意：此时 comit 一定不能带具体文件名</li>
</ul>
<p><strong><font color="red">我们在修改的过程中应与团队商量</font></strong></p>
<h1 id="第六章：配置远程仓库"><a href="#第六章：配置远程仓库" class="headerlink" title="第六章：配置远程仓库"></a>第六章：配置远程仓库</h1><h2 id="6-1、远程仓库有哪些"><a href="#6-1、远程仓库有哪些" class="headerlink" title="6.1、远程仓库有哪些"></a>6.1、远程仓库有哪些</h2><ul>
<li>gitHub</li>
<li>gitee(码云)</li>
<li>gitLab</li>
</ul>
<h2 id="6-2、为什么选择GitEE"><a href="#6-2、为什么选择GitEE" class="headerlink" title="6.2、为什么选择GitEE"></a>6.2、为什么选择GitEE</h2><p>他们每一个功能界面都差不多，我们就学习配置GitEE就可以了，因为他网速快方便。</p>
<p>网址：<strong><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></strong></p>
<h2 id="6-3、创建远程仓库"><a href="#6-3、创建远程仓库" class="headerlink" title="6.3、创建远程仓库"></a>6.3、创建远程仓库</h2><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a><strong>1、登录</strong></h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy66e33e4a-7a14-45b7-b216-4b6acf9d163f.png" alt="img"></p>
<h3 id="2、点击右上角"><a href="#2、点击右上角" class="headerlink" title="2、点击右上角"></a>2、点击右上角</h3><p>点击右上角+号选择新建立仓库<br><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy8ff909d9-9438-4ac2-a470-eb588b38cf4e.png" alt="img"></p>
<h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy10b80ed4-ecd5-42cf-940f-2fd96891c295.png" alt="img"></p>
<h3 id="4、拉取代码"><a href="#4、拉取代码" class="headerlink" title="4、拉取代码"></a><strong>4、拉取代码</strong></h3><p>点击复制</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyac762cb6-bd4d-44f5-a5d2-1a440b67d52a.png" alt="img"></p>
<p>命令行输入 <strong><code>git clone https://gitee.com/little_bingedream/lovely-old-sister.git</code></strong></p>
<h2 id="6-4、生成ssh密钥"><a href="#6-4、生成ssh密钥" class="headerlink" title="6.4、生成ssh密钥"></a>6.4、生成ssh密钥</h2><ul>
<li><strong>查看是有已生成公钥任意目录下打开Git Bash</strong></li>
</ul>
<pre><code>cd ~/.ssh</code></pre><ul>
<li>若命令行提示bash: cd: ~./ssh: No such file or directory则说明还没有配置好 ssh 文件生成ssh 公钥：首先配置用户信息</li>
</ul>
<pre><code>git config --global user.name = &quot;xxx&quot;
git config --global user.email = &quot;xxx@xxxx.xxx&quot;</code></pre><ul>
<li>生成公钥</li>
</ul>
<pre><code>cd ~
ssh-keygen -t rsa -C &quot;xxxx@xxx.xxx&quot;</code></pre><p>他会出现的一下信息：(注意：下面的不是命令)</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (c/User/%USERNAME%/.ssh/id_rsa): //不用修改(默认存储地点)
Enter passphrase (empty for no passphrase):  //可以为空
Enter same passphrase again:</code></pre><ul>
<li>查看公钥</li>
</ul>
<pre><code>cd ~/.ssh            #//进入. ssh 目录：
cat id_rsa.pub    #或者 vim id_rsa.pub</code></pre><h2 id="6-5、配置ssh公钥"><a href="#6-5、配置ssh公钥" class="headerlink" title="6.5、配置ssh公钥"></a>6.5、配置ssh公钥</h2><p><strong>我们登录码云进入到个人设置中，然后点击ssh公钥，将我们自己的公钥信息设置进去：</strong></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy68fc2f66-86ca-4599-871c-4270fbc3be03.png" alt="img"></p>
<h2 id="6-6、gitee拉取新成员加入"><a href="#6-6、gitee拉取新成员加入" class="headerlink" title="6.6、gitee拉取新成员加入"></a>6.6、gitee拉取新成员加入</h2><ul>
<li>1、<strong>进入仓库的详情页面</strong></li>
</ul>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy98f2e3fd-6ff0-4c5e-8bf2-bb76b84f7ba4.png" alt="img"></p>
<ul>
<li>2、<strong>选择成员</strong></li>
</ul>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy5b0ce8d1-7535-49d2-8f48-372ed99bfa23.png" alt="img"></p>
<ul>
<li>3、发送链接</li>
</ul>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy389a7322-2c2d-4b40-84ee-fd2c0b9a0db1.png" alt="img"></p>
<h1 id="第七章：Idea配置并使用"><a href="#第七章：Idea配置并使用" class="headerlink" title="第七章：Idea配置并使用"></a>第七章：Idea配置并使用</h1><h2 id="7-1、安装GitEE插件"><a href="#7-1、安装GitEE插件" class="headerlink" title="7.1、安装GitEE插件"></a>7.1、安装GitEE插件</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudye423806e-019a-4344-baed-17b45af44dab.png" alt="img"></p>
<p>注意：安装完后重启idea</p>
<h2 id="7-2、拉取代码"><a href="#7-2、拉取代码" class="headerlink" title="7.2、拉取代码"></a>7.2、拉取代码</h2><p>到gitee或者github上粘贴代码地址： <strong><a href="https://gitee.com/\" target="_blank" rel="noopener">https://gitee.com/\</a></strong>*<em>*</em>*<em>*</em>*<strong>*.git</strong></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy550f6bb2-c441-4ff8-b1b1-de3f35fd3e30.png" alt="img"><br>选取过后下一步下一步即可打开新窗口</p>
<h2 id="7-3、添加代码"><a href="#7-3、添加代码" class="headerlink" title="7.3、添加代码"></a>7.3、添加代码</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyb26f8364-16e6-442f-94c1-5f460bb4cf61.png" alt="img"></p>
<h2 id="7-4、提交代码"><a href="#7-4、提交代码" class="headerlink" title="7.4、提交代码"></a>7.4、提交代码</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy110cb0a4-a882-4689-9596-8bc28f230cec.png" alt="img"></p>
<h2 id="7-5、提交代码"><a href="#7-5、提交代码" class="headerlink" title="7.5、提交代码"></a>7.5、提交代码</h2><p><strong>提交代码到gitee上</strong></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy4b47f6a9-f4b8-4d4f-ad19-7b8441d7007d.png" alt="img"></p>
<h2 id="7-6、更新代码"><a href="#7-6、更新代码" class="headerlink" title="7.6、更新代码"></a>7.6、更新代码</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy79d86712-a1c4-4e53-bd44-3ea6d427a50e.png" alt="img"></p>
<h2 id="7-7、查提交历史"><a href="#7-7、查提交历史" class="headerlink" title="7.7、查提交历史"></a>7.7、查提交历史</h2><p>查看我们代码提交的历史，方便我们查看谁把分支里面的代码搞乱</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy4e4f5357-e886-4980-8645-d0c55a7b5df5.png" alt="img"></p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy372e9ae5-606c-49c6-9262-eb7f20f52e3c.png" alt="img"></p>
<h2 id="7-8、创建分支"><a href="#7-8、创建分支" class="headerlink" title="7.8、创建分支"></a>7.8、创建分支</h2><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyd17e0dc6-fe38-430d-ab0d-01341a5f690f.png" alt="img"></p>
<h3 id="第二步：-1"><a href="#第二步：-1" class="headerlink" title="第二步："></a>第二步：</h3><p><strong>输入自己要创建的分支名字</strong></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy2e95f889-9d2e-4feb-b79a-65e3f6b93c70.png" alt="img"></p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p><strong>提交代码即可</strong></p>
<h2 id="7-9、合并分支代码"><a href="#7-9、合并分支代码" class="headerlink" title="7.9、合并分支代码"></a>7.9、合并分支代码</h2><h3 id="第一步：-1"><a href="#第一步：-1" class="headerlink" title="第一步："></a>第一步：</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy370882d7-0572-4556-964c-db01285074ba.png" alt="img"></p>
<h3 id="第二步：-2"><a href="#第二步：-2" class="headerlink" title="第二步："></a>第二步：</h3><p>选择要合并的分支</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudy0ce5621b-a8f5-4473-bfcd-2ff1d28c29f5.png" alt="img"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步:"></a>第三步:</h3><p><strong>如果出现冲突的话</strong>我们需要自己来解决，也可以选择idea的一键解决冲突</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/27/kuangstudyab303307-6bfb-492f-a011-4dbddc3d95e5.png" alt="img"></p>
<h3 id="第三步：-1"><a href="#第三步：-1" class="headerlink" title="第三步："></a>第三步：</h3><p><strong>提交代码</strong></p>
<h2 id="idea安装Git"><a href="#idea安装Git" class="headerlink" title="idea安装Git"></a>idea安装Git</h2><ul>
<li><p>[下载地址]:<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p>
</li>
<li><p>安装默认</p>
</li>
<li><p>运行测试：win+r,cmd  打开控制台，输入git指令，看到下图即表示安装成功</p>
</li>
<li><p><img src="https://stepimagewm.how2j.cn/5793.png" alt="运行测试"></p>
</li>
</ul>
<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><ul>
<li><p>菜单-&gt;settings-&gt;Version Control-&gt;Git-&gt;Path to Git executable: 设置为<a href="https://how2j.cn/k/idea/idea-git-install/1359.html" target="_blank" rel="noopener">安装git</a>中所安装的git.exe</p>
</li>
<li><p><img src="https://stepimagewm.how2j.cn/5794.png" alt="为IDEA指定git路径"></p>
</li>
<li><p>接下来为github设置账号密码：<br>菜单-&gt;settings-&gt;Version Control-&gt;GitHub-&gt;Create API Token</p>
</li>
<li><p><img src="https://stepimagewm.how2j.cn/5795.png" alt="设置github账号"></p>
</li>
</ul>
<h2 id="idea-pull项目"><a href="#idea-pull项目" class="headerlink" title="idea pull项目"></a>idea pull项目</h2><ul>
<li>checkout：菜单-&gt;VCS-&gt;Chekout from Version Control-&gt;GitHub</li>
<li><img src="https://stepimagewm.how2j.cn/5797.png" alt="checkout"></li>
<li>输入项目参数：Git Repositor URL:<a href="https://github.com/how2j/higit.git" target="_blank" rel="noopener">https://github.com/how2j/higit.git</a><br>Parent Directory: e:\project<br>Directory Name: higit<br>然后点击 Clone</li>
<li><img src="https://stepimagewm.how2j.cn/5798.png" alt="输入项目参数"></li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5</title>
    <url>/Mr-lee-MQ.hithub.io/2020/07/13/HTML5/</url>
    <content><![CDATA[<h1 id="HTML详解"><a href="#HTML详解" class="headerlink" title="HTML详解"></a>HTML详解<a id="more"></a></h1><h2 id="初识HTML"><a href="#初识HTML" class="headerlink" title="初识HTML"></a>初识HTML</h2><ul>
<li>Hper Text Markup Language(超文本标记语言)</li>
<li>W3C     万维网联盟</li>
<li>W3C标准包括<ul>
<li>结构化标准语言（HTML    XML）</li>
<li>表现标准语言（CSS）</li>
<li>行为标准（DOM，ECMAScript）</li>
</ul>
</li>
</ul>
<h2 id="HTML的基本结构"><a href="#HTML的基本结构" class="headerlink" title="HTML的基本结构"></a>HTML的基本结构</h2><p>网页头部</p>
<pre><code class="HTML">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;我的第一个网页&lt;/title&gt;
&lt;/head&gt;</code></pre>
<p>主体部分</p>
<pre><code class="html">&lt;body&gt;

&lt;/body&gt;</code></pre>
<ul>
<li><p>&lt; body&gt;  ，&lt; /body&gt;等成对出现的标签（&lt; body&gt; 为开放标签     &lt; /body&gt;为闭合标签 ）</p>
</li>
<li><p>&lt; meta charset=”UTF-8”&gt;为自闭合标签</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE：      &gt;      &lt;!--告诉浏览器要使用什么规范--&gt;</code></pre>
<pre><code class="html">&lt;title&gt;我的第一个程序&lt;/title&gt;    &lt;!--网页的标题--&gt;</code></pre>
<pre><code class="html">&lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;!--mate 描述性标签，用来描述网站的信息，可做SEO--&gt;</code></pre>
<pre><code>&lt;meta  name =&quot;keywords&quot; content=&quot;西部开源&quot; &gt;
&lt;meta name=&quot;description&quot; content=&quot;可以学JAVA&quot; &gt;    &lt;！--网站描述--&gt;</code></pre><h2 id="网页基本标签"><a href="#网页基本标签" class="headerlink" title="网页基本标签"></a>网页基本标签</h2><ul>
<li><p>标题标签</p>
<ul>
<li>（&lt; h1&gt;一级标签&lt; /h1&gt;）</li>
<li>（&lt; h2&gt;一级标签&lt; /h2&gt;）</li>
<li>（&lt; h3&gt;一级标签&lt; /h3&gt;）</li>
</ul>
</li>
<li><p>段落标签</p>
<ul>
<li>（&lt; p&gt;段落&lt; /p&gt;）</li>
</ul>
</li>
<li><p>换行标签</p>
<ul>
<li>（br  换行）自闭合标签</li>
</ul>
</li>
<li><p>水平线标签</p>
<ul>
<li>（&lt; /hr&gt;）</li>
</ul>
</li>
<li><p>字体样式标签</p>
<ul>
<li>粗体（&lt; stong&gt;  &lt; /stong&gt;）</li>
<li>斜体（&lt; em&gt;&lt; /em&gt;）</li>
</ul>
</li>
<li><p>特殊符号（&amp;     ）</p>
<ul>
<li>空格（&amp;nbsp；）</li>
<li>大于号   (&amp;gt ;）</li>
<li>小于号   (&amp;lt ;)</li>
<li>版权符号（&amp;copy；）</li>
</ul>
</li>
</ul>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><ul>
<li>img标签学习<ul>
<li>&lt; img src&gt;<ul>
<li>src     图片地址<ul>
<li>相对地址（常用）../      –上一级目录</li>
<li>绝对地址</li>
</ul>
</li>
<li>alt     图片名字</li>
<li>title     鼠标悬停显示的文字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><pre><code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;       &lt;!--必填，表示要跳转的网址</code></pre><ul>
<li><p>target     以何种方式打开窗口</p>
<ul>
<li>blank     在一个新的网页中打开</li>
<li>self         在本网页中打开</li>
</ul>
</li>
<li><p>锚链接</p>
<ul>
<li>需要一个锚标记</li>
<li>#加标记name </li>
</ul>
</li>
<li><p>功能性链接</p>
<ul>
<li><p>邮件链接： mailto</p>
</li>
<li><p>QQ链接：</p>
</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::52&quot; alt=&quot;点击我&quot; title=&quot;点击我&quot;/&gt;&lt;/a&gt;</code></pre>
<h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><ul>
<li>块元素<ul>
<li>无论内容多少，该元素独占一行</li>
<li>（p、h1-h6）</li>
</ul>
</li>
<li>行内元素<ul>
<li>内容撑开宽度，左右都是行元素的可以排在一行</li>
<li>（a.strong.em…..）</li>
</ul>
</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>无序列表</li>
</ul>
<pre><code>&lt;ol&gt;
    &lt;li&gt;JAVA&lt;/li&gt;
    &lt;li&gt;前端&lt;/li&gt;
    &lt;li&gt;C语言&lt;/li&gt;

&lt;/ol&gt;
</code></pre><ul>
<li>有序列表</li>
</ul>
<pre><code>&lt;ul&gt;
    &lt;li&gt;JAVA&lt;/li&gt;
    &lt;li&gt;前端&lt;/li&gt;
    &lt;li&gt;C语言&lt;/li&gt;

&lt;/ul&gt;</code></pre><ul>
<li>自定义列表</li>
</ul>
<pre><code>&lt;dl&gt;
    &lt;dt&gt;学科&lt;/dt&gt;
    &lt;dd&gt;JAVA&lt;/dd&gt;
    &lt;dd&gt;Linux&lt;/dd&gt;
&lt;/dl&gt;</code></pre><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><ul>
<li><p>表格标签table</p>
<ul>
<li><p>行标签   tr</p>
</li>
<li><p>列标签   td</p>
</li>
<li><p>边框   border</p>
</li>
<li><p>跨列   colspan</p>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;td colspan=&quot;4&quot;&gt;1-1&lt;/td&gt;</code></pre><ul>
<li>跨行  rowspan</li>
</ul>
<pre><code>&lt;td rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt;</code></pre><h2 id="视频和音频"><a href="#视频和音频" class="headerlink" title="视频和音频"></a>视频和音频</h2><pre><code>&lt;video src=&quot;../resources/video/NOGIZAKA46_&gt;&lt;/video&gt;</code></pre><ul>
<li>src     资源路径</li>
<li>controls    控制条 </li>
<li>autoplay    自动播放</li>
</ul>
<pre><code>&lt;audio src=&quot;../resources/audio/LOSER%20-%20米津玄師.mp3&quot;&gt;&lt;/audio&gt;</code></pre><ul>
<li>controls    控制条 </li>
<li>autoplay    自动播放</li>
</ul>
<h2 id="页面结构分析"><a href="#页面结构分析" class="headerlink" title="页面结构分析"></a>页面结构分析</h2><ul>
<li>header    标题头部区域的内容</li>
<li>footer     标题脚部区域的内容</li>
<li>section    Web页面中的一块独立区域</li>
<li>article      独立的文章内容</li>
<li>aside      相关内容或应用</li>
<li>nav      导航类辅助内容</li>
</ul>
<h2 id="iframe内联框架"><a href="#iframe内联框架" class="headerlink" title="iframe内联框架"></a>iframe内联框架</h2><pre><code class="html">&lt;iframe src=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt;&lt;/iframe&gt;</code></pre>
<ul>
<li>src    地址</li>
<li>w-h    高度宽度   </li>
</ul>
<h2 id="表单语法"><a href="#表单语法" class="headerlink" title="表单语法"></a>表单语法</h2><pre><code>&lt;form action=&quot;&quot;&gt;&lt;/form&gt;</code></pre><ul>
<li>action   表单提交的位置，可以是网站，也可以是一个请求处理的地址</li>
<li>method    post，get 提交方式<ul>
<li>get     信息可以在url中看到，不安全，高速</li>
<li>post    比较安全，传输大文件</li>
</ul>
</li>
</ul>
<p>文本输入框    input</p>
<ul>
<li>type     指定元素类型<ul>
<li>text  文本框</li>
<li>password    密码框</li>
<li>submit    提交</li>
<li>reset    重置</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;h1&gt;注册&lt;/h1&gt;
&lt;form action=&quot;我的第一个程序.html&quot; method=&quot;post&quot;&gt;
    &lt;p&gt;用户户名：&lt;input type=&quot;text&quot;name=&quot;username&quot;&gt;&lt;/p&gt;
    &lt;p&gt;密码：&lt;input type=&quot;password &quot;name=&quot;psd&quot; &gt;&lt;/p&gt;
    &lt;p&gt;
        &lt;input type=&quot;submit&quot;&gt;
        &lt;input type=&quot;reset&quot;&gt;
    &lt;/p&gt;
&lt;/form&gt;</code></pre>
<h3 id="表单元素格式"><a href="#表单元素格式" class="headerlink" title="表单元素格式"></a>表单元素格式</h3><ul>
<li>type    指定元素类型      （都需要name属性）<ul>
<li>text   文本框（默认）</li>
<li>password    密码框</li>
<li>checkbox   单选框</li>
<li>radio   单选框       必须有初值，且单选框的name需一致</li>
<li>submit    按钮提交</li>
<li>reset    按钮重置</li>
<li>file     文件域</li>
<li>hidden 隐藏域</li>
<li>image   图片点击</li>
<li>button   按钮</li>
</ul>
</li>
<li>name    指定表单元素的名称</li>
<li>value    元素的初始值      type为radio时必须指定一个值</li>
<li>size   指定表单元素的初始宽度。当type为text或password时，表单元素的大小以字符为单位。对于其它类型，宽度以像素为单位</li>
<li>maxlength    type为text或password时，输入的最大字符</li>
<li>checked     type为radio或checkbox时，指定按钮是否被选中</li>
</ul>
<p>单选框   radio</p>
<pre><code class="html">&lt;p&gt;
        &lt;input type=&quot;radio&quot;value=&quot;boy&quot;  name=&quot;sex&quot; /&gt;男
        &lt;input type=&quot;radio&quot;value=&quot;girl&quot; name=&quot;sex&quot; /&gt;女
    &lt;/p&gt;</code></pre>
<p>多选框    checkbox</p>
<ul>
<li>checked    默认选中</li>
</ul>
<pre><code class="html">&lt;p&gt;
        &lt;input type=&quot;checkbox&quot; value=&quot;game&quot;name=&quot;hobby&quot; &gt;游戏
        &lt;input type=&quot;checkbox&quot; value=&quot;go&quot;name=&quot;hobby&quot; checked&gt;逛街
        &lt;input type=&quot;checkbox&quot; value=&quot;hua&quot;name=&quot;hobby&quot; &gt;化妆
    &lt;/p&gt;</code></pre>
<p>按钮  button</p>
<pre><code class="html">&lt;input type=&quot;button&quot;name=&quot;but1&quot; value=&quot;点击&quot;/&gt;
&lt;input type=&quot;image&quot;src=&quot;../resources/image/mmexport1564926230808.jpg&quot;alt=&quot;tutu&quot;width=&quot;200&quot;height=&quot;200&quot;/&gt;</code></pre>
<p>下拉框/列表框      select</p>
<ul>
<li><p>select    列表</p>
</li>
<li><p>option  value=“      ”     选项的值</p>
</li>
</ul>
<pre><code class="html">&lt;select name=&quot;列表名称&quot;&gt;
        &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt;
        &lt;option value=&quot;ruishi&quot;&gt;瑞士&lt;/option&gt;
        &lt;option value=&quot;deguo&quot;&gt;德国&lt;/option&gt;
        &lt;option value=&quot;meiguo&quot;&gt;美国&lt;/option&gt;
    &lt;/select&gt;</code></pre>
<p>文本域   textarea</p>
<ul>
<li>cols   长度</li>
<li>rows   宽度</li>
</ul>
<pre><code class="html">&lt;textarea name=&quot;textarea&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</code></pre>
<p>文件域    file</p>
<pre><code class="html"> &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;
    &lt;input type=&quot;button&quot; name=&quot;bon1&quot; value=&quot;上传&quot; &gt;</code></pre>
<p>邮件验证     email</p>
<pre><code>&lt;input type=&quot;email&quot;name=&quot;email&quot;&gt;</code></pre><p>URL验证   url</p>
<pre><code>&lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;</code></pre><p>数字验证  number</p>
<ul>
<li>max</li>
<li>min</li>
<li>step     递增或递减</li>
</ul>
<pre><code>&lt;input type=&quot;number&quot;name=&quot;number&quot; max=&quot;100&quot;min=&quot;10&quot;step=&quot;1&quot; &gt;</code></pre><p>滑块     range</p>
<ul>
<li>max</li>
<li>min</li>
<li>step    递增或递减 </li>
</ul>
<pre><code class="html">&lt;input type=&quot;range&quot;name=&quot;huakuai&quot;max=&quot;100&quot;min=&quot;1&quot;step=&quot;1&quot;&gt;</code></pre>
<p>搜索框   search</p>
<pre><code class="html">&lt;input type=&quot;search&quot;name=&quot;sousuo&quot;&gt;</code></pre>
<h2 id="表单的应用"><a href="#表单的应用" class="headerlink" title="表单的应用"></a>表单的应用</h2><ul>
<li><p>只读域   readonly</p>
<pre><code class="html">&lt;input type=&quot;radio&quot;value=&quot;boy&quot;  name=&quot;sex&quot; readonly/&gt;男</code></pre>
</li>
<li><p>禁用域    disabled</p>
</li>
</ul>
<pre><code class="html">&lt;input type=&quot;checkbox&quot; value=&quot;game&quot;name=&quot;hobby&quot;  disabled&gt;游戏</code></pre>
<ul>
<li>隐藏域   hidden</li>
</ul>
<pre><code class="html">&lt;input type=&quot;password &quot;name=&quot;psd&quot; hidden&gt;</code></pre>
<ul>
<li>增强鼠标的可用性   lable<ul>
<li>for=“进入某个id中”</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;label for=&quot;mark&quot;&gt;你点我试试&lt;label&gt;
        &lt;input type=&quot;text&quot;&gt;</code></pre>
<h2 id="表单初级验证"><a href="#表单初级验证" class="headerlink" title="表单初级验证"></a>表单初级验证</h2><ul>
<li>提示信息：placeholder=“请输入用户名”</li>
<li>非空判断：required</li>
<li>正则表达式:    pattern     百度可得</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的搭建</title>
    <url>/Mr-lee-MQ.hithub.io/2020/05/24/Hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="软件安装部署及更新"><a href="#软件安装部署及更新" class="headerlink" title="软件安装部署及更新"></a>软件安装部署及更新<a id="more"></a></h1><h2 id="hexo-github-搭建的个人博客"><a href="#hexo-github-搭建的个人博客" class="headerlink" title="hexo + github 搭建的个人博客"></a>hexo + github 搭建的个人博客</h2><p>源于 <a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
<h2 id="hexo-gitee-搭建的个人博客"><a href="#hexo-gitee-搭建的个人博客" class="headerlink" title="hexo + gitee 搭建的个人博客"></a>hexo + gitee 搭建的个人博客</h2><p>源于 <a href="https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#more" target="_blank" rel="noopener">https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#more</a></p>
<h2 id="搭建完成后更换主题"><a href="#搭建完成后更换主题" class="headerlink" title="搭建完成后更换主题"></a>搭建完成后更换主题</h2><ul>
<li>安装主题</li>
</ul>
<p>git clone –depth=1 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus.git" target="_blank" rel="noopener">https://github.com/JoeyBling/hexo-theme-yilia-plus.git</a> ./yilia-plus</p>
<ul>
<li>配置</li>
</ul>
<p>修改hexo根目录下的 _config.yml ➡️ theme: yilia-plus</p>
<ul>
<li>更新</li>
</ul>
<p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
<p>源于 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank" rel="noopener">https://github.com/JoeyBling/hexo-theme-yilia-plus</a></p>
<p>用Hexo写一篇博客</p>
<pre><code>$ hexo n &quot;我的第一篇博客&quot;
INFO  Created: E:\bolg\source\_posts\我的第一篇博客.md</code></pre><p>编辑完保存文件，重启Hexo服务</p>
<pre><code> hexo clean          # 清除所有记录 
$ hexo generate       # 生成静态网页 简写：hexo g
$ hexo server         # 启动服务 简写：hexo s</code></pre><p>或者用&amp;&amp;连接起来也可以</p>
<pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2020年8月4日11-36-49"><a href="#2020年8月4日11-36-49" class="headerlink" title="2020年8月4日11:36:49"></a>2020年8月4日11:36:49</h3><ul>
<li><p>将图片存放在同名文件夹中，放到图床上，然后将Markdown的详细链接放到博客中即可插入图片</p>
</li>
<li><p>网易云音乐更换音乐<a href="https://music.163.com/#，选择外链id后进入主题下config文件下更改音乐id" target="_blank" rel="noopener">https://music.163.com/#，选择外链id后进入主题下config文件下更改音乐id</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多线程</title>
    <url>/Mr-lee-MQ.hithub.io/2020/10/17/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程详解"><a href="#多线程详解" class="headerlink" title="多线程详解 "></a>多线程详解 <a id="more"></a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>线程简介</li>
<li><strong>线程实现（重点）</strong></li>
<li>线程状态</li>
<li><strong>线程同步（重点）</strong></li>
<li>线程通信问题</li>
<li>高级主题</li>
</ul>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="Process（进程）和Thread（线程）"><a href="#Process（进程）和Thread（线程）" class="headerlink" title="Process（进程）和Thread（线程）"></a>Process（进程）和Thread（线程）</h3><ul>
<li>说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</li>
<li>而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。</li>
<li>通常一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程就是CPU调度和执行的单位。</li>
</ul>
<p><strong>注意：</strong>很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，所以就有同时执行的错觉。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li><p>线程就是独立的执行路径。</p>
</li>
<li><p>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；</p>
</li>
<li><p>main（）称之为主线程，为系统的入口，用于执行整个程序。</p>
</li>
<li><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预。</p>
</li>
<li><p>对同一份资料操作时，会存在资源抢夺的问题，需要加入并发控制。</p>
</li>
<li><p>线程会带来额外的开销，如cpu调度时间，并发控制开销。</p>
</li>
<li><p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。</p>
</li>
</ul>
<h2 id="线程创建（三种）"><a href="#线程创建（三种）" class="headerlink" title="线程创建（三种）"></a>线程创建（三种）</h2><ul>
<li><p>Thread class        继承Thread类(重点)</p>
</li>
<li><p>Runnable接口        实现Runnable接口(重点)</p>
</li>
<li><p>Callable接口       实现Callable接口(了解)</p>
</li>
</ul>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul>
<li>自定义线程类继承Thread类。</li>
<li>重写run()方法。</li>
<li>创建线程对象，调用start()方法启动线程。</li>
</ul>
<pre><code class="java">//创建线程方法一:继承Thread类，重写run方法，调用start开启线程
public class TestThread extends Thread{
    @Override
    public void run(){
        //run方法线程体
        for(int i = 0; i &lt;20; i++){
            System.out.println(&quot;我早看代码&quot;);
        }
    }
    public static void main(String[] args){
        //main线程，主线程
        //创建一个线程对象
        TestThread1 testThread1 = new TestThread();
        //调用start()方法开启线程
        testThread.start();

        for(int i = 0; i &lt; 200; i++){
            System.out.println(&quot;我在学习多线程--&quot;+i);
        }
    }
}</code></pre>
<p><strong>run方法和Thread.start方法的区别</strong></p>
<p>run方法是按照调用的顺序执行,而Thread.start方法则是有cpu安排顺序。</p>
<h3 id="网图下载"><a href="#网图下载" class="headerlink" title="网图下载"></a>网图下载</h3><pre><code class="java">//需要导包 commons.io.FileUtils
//练习Thread，实现多线程同步下载图片
public class TestThread2 extends Thread {
    private String url;//网络图片地址
    private String name;//保存的文件名

    public TestThread2(String url,String name){
        this.url = url;
        this.name = name;
    }

    //下载图片的执行体
    @Override
    public void run(){
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url,name);
        Syetem.out.println(&quot;下载了文件名为:&quot;+name);
    }
    public static void main(String[] args){
        TestThread2 t1 = new TestThread2(url,name);
        TestThread2 t2 = new TestThread2(url,name);
        TestThread2 t3 = new TestThread2(url,name);
        //并非按照顺序下载，同时下载。
        t1.start();
        t1.start();
        t1.start();
    }
}
//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try{
            FileUtils.copyURLTOFile(new URL(url),new FIle(name));
        }catch(IOException e){
            e.printStackTrace();
            System.out.println(&quot;IO异常，downloader方法出现异常&quot;);
        }
    }
}</code></pre>
<h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><ul>
<li>定义MyRunnable类实现的Runnable接口</li>
<li>实现run（）方法，编写线程执行体</li>
<li>创建线程对象，调用start（）方法启动线程</li>
</ul>
<pre><code class="java">//大体实现步骤
public class StartThread3 implements Runnable{
    @Override
    public void run(){
        //线程体
        for(int i = 0;i &lt; 20; i++){
            System.out.println(&quot;我在听课&quot;);
        }
    }
    //创建实现类对象
    StartTjread3 st = new StartThread3();
    //创建代理类对象
    Thread thread = new Thread(st);
    //启动
    thread.start();
}</code></pre>
<pre><code class="java">//创建线程方式2:实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。
public class TestThread imlements Runnable{
    @Override
    public void run(){
        //run方法线程体
        for(int i = 0;i &lt;200; i++){
            System.out.println(&quot;我在看代码&quot;+i);
        }
    }
    public static void main(String[] args){
        //创建runnable接口的实现类对象
        TestThread3 testThread3 = new TestThread3();
        //创建线程对象，通过线程对象来开启我们的线程，代理。
        //Thread thread = new Thread(testThread3);

        //thread.start();
        new Thread(testThread3).start();
        for (int i = 0;i &lt; 1000; i++){
            System.out.println(&quot;我在学习多线程&quot;+i);
        }
    }
}</code></pre>
<p><strong>小结：</strong></p>
<ul>
<li>继承Thread类<ul>
<li>子类继承Thread类具有多线程能力。</li>
<li>启动线程：子类对象.start()</li>
<li>不建议使用：避免OOP单继承局限性</li>
</ul>
</li>
<li><strong>实现Runnable接口</strong><ul>
<li>实现接口Runnable具有多线程的能力。</li>
<li>启动线程:传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。</strong></li>
</ul>
</li>
</ul>
<h2 id="初识并发问题"><a href="#初识并发问题" class="headerlink" title="初识并发问题"></a>初识并发问题</h2><pre><code class="java">//多个线程同时操作同一个对象
//买火车票的例子
//发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱。
public class TestThread4 implements Runnable{

    //票数
    private int ticketNums = 10;

    @Override
    public void run(){
        while (ture){
            if(ticketNums&lt;=0){
                break;
            }
            //模拟延时
            try{
                Thread.sleep(200);
            }catch(InterruptedException e){
                e.prontStartTrace();
            }

            System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿了第&quot;+ticketNums--+&quot;票&quot;);
        }
    }
    public static void main(String[] args){
        TestThread4 ticket = new TestThread4();

        new Thread(ticket,&quot;小明&quot;).start();
        new Thread(ticket,&quot;老师&quot;).start();
        new Thread(ticket,&quot;黄牛党&quot;).start();

    }
}
//输出发现小明，老师，黄牛党可能拿到相同的票</code></pre>
<h2 id="案例：龟兔赛跑"><a href="#案例：龟兔赛跑" class="headerlink" title="案例：龟兔赛跑"></a>案例：龟兔赛跑</h2><ul>
<li>首先来个赛道距离，然后要离终点越来越近</li>
<li>判断比赛是否结束</li>
<li>打印出胜利者</li>
<li>龟兔赛跑开始</li>
<li>故事中的乌龟赢的，兔子需要睡觉，所以我们来模拟兔子睡觉</li>
<li>终于，乌龟赢得了比赛</li>
</ul>
<pre><code class="java">//模拟龟兔赛跑
public class Race implements Runnable{
    @Override
    public void run(){

        for (int i = 0;i &lt;=100; i++){

            //模拟兔子休息
            if(Thread.currentThread().getName().equlas(&quot;兔子&quot;)&amp;&amp; i%10==0){
                try{
                    Thread.sleep(200);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        //判断比赛是否结束
        boolean flog = gameOver(i);  
        //如果比赛结束了，就停止程序
        if(flag){
            break;
        }    System.out.println(Thread.currentThread().getName()+&quot;--&gt;跑了&quot;+i+&quot;步&quot;);
        }
    }
    //判断是否完成比赛
    private boolean gameOver(int steps){
        //判断是否有胜利者
        if(winner!= null){
            //已经存在胜利者了
            return true;
        }{
            if (steps&gt;= 100){
                winner = Thread.currentThread().getName();
                System.out.println(&quot;winner is &quot;+winner);
                return true;
            }
        }
        return flase;
    }
    public static void main(String[] args){
        Race race = new Race();

        new Thread(race, &quot;兔子&quot;).start();
        new Thread(race, &quot;乌龟&quot;).start();

    }
}</code></pre>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul>
<li>实现Callable接口，需要返回值类型</li>
<li>重写call方法，需要抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：ExecutorService  ser = Executors.newFixedThreadPool(1);</li>
<li>提交执行:Future<Boolean> result = ser.submit(t1);</Boolean></li>
<li>获取结果:boolean r1 = result.get();</li>
<li>关闭服务:ser.shutdownNow(); </li>
</ul>
<pre><code class="java">//线程创建方式三：实现callable接口
/*
callable的好处
1.可以定义返回值
2.可以抛出异常
*/
public class TestCallable implements Callable&lt;Boolean&gt;{

    private String url;//网络图片地址
    private String name;//保存的文件名

    public TestCallable(String url,String name){
        this.url = url;
        this.name = name;
    }
    //下载图片线程的执行体
    @Override 
    public Boolean call(){
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url,name);
        System.out.println(&quot;下载了文件名为:&quot;+name);
        return true;
    }

    public static void main(String[] args){
        TestCallable t1 = new TestCallable(&quot;http://blog.kuangstudy.com/usr/themes/handsome/usr/img/sj/1.jpg&quot;);
        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);

        //执行提交
        Future&lt;Boolean&gt; r1 = ser.submit(t1);

        //获取结果
        boolean rs1 = r1.get();
        System.out.println(rs1);
        //关闭服务
        ser.shutdownNow();
    }



}</code></pre>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><pre><code class="java">//静态代理模式总结
//真实对象和代理对象都实现一个接口
//代理对象要代理真实角色
//好处：
    //代理对象可以做很多真实对象做不了的事情
    //真实对象专注做自己的事情

public class StaticProxy{
    public static void main(String[] args){
        You you = new You();//你要结婚

        new Thread (()-&gt;System.out.println(&quot;我爱你&quot;)).start();

        WeddingCompany weddingCompany = new WeddingCompany(you);
        weddingCompany.HappyMarry();
    }
}
interface Marry{
    void HappyMarry();
}
//真实角色，你去结婚
class You implements Marry{
    @Override
    public void HappyMarry(){
        System.out.println(&quot;秦老师要结婚了。&quot;);
    }
}

//代理角色
class weddingCompany implements Marry{
    private Marry target;

    public WeddingCompany (Marry target){
        this.target.HappyMarry();
        after();
    }

    private void after(){
        System.out.println(&quot;结婚之前，布置现场&quot;);
    }
    private void before(){
        System.out.println(&quot;结婚之后，收尾款&quot;);

    }
}</code></pre>
<h2 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h2><ul>
<li><p>希腊字母表中排序第十一位的字母，英语名称为Lamda</p>
</li>
<li><p>避免匿名内部类定义过多</p>
</li>
<li><p>其实质属于函数式编程的概念</p>
</li>
<li><blockquote>
<p>new Thread (()-&gt;System.out.println(“多线程学习…”)).start(</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>为什么使用lambda表达式</p>
<ul>
<li>避免匿名内部类定义过多</li>
<li>可以让你的代码看起来很简洁</li>
<li>去掉了一堆没有意义的代码，只留下核心的逻辑</li>
</ul>
</li>
<li><p>函数式接口的定义：</p>
<ul>
<li><p>任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口。</p>
<pre><code class="java">public interface Runnable{
    public abstract void run();
}</code></pre>
</li>
<li><p>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">//推导lambda表达式
Public class TestLambda{
    //3.静态内部类
    static class Like2 implements ILike{
        @Override
        public void lambda(){
            System.out.println(&quot;I Like Lambda2&quot;);
        }
    }
    public static void main(String[] args){
        ILike like = new Like();
        like.lambda();

        like = new Like2();
        like.lambda();

        //4.局部内部类
        class Like2 implements ILike{
            @Override
            public void lambda(){
                System.out.println(&quot;I Like Lambda3&quot;);
            }
        }
        like = new Like3();
        like.lambda();

        //5.匿名内部类
        like = new ILike(){
            @Override
            public void lambda(){
                System.out.println(&quot;I Like Lambda4&quot;);
            }
        };
        like.lambda();

        //6.用lambda简化
        like = ()-&gt;System.out.println(&quot;I Like Lambda&quot;);

    };
    like.lambda();
}
//1.定义一个函数式接口
interface ILike{
    void lambda();
}
//2.实现类
class Like implements ILike{
    @Override
    public void lambda(){
        System.out.println(&quot;I Like Lambda&quot;);
    }
}</code></pre>
<pre><code class="java">//lambda表达式简化 
public class TestLambda2{
    public static void main(String[] args){
        //1.lambda表示简化
        ILove love = (int a)-&gt;{
            System.out.println(&quot;i Love you--&gt;&quot;+ a);
        };
        //简化1.参数类型
        love = (a)-&gt;{
            System.out.println(&quot;i love you--&gt;&quot;+a);
        };
        //简化2.去掉括号
        love = a-&gt;{
            System.out.println(&quot;i love you--&gt;&quot;+a);
        };
        //简化3.去掉花括号
        love = a-&gt;System.out.println(&quot;i love you--&gt;&quot;+a);

        love.love(520);
    }
} 

/*总结：lambda表达式只能有一行代码的情况下才能简化成一行，如果有多行，        那么就用代码块包裹
        前提是接口为函数式接口
        多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号
*/    </code></pre>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li><p>创建状态</p>
</li>
<li><p>就绪状态</p>
</li>
<li><p>阻塞状态</p>
</li>
<li><p>运行状态</p>
</li>
<li><p>死亡状态</p>
</li>
</ul>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><ul>
<li>不推荐使用JDK提供的stop（），destroy（）方法。已废弃</li>
<li>推荐线程自己停下来</li>
<li>建议使用一个标志位进行终止变量，当flog=fslse，则终止线程运行</li>
</ul>
<pre><code class="java">public class TestStop implements Runnable{
    //1.线程中定义线程体使用的标识
    private boolean flag = true;

    @Override
    public void run(){
        //2.线程使用该标识
        while (flog){
            System.out.println(&quot;run...Thread&quot;);
        }
    }
    //3.对外提供方法改变标识
    public void stop(){
        this.flog = false;
    }
}</code></pre>
<pre><code class="java">//测试stop
//1.建议线程正常停止--&gt;利用次数，不建议死循环
//2.建议使用标志位--&gt;设置一个标志位
//3.不要使用stop或者destroy等过时或不推荐使用的方法

public class TestStop implements Runnable{
    //1.设置一个标识位
    private boolean flag = true;

    @Override
    public void run(){
        int i = 0;
        while (flag){
            System.out.println(&quot;run...Thread&quot;+i++);
        }
    }

    //2.设置一个公开的方法停止线程，转换标志位
    public void stop(){
        this.flog = false;
    }

    public static void main(String[] args){
        TestStop teststop = new TestStop();
        new Thread(testStop).start();

        for(int i = 0;i &lt; 1000; i++){
            System.out.println(&quot;main&quot;+i);
            if(i==900){
                //调用stop方法切换标志位，让线程停止
                testStop.stop();
                System.out.println(&quot;线程停止了&quot;);
            }
        }
    }
}</code></pre>
<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul>
<li>sleep(时间)指定当前线程阻塞的毫秒数；</li>
<li>sleep存在异常interruptedException;</li>
<li>sleep时间达到后线程进入就绪状态；</li>
<li>sleep可以模拟网络延时，倒计时等、</li>
<li>每一个对象都有一个锁，sleep不会释放锁；</li>
</ul>
<pre><code class="java">//模拟倒计时
public class TestSleep2 {
    public static void main(String[] args){
        //打印当前系统时间
        Date startTime = new Date(System.currentTimeMills());//获取系统当前时间
        while(true){
            try{
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(startTime));
                startTime = new Date(System.currentTimeMills());//更新当前时间
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }
    }


}</code></pre>
<h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul>
<li>线程礼让，让当前正在执行的线程暂停，但不阻塞。</li>
<li>将线程从运行状态转为就绪状态</li>
<li>让CPU重新调度，礼让不一定成功，看CPU心情</li>
</ul>
<pre><code class="java">//测试礼让线程，礼让不一定成功，看CPU调度
public class TestYield {
    public static void main(String[] args){
        MyYield myYield = new MyYield();

        new Thread(myYield,&quot;a&quot;).start();
        new Thread(myYield,&quot;b&quot;).start();
    }
}

class MyYield implements Runnable{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);
    Thread.yield();    System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);

    }
}</code></pre>
<h3 id="线程强制执行-Join"><a href="#线程强制执行-Join" class="headerlink" title="线程强制执行    Join"></a>线程强制执行    Join</h3><ul>
<li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。</li>
<li>可以想象成插队。</li>
</ul>
<pre><code class="java">//测试Join方法
public class TestJoin implements Runnable{
    @Override
    public void run(){
        for (int i = 0; i &lt; 1000; i++ ){
            System.out.println(&quot;线程Vip来了&quot;+i);
        }
    }
    public static void main(String[] args){
        //启动线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程

        for(int i = 0; i &lt; 500; i++){
            if(i==200){
                thread.join();//插队
            }
            System.out.println(&quot;main&quot;+i);

        }

    }
}</code></pre>
<h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><ul>
<li><p>Thread.State</p>
<p>线程状态。</p>
<ul>
<li><p>NEW </p>
<p>尚未启动的线程处于此状态</p>
</li>
<li><p>RUNNABLE</p>
<p>在Java虚拟机中执行的线程处于此状态</p>
</li>
<li><p>BLOCKED</p>
<p>被阻塞等待监视器锁定的线程处于此状态</p>
</li>
<li><p>WAITING</p>
<p>正在等待另一个线程执行特定动作的线程处于此状态</p>
</li>
<li><p>TIMED_WAITING</p>
<p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</p>
</li>
<li><p>TERMINATED</p>
<p>已退出的线程处于此状态</p>
</li>
</ul>
</li>
</ul>
<p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p>
<pre><code class="java">//观察测试线程的状态
public class TestState{
    public static void main(String[] args){
        Thread thread = new Thread(()-&gt;{
            for(int i = 0; i &lt; 5; i++){
                try{
                    Thread.sleep(1000);

                }catch (InterruptedEcxeption e){
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;////////&quot;);
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);//NEW

        //观察启动后
        thread.start();//启动线程
        state = thread.getState();
        System.out.println(state);//Run

        while(state != Thread.State.TERMINATED){
            //只要线程不终止，就一直输出
            Thread.sleep(100);
            state = thread.getState();//更新线程状态
            System.out.println(state);//输出状态
        }
    }
}</code></pre>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</li>
<li>线程的优先级用数字表示，范围1~10.<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;</li>
</ul>
</li>
<li>使用以下方式改变或获取优先级<ul>
<li>getPriority().setPriority(int XXX)</li>
</ul>
</li>
</ul>
<pre><code class="java">//测试线程的优先级
public class TestPriority{
    public static void main(String[] args){
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());

        MyPriority_myPriority = new MyPriority();

        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);

        //先设置优先级，再启动
        t1.start();

        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();

    }
}</code></pre>
<p>优先级低只是意味着获取调度的概率低，并不是优先级低就不会被调用了，都看CPU的调度。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕</li>
<li>如，后台记录操作日志，监控内存，垃圾回收等待</li>
</ul>
<pre><code class="java">//测试守护线程
//上帝守护你
public class TestDaemon{

    public class void main(String[] args){
        God god = new GOd();
        You you = new You();

        Thread thread = new Thread(god);
        thread.setDaemon(true);//默认是false表示用户线程。

        thread.start();//上帝守护线程启动

        new Thread(you).start();//你  用户线程启动
    }
}

//上帝
class God implements Runnable{
    @Override
    public void run(){
        while(true){
            System.out.println(&quot;上帝保有着你&quot;);
        }
    }
}


//你
class You implements Runnable{
    @Override
    public void run(){
        for (int i = 0; i &lt; 36500; i++){
            System.out.println(&quot;你一生都开心的活着&quot;);
        }
        System.out.prntln(&quot;====goodbay! world====&quot;);
    }
}</code></pre>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>多个线程作用统一资源</p>
<p><strong>并发：</strong>同一个对象被多个线程同时操作</p>
<p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。</p>
<p><strong>线程同步</strong>其实就是一种等待机制，多个需要同时访问此对象的线程进入这个<strong>对象的等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用。</p>
<h3 id="队列和锁"><a href="#队列和锁" class="headerlink" title="队列和锁"></a>队列和锁</h3><p>线程同步需要队列和锁</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制  synchronized</strong>,当一个线程获得对象的排它锁，独占资源，其他线程必须得等待，使用后释放锁即可。存在以下几个问题<ul>
<li>一个线程持有锁会导致其他需要此锁的线程挂起。</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。</li>
</ul>
</li>
</ul>
<h3 id="三大不安全案例"><a href="#三大不安全案例" class="headerlink" title="三大不安全案例"></a>三大不安全案例</h3><pre><code class="java">//不安全的买票案例
//线程不安全，有负数
public class UnsafeBuyTicket{
    public static void main(String[] args){
        BuyTicket station = new BuyTicket();

        new Thread(station,&quot;苦逼的我&quot;).start();
        new Tgread(station,&quot;牛逼的你们&quot;).start();
        new Thread（station,&quot;可恶的黄牛党&quot;).start();
    }

}

class BuyTicket implements Runnable{
    //票
    private int ticketNums = 10;
    boolean flag = true;//外部停止方式
    @Override
    public void run(){
        //买票
        while(flag){
            try{ 
                buy();
            }catch(InterruptedException e){
                e.printStackTrace();
            }

        }
    }

    private void buy(){
        //判断是否有票
        if(ticketNums&lt;=0){
            flag = false;
            return;
        }
        //模拟延时
        Thread.sleep(100); 

        //买票
        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNums--);
    }
}</code></pre>
<pre><code class="java">//不安全的取钱
//两个人去银行取钱，账户
public class UnsafeBank{
    public static void mian(String[] args){
        //账户
        Account account = new Account(100,&quot;结婚基金&quot;);

        Drawing you = new Drawing(account, 50, &quot;你&quot;);
        Drawing girl = new Drawing(account, 50, &quot;girl&quot;);

        you.start();
        girl.start();
    }

}
//账户
class Account{
    int money;//余额
    String name;//卡名

    public Account (int money,String name){
        this.money = money;
        this.name = name;
    }
}
//银行：模拟取款
class Drawing extends Thread{
    Account account;//账户
    int drawingMoney;
    int nowMoney;

    public Drawing(Account account,int drawingMoney,Stirng name){
        super(name);
        this.account = account;
        this.drawingMoney = drawingMonry;

    }
    //取钱
    @Override
    public void run(){
        //判断有没有钱
        if(account.money-drawingMoney&lt;0){
            System.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);
            return;
        }
        //卡内余额 = 余额 - 你取的钱
        account.money = account.money - drawingMoney;
        //你手里的钱
        nowMoney = nowMoney + drawingMoney;

        System.out.println(account.name+&quot;余额为:&quot;+account.money);
        //Thread.currentThread().getName() = this.getName()
        System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMony);
    }

}</code></pre>
<pre><code class="java">//线程不安全的集合
public class UnsafeList{
    public static void main(String[] args){
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for(int i = 0; i &lt; 10000; i++){
            new Thread(()--&gt;{
                list.add(Thread.cirrentThread().getName());
            }).start();
        }
        try{
            Thread.sleep(3000);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}</code></pre>
<h2 id="同步方法及同步块"><a href="#同步方法及同步块" class="headerlink" title="同步方法及同步块"></a>同步方法及同步块</h2><ul>
<li><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们需要针对方法提出一套机制，这个机制就是synchronized关键字，他包括两种用法：synchronized方法和synchronized块</p>
<p><strong>同步方法：public synchronized void method (int args){}</strong></p>
</li>
<li><p>synchronized方法控制对”对象“的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。</p>
<p><strong>缺陷：若将一个大的方法声明为synchronized将会影响效率。</strong></p>
</li>
</ul>
<h3 id="同步方法弊端"><a href="#同步方法弊端" class="headerlink" title="同步方法弊端"></a>同步方法弊端</h3><p>方法里面需要修改的内容才需要锁，锁的太多，浪费资源。</p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><ul>
<li>同步块:synchronized(Obj){}</li>
<li>Obj称之为同步监视器<ul>
<li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法中的同步监视器就是this，就是这个对象本身，或者class[反射中讲解]</li>
</ul>
</li>
<li>同步监视器的执行过程<ul>
<li>第一个线程访问，锁定同步监视器，执行其中的代码。</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问。</li>
<li>第一个线程访问完毕，解锁同步监视器。</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ul>
</li>
</ul>
<p>锁的对象是变化的量，需要增删改的对象</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><pre><code class="java">//测试JUC安全类型的集合
public class TestJUC {
    public static void mian(String[] args){
        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();
        for(int i = 0; i&lt; 1000; i++){
            new Thread(()-&gt;{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try{
            Thread.sleep(3000);
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}</code></pre>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才可以运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情景。某一个同步块同时拥有两个”两个以上对象的锁”时，就有可能会发生“死锁”的问题。</p>
<pre><code class="java">//死锁：多个线程互相抱着对方需要的资源，然后形成僵持
public class DeadLock{
    public static void main(String[] args){
       Makeup g1 = new Makeup(0,&quot;灰姑凉&quot;);
       Makeup g2 = new Makeup(1,&quot;白雪公主&quot;);

        g1.start();
        g2.start();

    }
}
//口红
class Lipstick{

}
//镜子
class Mirror{

}

class Makeup extends Thread{

    //需要的资源只有一份，用static来保证只有一份
    static Lipstick liostick = new Lipstick();
    static Mirror mirror = new Mirror();

    int choice;//选择
    String girlName;//使用化妆品的人

    Makeup (int choice, String girlName){
        this.choice = choice;
        this.girlName = girlName;
    }


    @Override
    public void run(){
        //化妆
        try{
            makeup();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
    //化妆,互相持有对方的锁，就是需要拿到对方的资源
    private void makeup() throws InterruptedException{
        if(choice == 0){
            synchronized (lipstick){//获得口红的锁
                System.out.println(this.girlName+&quot;获得口红的锁&quot;);
                Thread.sleep(1000);
                synchronized(mirror){//一秒后想获得镜子
                    System.out.println(this.girlName+&quot;获得镜子的锁&quot;);

                }
            }
        }else{
            synchronized (mirror){
                //获得镜子的锁
                System.out.println(this.girlName+&quot;获得镜子的锁&quot;);
                Thread.sleep(2000);
                synchronized(lipstick){
                    //一秒钟后想获得口红
                    system.out.println(this.girlName+&quot;获得口红的锁&quot;);
                }
            }
        }

    }

}

</code></pre>
<p><strong>产生死锁的四个必要条件</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h3 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h3><p>ReentrantLock可重入锁</p>
<ul>
<li><p>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p>
</li>
<li><p>Java.util.concurrent.locks.Lock接口使控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
</li>
<li><p>ReettantLock类实现了Lock，他拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁，释放锁。</p>
</li>
</ul>
<pre><code class="java">public class TestLock {
    public static void main(Strinh[] args){
        TestLock2 testLock2 = new TestLock2();

        new Thread (testLock2).start();
        new Thread (testLock2).start();
        new Thread (testLock2).start();
    }
}

class TestLock2 implements Runnable{
    int ticketNums = 10;

    //定义Lock锁
    private final ReentranLock lock = new ReentrantLock();

    @Override
    public void run(){
        while(true){
            try{
                lock.lock();//加锁
                if(ticketNums&gt;0){
                    try{
                        Thraed.sleep(1000);
                    }catch(InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                }else{
                    break;
                }
            }finally{
                //解锁
                lock.unlock();
            }
        }
    }
}</code></pre>
<pre><code class="java">//Lock锁   模板

class A{
    private final ReentrantLock lock = new ReenTrantLock();
    public void m(){
        lock.lock();
        try{
            //保证线程安全的代码;
        }
        final{
            lock.unlock();
            //如果同步代码有异常，要将unlock()写入finally语句块
        }
    }
}</code></pre>
<h3 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h3><ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序：<ul>
<li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="问题：生产者消费者模式"><a href="#问题：生产者消费者模式" class="headerlink" title="问题：生产者消费者模式"></a>问题：生产者消费者模式</h3><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li>应用场景：生产者和消费者问题<ul>
<li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</li>
<li>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</li>
<li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li>
</ul>
</li>
</ul>
<p><strong>分析：</strong>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。</p>
<ul>
<li>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，有需要马上通知消费者消费。</li>
<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li>
<li>生产者消费者问题中，仅有synchronized是不够的。<ul>
<li>synchronized可阻止并发更新同一个资源共享，实现了同步。</li>
<li>synchronized不能用来实现不同线程之间的消息传递（通信）</li>
</ul>
</li>
</ul>
<p><strong>解决方法1</strong></p>
<p>并发协作模型”生产者/消费者模式”—-&gt;管程法</p>
<ul>
<li>生产者：负责生产数据的模块（可能是方法，对象，线程，进程）</li>
<li>消费者：负责生产数据的模块（可能是方法，对象，线程，进程）</li>
<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个”缓冲区“</li>
</ul>
<p><strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。</strong></p>
<p><strong>解决方式2</strong></p>
<p>并发协作模型”生产者/消费者模式”—-&gt;信号灯法</p>
<pre><code class="java">//测试：生产者和消费者模型---&gt;利用缓冲区解决:管程法
//生产者，消费者，产品，缓冲区
public class TestPC{
  public static void main(String[] args){
      SynContainer container = new SynContainer();

      new Productor(container).start();
      new Consumer(container).start();
  }

}

//生产者
class Productor extends Thread{
    SynContainer container;

    public Productor(SynContainer container){
        this.container = container;
    }

    //生产
    @Override
    public void run(){
        super.run(){
            for(int i = 0; i &lt; 100; i++){
                container.push(new Chicken(i));
                System.out.println(&quot;生产了&quot;+i+&quot;只鸡&quot;);
            }
        }
    }
}

//消费者
class Consumer extends Thread{
    SynContainer container;

    public Productor(SynContainer container){
        this.container = container;
    }

    //消费
    @Override
    public void run(){
        for(int i = 0; i &lt;100; i++){
            System.out.println(&quot;消费了&quot;+container.pop().id+&quot;只鸡&quot;);
        }
    }
}

//产品
class Chicken{
    int id;//产品编号

    public Chicken(int id){
        this.id = id;
    }
}

//缓冲区
class SynContainer{
    //需要一个容器大小
    Chicken[] chicken = new Chicken[10];
    //容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Chicken chicken){
        //如果容器满了，就需要等待消费者消费
        if(count == chickens.length){
            //通知消费者消费，生产等待
        }

        //如果没有满，我们就需要丢入产品 
        chicken[count] = chicken;
        count++;

        //可以通知消费者消费了。
        this.notifyAll();
    }


    //消费者消费产品
    public synchronized Chicken pop(){
        //判断能否消费
        if(count == 0){
            //生产者生产，消费者等待
            try{
                this.wait();
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }

        //如果可以消费
        count--;
        Chicken chicken = chickens[count];

        //吃完了，通知生产者生产
        return chicken;

    }

}</code></pre>
<pre><code class="java">//测试生产者消费者问题2:信号灯法，标志位解决

public class TestPc2{
    public static void main(String[] args){
        TV tv = new TV;
        new Player(tv).start();
        new Watch(tv).start();
    }



}
//生产者--&gt;演员
class Player extends Thread{
    TV tv;
    public Player(TV tv){
        this.tv = tv;
    }

    @Override
    public void run(){
        for(int i = 0; i &lt; 20; i++){
            if(i%2==0){
                this.tv.play(&quot;快乐大本营&quot;);
            }elae{
                this.tv.play(&quot;抖音:记录美好生活&quot;);
            }
        }
    }
}

//消费者--&gt;观众
class Watcher extends Thread{
     TV tv;
    public Watcher(TV tv){
        this.tv = tv;
    }
    @Override
    public void run(){
        for(int i = 0; i &lt; 20; i++ ){
            tv.watch();
        }
    }


}

//产品--&gt;节目
class TV{
    //演员表演，观众等待
    //观众观看，演员等待
    String voice;//表演的节目
    boolean flag = true;

    //表演
    public synchronized void play(String[] voice){
        if(!flag){
            try{
                this.wait();
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }

        System.out.println(&quot;演员表演了:&quot;+voice);
        //通知观众观看
        this.notifyAll();//通知唤醒
        this.voice = voice;
        this.flag = !this.flag;
    }

    //观看
    public synchronized void watch(){
        if(flag){
            try{
                this.wait();
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        System.out.println(&quot;观看了:&quot;+ voice);
        //通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }

}</code></pre>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用后放回池中。可以避免频繁的创建销毁，实现重复利用。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：线程池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间会终止。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h3><ul>
<li>JDK5.0起提供了线程池相关的API：ExecutorService 和 Executors</li>
<li>ExecutorService ：真正的线程池接口。常见的子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T>Future<T>submit(Callable<T> task)：执行任务，有返回值，一般又来执行Callable</T></T></T></li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类，线程池的工厂类，用于创建返回不同类型的线程池。</li>
</ul>
<pre><code class="java">//测试线程池
public class TestPool{
    public static void main(String[] args){
        //1.创建服务，创建线程池
        //newFixedThreadPool  参数为：线程池大小
        ExecutorService service = Executors.newFixedThreadPool(10);

        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());

        //2.关闭连接
        service.shutdown();
    }
}

class MyThread implements Runnable{
    @Override
    public void run(){
            System.out.println(Thread.currentThread().getName());

    }
}</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="java">//回顾总结线程的创建
public class ThreadNew{
    public static void main(String[] args){
        new MyThread1().start();

        new Thread(new MyThread2()).start();

        FutureTask futureTask = new FutureTask(new MyThread3());
        new Thread().start();
    }
}
//1.继承Thread类
class MyThread1 extends Thread{
    @Override
    public void run(){
        System.out.println(&quot;MyThread&quot;);
    }
}

//2.实现Runnable接口
class MyThread2 implements Runnable{
    @Override
    public void run(){
        System.out.println(&quot;MyThread2&quot;);
    }
}


//3.实现Callable接口
class MyThread3 implements Callable&lt;Intrger&gt;{
    @Override
    public Integer call() throws Exception{
        System.out.println(&quot;MyThread3&quot;);
        return 100;
    }
}
</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/05/JSON/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON<a id="more"></a></h1><p><strong>要求及语法格式</strong></p>
<ul>
<li>对象表示为键值对</li>
</ul>
<pre><code class="javascript"> &lt;!-- 键名写在前面并用双引号&quot;&quot;包裹，使用:分割，然后紧接着值--&gt;
{&quot;name&quot;:&quot;qinjiang&quot;}
{&quot;age&quot;:&quot;3&quot;}
{&quot;sex&quot;:&quot;男&quot;}</code></pre>
<ul>
<li>数据由逗号分割</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON和JS对象的关系</strong>:</p>
<p>JSON是JS对象的字符串表示法，他使用文本表示一个JS对象的信息，本质是一个字符串。</p>
<pre><code class="javascript">var obj = {a:&#39;hello&#39;,b:&#39;World&#39;};//这是一个对象，注意键名也是可以使用引号包裹。
var json = &#39;{&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;}&#39;;//这是一个JSON字符串，本质是一个字符串</code></pre>
<p><strong>JSON和JS对象互转</strong></p>
<p>JSON字符串转换为JS对象，使用JSON.parse()方法：</p>
<pre><code class="javascript">var obj = JSON.parse(&#39;{&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;}&#39;);
//结果是{a:&#39;Hello&#39;,b:&#39;World&#39;}</code></pre>
<p>JS对象转换为JSON字符串，使用JSON.stringify()方法：</p>
<pre><code class="javascript">var json = JSON.stringify({a:&#39;Hello&#39;,b:&#39;World&#39;});
//结果是&#39;{&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;}&#39;</code></pre>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/Mr-lee-MQ.hithub.io/2020/07/24/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript<a id="more"></a></h1><p>JavaScript是一门世界上最流行的脚本语言。</p>
<p>严格区分大小写。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="引入JavaScript"><a href="#引入JavaScript" class="headerlink" title="引入JavaScript"></a>引入JavaScript</h3><ul>
<li>内部标签使用</li>
</ul>
<pre><code class="javascript"> &lt;script&gt;
        alert(&quot;Hello,JavaScript&quot;)
    &lt;/script&gt;</code></pre>
<ul>
<li>外部引入</li>
</ul>
<pre><code class="javascript">alert(&quot;Hello,JavaScript&quot;)


&lt;body&gt;
&lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="基本语法入门"><a href="#基本语法入门" class="headerlink" title="基本语法入门"></a>基本语法入门</h3><ul>
<li>定义变量</li>
</ul>
<pre><code class="javascript">变量类型    变量名 = 变量值；
var num = 1；
var name = &quot;liminqiang&quot;</code></pre>
<ul>
<li>条件控制</li>
</ul>
<pre><code class="javascript">if(2&gt;1){
alert(&quot;true&quot;);
}</code></pre>
<ul>
<li>注释</li>
</ul>
<pre><code class="javascript">/*     */</code></pre>
<ul>
<li>打印变量</li>
</ul>
<pre><code>console.log(score)        /*在浏览器的控制台打印变量相当于sout*/</code></pre><ul>
<li>控制台调试JavaScript<ul>
<li>Elements   :HTML和CSS代码</li>
<li>Console   :控制台（可写JavaScript代码）</li>
<li>Sources   :当前的源码目录<ul>
<li>打断点<ul>
<li>在Sources的源码中点击左侧行数即打断点，然后刷新页面</li>
<li>右上角上下箭头选择</li>
</ul>
</li>
</ul>
</li>
<li>Neteork :网络请求 </li>
<li>Application：相当于web里的数据库</li>
</ul>
</li>
</ul>
<h3 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h3><p>数值，文本，图形，音频，视频……</p>
<ul>
<li>number</li>
</ul>
<p>js不区分小数跟整数</p>
<pre><code class="javascript">123//整数123
123.3// 浮点数123.3
1.12e3//科学计数法
-99 //复数
NaN  //not a number
Infinity  //表示无限大</code></pre>
<ul>
<li>字符串</li>
</ul>
<pre><code class="javascript">&#39;abc&#39;
&quot;abc&quot;</code></pre>
<ul>
<li>布尔值</li>
</ul>
<pre><code class="javascript">true 
false</code></pre>
<ul>
<li>逻辑运算</li>
</ul>
<pre><code class="javascript">&amp;&amp; 两个都为真，结果为真
||一个为真，结果为真
!真既假，假即真</code></pre>
<ul>
<li>比较运算符</li>
</ul>
<pre><code class="javas">=   赋值
==   等于（类型不一样，值一样，也会判断为true）
====   绝对等于（类型一样，值一样，则为true）</code></pre>
<p>特殊：NaN===NaN，NaN与所有值都不相等，包括自己。</p>
<p>​            只能通过isNaN(NaN)来判断这个数是否是NaN</p>
<p>浮点数问题：</p>
<pre><code class="javascript">console.log((1/3)===(1-2/3))</code></pre>
<p>尽量避免使用浮点数进行运算，存在精度问题。</p>
<p>可用Math.abs解决</p>
<pre><code class="javascript">console.log(Math.abs(1/3-(1-2/3))&lt;0.00000001;</code></pre>
<ul>
<li><p>null和undefined</p>
<ul>
<li>null空</li>
<li>undefined未定义</li>
</ul>
</li>
<li><p>数组</p>
</li>
</ul>
<p>Java中必须是一系列类型相同的对象,JS中不需要</p>
<pre><code class="javascript">var arr = [1,2,3,4,&quot;hello&quot;,null,true]</code></pre>
<p>为保证代码的可读性数组尽量用[   ],对象则用{   }</p>
<p>取数组下标，如果越界，则为undefined。</p>
<ul>
<li>对象</li>
</ul>
<p>对象是大括号，数组是中括号。每个属性用逗号隔开，最后一个不用加。</p>
<pre><code class="javascript">varperson={

    name:&quot;limin&quot;,
    age:14,    
}</code></pre>
<p>取对象的值</p>
<pre><code class="javascript">调用：person.name
        limin</code></pre>
<p>严格检查模式   use strict</p>
<ul>
<li><p>放第一行。</p>
</li>
<li><p>预防JavaScript的随意性导致产生一些问题。</p>
</li>
<li><p>局部变量都用let去定义。</p>
</li>
</ul>
<pre><code class="javascript">let i = 1 ;</code></pre>
<h2 id="数据类型详解"><a href="#数据类型详解" class="headerlink" title="数据类型详解"></a>数据类型详解</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>正常的字符串我们用单引号，或双引号包裹</li>
<li>注意转义字符 \</li>
</ul>
<pre><code>\&#39;
\n
\t
\u4e2d
\u####
unicode字符
\x41   Ascll字符</code></pre><ul>
<li>多行字符串编写</li>
</ul>
<pre><code class="javascript">//tab上面的  esc键下面
var msg=
    `hello
world
你好呀
你好</code></pre>
<ul>
<li>模板字符串</li>
</ul>
<pre><code class="javascript">//tab上面 esc下面
let name = &quot;qinjiang&quot;;
let age = 3;

let msg = `你好呀，${name}`</code></pre>
<ul>
<li>字符串长度</li>
</ul>
<pre><code class="javascript">console.log(str.length)</code></pre>
<ul>
<li>字符串的可变性，不可变</li>
</ul>
<pre><code class="java">console.log(student[0])
    s
student[0]= 1
    1
console.leg(student)
    student</code></pre>
<ul>
<li>大小写转换</li>
</ul>
<pre><code>//注意，这里是方法，不是属性
student.toUpperCase()
student.toLowerCase()</code></pre><ul>
<li>student.indexOf(‘t’)    获取指令的下标</li>
<li>substring</li>
</ul>
<pre><code class="javascript">//包含前面，不包含后面
student.substring(1)  //从第一个字符串截取到最后一个字符串
student.substring(1,3)   //[1)</code></pre>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Array可以包含任意的数据类型</p>
<pre><code class="javascript">var arr= [1,2,3,4,5]</code></pre>
<ul>
<li>长度</li>
</ul>
<pre><code class="java">arr.length</code></pre>
<p>注意：假如给arr.length赋值，则数组大小就会发生变化。如果赋值过小，元素会丢失。</p>
<ul>
<li>indexOf   通过元素获得下标索引。</li>
</ul>
<pre><code class="javascript">arr.indexOf(2)
1</code></pre>
<p>字符串的“1”和数字1是不同的</p>
<ul>
<li>slice（）截取Array的一部分，返回一个新数组，类似于String中的substring</li>
<li>push（） , pop（）</li>
</ul>
<pre><code class="javascript">push:  压入到尾部
pop:  弹出尾部的一个元素

var arr= [1,2,3,4,5]
arr.push(&#39;a&#39;,&#39;b&#39;)
arr;
1,2,3,4,5,&quot;a&quot;,&quot;b&quot;

arr.pop()
arr;
1,2,3,4,5,&quot;a&quot;</code></pre>
<ul>
<li>unshift(),   shift()头部</li>
</ul>
<pre><code class="javascript">unshift:  压入到头部
shift:  弹出头部的一个元素</code></pre>
<ul>
<li>sort  排序        </li>
</ul>
<pre><code class="javascript">(3)[&quot;B&quot;,&quot;C&quot;,&quot;A&quot;]
arr.sort()
(3)[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]</code></pre>
<ul>
<li>reverse()     元素反转</li>
</ul>
<pre><code class="javascript">(3)[&quot;B&quot;,&quot;C&quot;,&quot;A&quot;]
arr.reverse()
(3)[&quot;C&quot;,&quot;B&quot;,&quot;A&quot;]</code></pre>
<ul>
<li>concat()</li>
</ul>
<pre><code class="javascript">(3)[&quot;B&quot;,&quot;C&quot;,&quot;A&quot;]
arr.concat([1,2,3])
(6)[&quot;C&quot;,&quot;B&quot;,&quot;A&quot;,1,2,3]
arr
(3)[&quot;C&quot;,&quot;B&quot;,&quot;A&quot;]</code></pre>
<p>注意：concat（）并没有修改数组，只是会返回了一个新的数组</p>
<ul>
<li>连接符   join</li>
</ul>
<p>打印拼接数组，使用特定的字符串连接</p>
<pre><code class="javascript">(3)[&quot;C&quot;,&quot;B&quot;,&quot;A&quot;]
arr.join(&#39;-&#39;)
&quot;C-B-A&quot;</code></pre>
<ul>
<li>多维数组</li>
</ul>
<pre><code class="javascript">arr = [[1,2][3,4][&quot;5&quot;,&quot;6&quot;]];
arr[1][1]
4</code></pre>
<p>数组：存储数据（如何存，如何取，方法可以自己实现！）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>若干个键值对</p>
<p>JavaScript中的所有的键都是字符串，值是任意对象</p>
<pre><code class="javascript">var 对象名= {
    属性名：属性值，
    属性名：属性值，
    属性名：属性值
}
定义了一个person对象，它有4个属性
var person={
    name:&quot;kuangshen&quot;,
    age:3,
    email:&quot;2285051311@qq.com&quot;,
    score:0  
}</code></pre>
<p>JS中对象，{…..}表示一个对象，键值对描述属性XXX：XXXX，多个属性之间使用逗号隔开，最后一个属性不加逗号！</p>
<ul>
<li>对象赋值</li>
</ul>
<pre><code class="javascript">person.name = &quot;qinjiang&quot;
&quot;qinjiang&quot;
person.name
&quot;qinjiang&quot;</code></pre>
<ul>
<li>使用一个不存在的对象属性，不会报错！undefined</li>
</ul>
<pre><code class="javascript">person.haha
undefined</code></pre>
<ul>
<li>动态的删减属性，通过delete删除对象的属性</li>
</ul>
<pre><code class="javascript">delete person.name
ture</code></pre>
<ul>
<li>动态的添加,直接给新的属性添加值即可</li>
</ul>
<pre><code class="javascript">person.haha = &quot;haha&quot;
&quot;haha&quot;
person</code></pre>
<ul>
<li>判断属性值是否在这个对象中！XXX  in   XXX</li>
</ul>
<pre><code class="javascript">&#39;age&#39; in person
true
//继承
&#39;toString&#39;  in  person
true</code></pre>
<ul>
<li>判断一个属性是否是这个对象拥有的。</li>
</ul>
<pre><code class="javascript">person.hasOwnProperty(&#39;toString&#39;)
false
person.hasOwnProperty(&#39;age&#39;)
true</code></pre>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li>if判断</li>
</ul>
<pre><code class="javascript">var age = 3;
if(age&gt;3){
    alert(&quot;haha&quot;);
    }else{
        alert(&quot;kuwa~&quot;);
    }</code></pre>
<ul>
<li>while循环，避免程序死循环</li>
</ul>
<pre><code class="javascript">while(age&lt;100){
    age = age +1;
console.log(age)
}

//do  while 循环
do{
    age = age + 1;
    console.log(age)
}while(age&lt;100)</code></pre>
<ul>
<li>for循环</li>
</ul>
<pre><code class="javascript">var age = 3;
for(let i = 0;i&lt;100;i++){
    console.log(i)
}</code></pre>
<ul>
<li>forEach循环</li>
</ul>
<pre><code class="javascript">var age = [12,3,12,3,12,31,23,123];
//函数
age.forEach(function (value)){
            console.log(value)
            })</code></pre>
<ul>
<li>for…..in</li>
</ul>
<pre><code class="javascript">//for(var index in object){}
for(var num in age){
if(age.hasownProperty(num)){
    console.log(&quot;存在&quot;)
    console.log(age[num])
    }
}</code></pre>
<h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p>ES6的新特性</p>
<ul>
<li>Map</li>
</ul>
<pre><code class="javascript">//Map
//学生的成绩，学生的名字
//var names = [&quot;tom&quot;,&quot;jack&quot;,&quot;haha&quot;];
//var scores = [100,90,80];
var map = new Map([[&#39;tom&#39;,100],[&#39;jack&#39;,90][&#39;haha&#39;,80]]);
var name = map.get(&#39;tom&#39;);
map.get(&#39;admin&#39;,123456);
map.delete(&quot;tom&quot;);   //删除</code></pre>
<ul>
<li>Set：无序不重复的集合</li>
</ul>
<pre><code class="javascript">//Set可以去重 
var set = new Set([3,1,1,1,]);
set.add(2);   //添加
set.delete(1);  //删除
console.log(set.has(3))   //是否包含某个元素</code></pre>
<h3 id="inerator"><a href="#inerator" class="headerlink" title="inerator"></a>inerator</h3><p>遍历数组</p>
<pre><code class="javascript">//通过for of /for  in   下标
var arr = [3,4,5]
for(var x of arr){
    console.log(x)
}</code></pre>
<p>遍历Map</p>
<pre><code class="javascript">var map = new Map([[&quot;tom&quot;,100],[&quot;jack&quot;,90],[&quot;haha&quot;,80]]);
for (let x of map){
    console.log(x)
}</code></pre>
<p>遍历set</p>
<pre><code class="javascript">var set = new Set([5,6,7]);
for (let x of set){
    console.log(x)
}</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>绝对值函数</p>
<blockquote>
<p>定义方式一</p>
</blockquote>
<pre><code class="javascript">funstion abs(x){
    if(x&gt;=0){
        return x;
    }else{
        return -x;
    }
}</code></pre>
<p>一旦执行到return代表函数结束，返回结果。如果没有执行return，函数执行完也会返回结果，结果是undefined</p>
<blockquote>
<p>定义方式二</p>
</blockquote>
<pre><code class="javascript">var abs = function(x){
   if(x&gt;=0){
        return x;
    }else{
        return -x;
    } 
}</code></pre>
<p>function(x){……}这是一个匿名函数。但是可以把结果赋值给abs，通过abs就可以调用函数。</p>
<ul>
<li>调用函数</li>
</ul>
<pre><code class="javascript">abs(10)
abs(-10)</code></pre>
<p>参数问题JS可以传任意个参数，也可以不传参数。</p>
<ul>
<li>假设不存在参数，如何规避？</li>
</ul>
<pre><code class="javascript">var abs = funstion(x){
    //手动抛出异常判断
    if(typeof x !==&#39;number&#39;){
        throw &#39;Not a number&#39;;
    }
    if(x&gt;=0){
        return x;
    }else{
        return -x;
        }
}</code></pre>
<ul>
<li>argument</li>
</ul>
<p>argument是Js的关键字，代表传递进来的所有参数，是一个数组。</p>
<pre><code class="javascript">var abs = funstion(x){
    console.log(&quot;X=&gt;&quot;+x);
    for (var i =0;i&lt;argument.length;i++){
        console.log(argument[i]);
    }
    if(x&gt;=0){
        return x;
    }else{
        return -x;
    }
}</code></pre>
<p>问题：argument包含所有的参数，我们有时候想使用多余的参数来进行附加操作。需要排除已有的参数。</p>
<ul>
<li>rest</li>
</ul>
<pre><code class="javascript">if(argument.length&gt;2){
    for(var i = 2;i&lt;armument.length;i++){

    }
}</code></pre>
<p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数</p>
<pre><code class="javascript">funstion aaa(a,b,.....rest){
    console.log(&quot;a=&gt;&quot;+a);
    console.log(&quot;b=&gt;&quot;+b);
    console.log(rest);
}</code></pre>
<p>rest 参数只能写在最后面，必须用…..标识。</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在Java Script中，var定义变量实际是有作用域的。</p>
<p>假设在函数体中声明，则在函数体外不可以使用（闭包）</p>
<pre><code class="javascript">function qj(){
    var x = 1;
    x = x + 1;
}
x = x + 2;</code></pre>
<p>如果两个函数使用了相同的变量名，只要在函数内部，就不冲突。</p>
<pre><code class="javascript">function qj(){
    var x = 1;
    x = x + 1;
}

function qj2(){
    var x = &#39;A&#39;;
    x = x + 1; 
}</code></pre>
<blockquote>
<p>内部函数可以访问外部函数的成员，反之则不行。</p>
</blockquote>
<pre><code class="javascript">funstion qj(){
    var x = 1;
    function qj2(){
        var y = x + 1;
    }
    var z = y + 1;

}</code></pre>
<blockquote>
<p>假设，内部函数变量和外部函数变量重名</p>
</blockquote>
<pre><code class="javascript">function qj(){
    var x = 1;
    function qj2(){
        console.log(&#39;inner&#39;+ x );
    }
    console.log(&#39;outter&#39; + X );
    qj2()
}
qj()</code></pre>
<p>假设JavaScript中函数查找变量从自身函数开始，由内向外查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。</p>
<blockquote>
<p>提升变量的作用域</p>
</blockquote>
<pre><code class="javascript">function qj (){
    var x = &quot;x&quot; + y;
    console.log(x);
    var y = &#39;y&#39;;
}

//结果：xundefined
说明JS执行引擎，自动提升了y的声明，但不会提升变量y的赋值</code></pre>
<pre><code class="javascript">function qj2(){
    var y;
    var x = &quot;x&quot; + y;
    console.log(x);
    y = &#39;y&#39;;
}
//即所有的变量定义都放在函数的头部</code></pre>
<blockquote>
<p>全局函数</p>
</blockquote>
<pre><code class="javascript">//全局变量
var x = 1;
function f(){
    console.log(x);
}
f();
console.log(x);</code></pre>
<p>全局对象    window</p>
<pre><code class="javascript">var x = &#39;xxx&#39;;
alret(x);
zlert(window.x);</code></pre>
<p>alert()本身也是window的一个变量</p>
<pre><code class="javascript">vsar x = &#39;xxx&#39;;
window.alert(x);
var old_alert = window.alert;
//old_alert
window.alert = function(){

}
//发现alert()失效了。
window.alert(123);

//恢复
window.alert = old_alert;
window.alert(456);</code></pre>
<p>JavaScript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数的作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错（ReferenceError）引用异常.</p>
<blockquote>
<p>规范</p>
</blockquote>
<p>由于我们所有的全局变量都会绑在我们的window上，如果不停的JS文件，使用了相同的全局变量，冲突—&gt;如何减少冲突。</p>
<pre><code class="javascript">//唯一全局变量
var KuangApp = {};

//定义全局变量
KuangApp.name = &#39;kuangshen&#39;;
KuangApp.add = function( a , b ){
    return a + b;
}</code></pre>
<p>把自己的代码全部放到自己定义的唯一空间名字中，降低全局冲突的问题</p>
<ul>
<li>局部定义域  let</li>
</ul>
<pre><code class="javascript">function aaa(){
    for (var i = 0; i&lt;100;i++){
        console.log(i) 
    }
   console.log(i + 1)
}                //i出了作用域还可以使用</code></pre>
<p>ES6 let关键字，解决局部作用域冲突问题。</p>
<pre><code class="javascript">function aaa(){
    for (let i = 0; i&lt;100;i++){
        console.log(i) 
    }
   console.log(i + 1)
}   </code></pre>
<ul>
<li>常量 const</li>
</ul>
<p>在ES6之前，怎么定义常量：只有用全部大写字母命名的变量就是常量。</p>
<pre><code class="javascript">var PI = &#39;3.14&#39;;

console.log(PI);
PI = &#39;213&#39;;
console.log(PI);</code></pre>
<p>在ES6引用关键字   const   </p>
<pre><code class="javascript">const PI = &#39;3.14&#39;;

console.log(PI);
PI = &#39;213&#39;;</code></pre>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>定义方法：方法就是把函数放在对象里面，对象只有两个东西：属性和方法</li>
</ul>
<pre><code class="javascript">var kuangshen = {
    name:&#39;秦疆&#39;；
    birth: 2000;
    //方法
    age:function(){
        //今年-出生的年
        var now = new Date().getFullYear();
        return now - this.birth;
        }
    }


    //属性
    kuangshen.name
    //方法，一定带括号()
    kuangshen.age()</code></pre>
<p>this代表什么？拆开上面的代码看看</p>
<pre><code class="javascript">function getAge(){
    //今年-出生的年
    var now = new Date().getFullYear();
    return now - this.birth;
}
    var kuangshen = {
        name:&#39;秦疆&#39;，
        birth:2000,
        age:getAge
    }
    //调用kuangshen.age()   ok
    //getAge() NaN  </code></pre>
<p>this 是无法指向的，是默认指向调用它的那个对象；</p>
<ul>
<li>apply</li>
</ul>
<p>在JS中可以控制this的指向</p>
<pre><code class="javascript">function getAge(){
    //今年-出生的年
    var now = new Date().getFullYear();
    return now - this.birth;
}
    var kuangshen = {
        name:&#39;秦疆&#39;，
        birth:2000,
        age:getAge
    }

    getAge.apply(kuangshen,[]);
//this.指向了kuangshen. 参数为空</code></pre>
<h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><ul>
<li>标准对象</li>
</ul>
<pre><code class="javascript">typeof 123
&quot;number&quot;
typeof &#39;123&#39;
&quot;string&quot;
typeof true
&quot;boolean&quot;
typeof NaN
&quot;number&quot;
typeof []
&quot;object&quot;
typeof {}
&quot;object&quot;
typeof Math.abs
&quot;function&quot;</code></pre>
<ul>
<li>Date</li>
</ul>
<pre><code class="javascript">var now = new Date();
now.getFullYear();//年
now.getMonth();//月
now.getDate();//日
now.getDay();//星期几
now.getHours();//时
now.getMinutes();//分
now.getSeconds();//秒

now.getTime();//时间戳</code></pre>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>定义：<ul>
<li><a href="https://baike.baidu.com/item/JSON" target="_blank" rel="noopener">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</li>
<li>简洁和清晰的<strong>层次结构</strong>使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
</li>
</ul>
<p>在JavaScript一切皆为对象，任何JS支持的类型都可以用JSON来表示。</p>
<p>格式：</p>
<ul>
<li>对象都用{}</li>
<li>数组都用[]</li>
<li>所有的键值对都用keyy:value</li>
</ul>
<p>JSON字符串和JS对象的转化</p>
<pre><code class="javascript">var user = {
    name:&quot;qinjiang&quot;,
    age:3,
    sex:&#39;男&#39;

    //对象转化为json字符串{&quot;name&quot;:&quot;qinjiang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;}
    var jsonUser = JSON.stringify(user);
    //json字符串转化为对象，参数为json字符串
    var obj =                                                       JSON.parse(&#39;{&quot;name&quot;:&quot;qinjiang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;}&#39;);  
</code></pre>
<h3 id="Ajax简述"><a href="#Ajax简述" class="headerlink" title="Ajax简述"></a>Ajax简述</h3><ul>
<li>原生的js写法   xhr异步请求</li>
<li>jQury封装好的方法    $(“#name”)ajax(“”)</li>
<li>axios请求</li>
</ul>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ul>
<li><p>类：一个模板     (原型对象)</p>
</li>
<li><p>对象：具体的实例</p>
</li>
</ul>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><pre><code class="javascript">&lt;script&gt;
    var Student = {
        name:&quot;qinjiang&quot;,
        age: 3,
        run: function(){
           console.log(this.name + &quot;run....&quot;);
        }
    };
    var xiaoming = {
        name:&quot;xiaoming&quot;
    };
    var Bird = {  
    }
    //小明的原型是Student
    xiaoming._proto_ = Student;
&lt;/script&gt;
</code></pre>
<h3 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h3><pre><code class="javascript">&lt;script&gt;
    function Student(name){
    this.name = name;
}
//给student新增一个方法
Student.prototype.hello = function(){
    slert(&#39;Hello&#39;)
};
//ES6之后
//定义一个学生的类
class Student{
    constructor(name){
        this.name = name;
    }
}    
    hello(){
        alert(&#39;hello&#39;)
    }</code></pre>
<ul>
<li>继承</li>
</ul>
<pre><code class="javascript">&lt;script&gt;

    function Student(name){
    this.name = name;
}
Student.prototype.hello = function(){
    slert(&#39;Hello&#39;)
};
class Student{
    constructor(name){
        this.name = name;
    }
}    
    hello(){
        alert(&#39;hello&#39;)
    }




class Xiaostudent extend student{
    constructor(name,grade){
        super(name);
        this.grade = grade;
    }
    myGrade(){
        alert(&#39;我是一名小学生&#39;)
    }
}
var xiaoming = new student(&quot;xiaoming&quot;);
var xiaohong = new Xiaostudent(&quot;xiaohong&quot;,1);
&lt;/script&gt;</code></pre>
<p>本质：查看对象原型</p>
<h2 id="操作BOM对象"><a href="#操作BOM对象" class="headerlink" title="操作BOM对象"></a>操作BOM对象</h2><p>JavaScript和浏览器的关系？</p>
<p>JavaScript诞生就是为了能够让他在浏览器中运行</p>
<p>BOM：浏览器对象模型</p>
<ul>
<li>IE6~11</li>
<li>Chrome</li>
<li>Safari</li>
<li>FireFox</li>
</ul>
<blockquote>
<p>window</p>
</blockquote>
<p>window 代表 浏览器窗口</p>
<pre><code class="javascript">window.alert(1)
undefined
window.innerHeight    //内部高度
258
window.innerWidth    //内部宽度
919
window.outerHeight    //外部高度
325
window.outerrWidth    //外部宽度
919</code></pre>
<blockquote>
<p>Navigator</p>
</blockquote>
<p>Navigator,封装了浏览器的信息</p>
<pre><code class="javascript">navigator.appName    //浏览器名称
navigator.appVersion    //版本号
navigator.userAgent    //用户信息
navigator.platform    //系统版本</code></pre>
<p>大多数时候不使用navigator对象，因为可能会被人为修改。不建议使用这些属性来判断和编写代码。</p>
<blockquote>
<p>screen</p>
</blockquote>
<p>屏幕尺寸</p>
<pre><code class="javascript">screen.width
1920
screen.height
1080</code></pre>
<blockquote>
<p>location</p>
</blockquote>
<p>location代表当前页面的URL信息</p>
<pre><code class="javascript">host:&quot;www.baidu.com&quot;
href:&quot;https://www.baidu.com/&quot;
protocol:&quot;https:&quot;
reload:f reload()//刷新网页
location.assign(&quot;https://blog.kuangstudy.com/&quot;)设置新的地址</code></pre>
<blockquote>
<p>document （文本内容）</p>
</blockquote>
<p>document代表当前的页面，HTML DOM文档树</p>
<pre><code class="javascript">document.title
&quot;百度一下，你就知道&quot;
document.title = &#39;狂神说&#39;
&quot;狂神说&quot;</code></pre>
<p>获取具体的文档数节点</p>
<pre><code>&lt;dl id=&quot;app&quot;&gt;
    &lt;dt&gt;Java&lt;/dt&gt;
    &lt;dt&gt;JavaSE&lt;/dt&gt;
    &lt;dt&gt;JavaEE&lt;/dt&gt;
&lt;/dl&gt;

&lt;script&gt;
    var dl = document.getElementById(&#39;app&#39;);
&lt;/script&gt;</code></pre><p>获取cookie</p>
<pre><code class="javascript">document.cookie</code></pre>
<p>劫持cookie原理</p>
<pre><code class="javascript">&lt;script src = &quot;aa.js&quot;&gt;&lt;/stript&gt;
&lt;!--恶意人员：获取你的cooike上传到他的服务器 --&gt;</code></pre>
<p>服务端可以设置 cooike为httpOnly</p>
<blockquote>
<p>history</p>
</blockquote>
<p>history代表浏览器的历史记录</p>
<pre><code class="javascript">history.back()  //后退
history.forward()  //前进</code></pre>
<h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>DOM：文本对象模型</p>
<p>核心：</p>
<ul>
<li>更新：更新    Dom节点</li>
<li>遍历Dom节点：得到Dom节点</li>
<li>删除：删除一个Dom节点</li>
<li>添加：添加一个新的节点</li>
</ul>
<p>要操作一个Dom节点，就必须要先获得这个Dom节点</p>
<blockquote>
<p>获得Dom节点</p>
</blockquote>
<pre><code class="javascript">&lt;h1&gt;标题一&lt;/h1&gt;
&lt;p id = &quot;p1&quot;&gt;p1&lt;/p&gt;
&lt;p class = &quot;p2&quot;&gt;p2&lt;/p&gt;
//获得dom节点   标签
var h1 = document.getElementsByTagName(&#39;h1&#39;)
var p1 = document.getElementsById(&#39;p1&#39;)
var p2 = document.getElementsByClassName(&#39;h1&#39;)</code></pre>
<p>这是原生代码，之后一般会使用JQuery</p>
<blockquote>
<p>更新节点</p>
</blockquote>
<p>操作文本</p>
<ul>
<li>innerText 修改文本值</li>
</ul>
<pre><code class="javascript">id1.innerText = &#39;456&#39;</code></pre>
<ul>
<li>可以解析HTML文本标签</li>
</ul>
<pre><code class="javascript">id1.innrtHTML = &#39;&lt;strong&gt;123&lt;/strong&gt;&#39;</code></pre>
<p>操作JS</p>
<pre><code class="javascript">id1.style.color = &#39;yellow&#39;;
id1.style.fontSize = &#39;20px&#39;;</code></pre>
<blockquote>
<p>删除节点</p>
</blockquote>
<p>删除节点的步骤：先获取父节点，在通过父节点删除自己</p>
<pre><code class="javascript">&lt;div id =&quot;father&quot;&gt;
    &lt;h1&gt;标题一&lt;/h1&gt;
    &lt;p id = &quot;p1&quot;&gt;p1&lt;/p&gt;
    &lt;p class = &quot;p2&quot;&gt;p2&lt;/p&gt;
&lt;/div&gt;

father.removeChild(p1)

//删除是一个动态的过程
father.removeChild(father.children[0])
father.removeChild(father.children[1])
father.removeChild(father.children[2])
</code></pre>
<p>注意：删除多个节点的时候，children是在时刻变化的，删除节点的时候一定要注意</p>
<blockquote>
<p>插入节点</p>
</blockquote>
<p>我们获得了某个DOM节点，假设这个DOM节点是空的，我们通过innerHTML就可以增加一个元素，但是这个DOM节点已经存在元素了，就不能这么做了，会产生覆盖。</p>
<ul>
<li>追加    appendChild</li>
</ul>
<pre><code class="javascript">&lt;p id = &#39;js&#39;&gt;JavaScript&lt;/p&gt;
&lt;div id = &#39;list&#39;&gt;
    &lt;p id = &quot;se&quot;&gt;JavaSE&lt;/p&gt;
    &lt;p id = &quot;ee&quot;&gt;JavaEE&lt;/p&gt;
    &lt;p id = &quot;me&quot;&gt;JavaME&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
        var js = docoment.getElmentById(&#39;js&#39;);
        var list = docoment.getElmentById(&#39;list&#39;);
        list.appendChild(js);//追加到后面
&lt;/script&gt;
</code></pre>
<ul>
<li>创建一个新的标签,实现插入    document.createElement</li>
</ul>
<pre><code class="javascript">&lt;script&gt;
    var js = document.getElementById(&#39;js&#39;);   //已经存在的节点
    var list = document.getElementById(&#39;list&#39;);
// 通过JS创建一个新的节点
    var newP = document.createElement(&#39;p&#39;);//创建一个P标签
    newP.id = &#39;newP&#39;;
    newP.innerText = &#39;Helllo,kuangshen&#39;;

//创建一个标签节点
    var myScript = document.creatElement(&#39;script&#39;);
    myScript.setAttribute(&#39;type&#39;,&#39;text/css&#39;);
//可以创建一个style标签
var myStyle = document.creatElement(&#39;style&#39;);//创建了一个空style
myStyle.setAttribute(&#39;type&#39;,&#39;text/css&#39;);
myStyle.innerHTML = &#39;body{background-color;chartreuse;}&#39;;//设置标签内容

document.getElementsByTagName(&#39;head&#39;)[0].appengchild(myStyle)
&lt;/script&gt;</code></pre>
<h2 id="操作表单（验证）"><a href="#操作表单（验证）" class="headerlink" title="操作表单（验证）"></a>操作表单（验证）</h2><blockquote>
<p>表单是什么     form  DOM树</p>
</blockquote>
<ul>
<li>文本框    text</li>
<li>下拉框     select</li>
<li>单选框      radio</li>
<li>多选框      checkbox</li>
<li>隐藏域      hidden</li>
<li>密码框      password</li>
<li>……….</li>
</ul>
<p>表单的目的：提交信息</p>
<blockquote>
<p>获得要提交的信息</p>
</blockquote>
<ul>
<li>得到输入框的值      input_text.value</li>
<li>修改输入框的值       input_text.value = ‘123’</li>
<li>对于单选框，多选框等等固定的值，boy_radio.value只能取到当前的值，</li>
<li>查看返回的结果       boy_radio.checked;      </li>
</ul>
<p>提交表单</p>
<pre><code class="javascript">&lt;form action=&quot;post&quot;&gt;
    &lt;p&gt;
        &lt;span&gt;用户名：&lt;span&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;span&gt;密码：&lt;span&gt;&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;
    &lt;/p&gt;
//绑定事件   onclick  被点击
    &lt;button type=&quot;button&quot; onclick=&quot;aaa()&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
        function aaa(){
        alert(1)
    }
&lt;/script&gt;</code></pre>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><p>JavaScript</p>
<p>JQuery库，里面存在大量的javascript函数</p>
<blockquote>
<p>获取JQuery</p>
</blockquote>
<pre><code class="html">&lt;script src= &quot;&lt;script src=&quot;http://code.jquery.com/jquery-migrate-1.2.1.min.js&quot;&gt;&lt;/script&gt;&quot;&gt;</code></pre>
<p>公式：</p>
<p>$(selector   选择器).action()</p>
<pre><code class="javascript">两种方法

&lt;a href=&quot;&quot; id=&quot;test-jquery&quot;&gt;点我&lt;/a&gt;
&lt;script&gt;
    document.getElementById(&#39;id&#39;);


//选择器就是CSS选择器
$(&#39;#text-jquery&#39;).click(function(){
    alert(&#39;hello,jquery&#39;);
})</code></pre>
<p>选择器</p>
<pre><code class="html">&lt;script&gt;
  //原生JS，选择器少，麻烦不好记
    //标签
    document.getElementsByTagName();
    //id
    document.getElementsById();
    //类
    document.getElementsByClassName();


  //JQuery  css  中的选择器他全部都能用
    $(&#39;p&#39;).click();//标签选择器
    $(&#39;#id1&#39;).click();//id选择器
    $(&#39;.class&#39;).click();//class选择器
&lt;/script&gt;</code></pre>
<p>文档工具站：<a href="https://jquery.cuishifeng.cn/" target="_blank" rel="noopener">https://jquery.cuishifeng.cn/</a></p>
<blockquote>
<p>事件</p>
</blockquote>
<ul>
<li>鼠标事件</li>
</ul>
<pre><code class="javascript">//按下
mousedown()(JQuery)
//离开
mouseleave()(JQuery)
//移动
mousemove()(JQuery)
//点击结束
mouseover()(JQuery)</code></pre>
<ul>
<li>键盘事件</li>
<li>其他事件</li>
</ul>
<h3 id="操作DOM元素"><a href="#操作DOM元素" class="headerlink" title="操作DOM元素"></a>操作DOM元素</h3><p>节点文本操作</p>
<pre><code class="javascript">$(&#39;#test-ul li[name=python]&#39;).text();//获得值
$(&#39;#test-ul li[name-python]&#39;).text(&#39;设置值&#39;)；//设置值
$(&#39;#test-ul&#39;).html();  //获得值
$(&#39;#test-ul&#39;).html(&#39;设置值&#39;)  //设置值</code></pre>
<p>CSS的操作</p>
<pre><code class="javascript">$(&#39;#test-ul li[name=python]&#39;).css({&quot;color&quot;,&quot;red&quot;})</code></pre>
<p>元素的显示和隐藏：本质 display:none</p>
<pre><code class="javascript">$(&#39;#test-ul li[name=python]&#39;).show()
$(&#39;#test-ul li[name=python]&#39;).hide()</code></pre>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb<a id="more"></a></h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="1-1、-前言"><a href="#1-1、-前言" class="headerlink" title="1.1、 前言"></a>1.1、 前言</h3><ul>
<li>web开发，网页的意思</li>
<li>静态web<ul>
<li>html，css</li>
<li>提供给所有人看的数据始终不会变化</li>
</ul>
</li>
<li>动态web<ul>
<li>淘宝，几乎所有的网站</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同</li>
<li>技术栈：Servlt/JSP，ASP，PHP</li>
</ul>
</li>
</ul>
<p>在java中，动态web资源开发的技术统称为javaWeb</p>
<h3 id="1-2、web应用程序"><a href="#1-2、web应用程序" class="headerlink" title="1.2、web应用程序"></a>1.2、web应用程序</h3><p>web应用程序：可以提供浏览器访问的程序。</p>
<ul>
<li><p>a.html，b.html….多个web资源可以被外界访问，对外界提供服务。</p>
</li>
<li><p>你们能访问到的任何一个页面和资源，都存在与这个世界上的某一台计算机上。</p>
</li>
<li><p>URL：统一资源定位符</p>
</li>
<li><p>这个统一的web资源会被放在同一个文件夹下。</p>
</li>
<li><p>一个web应用由多部分组成(静态web，动态web)</p>
<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>java程序</li>
<li>jar包</li>
<li>配置文件（Properties）</li>
</ul>
</li>
</ul>
<p>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理。</p>
<h3 id="1-3、静态web"><a href="#1-3、静态web" class="headerlink" title="1.3、静态web"></a>1.3、静态web</h3><ul>
<li>*.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。</li>
<li>静态web存在的缺点<ul>
<li>web页面动态无法更新，所有用户看到的是同一个页面<ul>
<li>轮播图，点击特效：伪动态</li>
<li>Javascript[实际开发中，他用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>他无法和数据库交互(数据无法持久化，用户无法交互)</li>
</ul>
</li>
</ul>
<h3 id="1-4、动态web"><a href="#1-4、动态web" class="headerlink" title="1.4、动态web"></a>1.4、动态web</h3><p>页面会动态展示：web的页面展示的效果因人而异。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201107161657089.png" alt="image-20201107161657089"></p>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布<ul>
<li>停机维护</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有的用户看到都不是同一个页面。</li>
<li>他可以与数据库交互（数据持久化：注册，商品信息）</li>
</ul>
<h2 id="2、Web服务器"><a href="#2、Web服务器" class="headerlink" title="2、Web服务器"></a>2、Web服务器</h2><h3 id="2-1、技术讲解"><a href="#2-1、技术讲解" class="headerlink" title="2.1、技术讲解"></a>2.1、技术讲解</h3><p><strong>ASP</strong></p>
<ul>
<li>微软：国内最早流行的就是ASP</li>
<li>在html中嵌入了VB的脚本，ASP+COM</li>
<li>在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱</li>
<li>维护成本高</li>
<li>C#</li>
</ul>
<p><strong>PHP</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码简单</li>
<li>无法承载大访问量的情况（局限性）</li>
</ul>
<p><strong>JSP/Servlet</strong></p>
<p>B/S:浏览器和服务器</p>
<p>C/S：客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的（所有大公司，或者一些开源的组件，都是用Java写的）</li>
<li>可以承载三高问题带来的影响</li>
</ul>
<h3 id="2-2、web服务器"><a href="#2-2、web服务器" class="headerlink" title="2.2、web服务器"></a>2.2、web服务器</h3><p>服务器是一种被动的操作，用来处理用户的请求和用户的一些响应信息</p>
<p><strong>IIS</strong></p>
<p>微软的：ASP…..Windows中自带。</p>
<p><strong>Tomcat</strong></p>
<p>下载tomcat：</p>
<p>1.安装或解压</p>
<p>2.了解配置文件及目录结构</p>
<p>3.了解tomcat的作用</p>
<h2 id="3、Tomcat"><a href="#3、Tomcat" class="headerlink" title="3、Tomcat"></a>3、Tomcat</h2><h3 id="3-1、安装tomcat"><a href="#3-1、安装tomcat" class="headerlink" title="3.1、安装tomcat"></a>3.1、安装tomcat</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201107165304701.png" alt="image-20201107165304701"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201107165406879.png" alt="image-20201107165406879"></p>
<h3 id="3-2、Tomcat启动和配置"><a href="#3-2、Tomcat启动和配置" class="headerlink" title="3.2、Tomcat启动和配置"></a>3.2、Tomcat启动和配置</h3><p>文件夹作用：</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201107165803596.png" alt="image-20201107165803596"></p>
<p><strong>启动。关闭Tomcat</strong></p>
<p>bin目录下：startup 开启。shutdown：关闭</p>
<p>可能遇到的问题：</p>
<ul>
<li>java环境变量没有配置</li>
<li>闪退问题：需要配置兼容性</li>
<li>乱码问题</li>
</ul>
<h3 id="3-3、配置"><a href="#3-3、配置" class="headerlink" title="3.3、配置"></a>3.3、配置</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201107171644336.png" alt="image-20201107171644336"></p>
<p>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<pre><code class="xml">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot;/&gt;</code></pre>
<p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为：localhost</li>
<li>默认网站应用存放的位置：webapps</li>
</ul>
<pre><code class="xml">&lt;Host name=&quot;www.qinjiang.com&quot; appBass=&quot;webapps&quot;
      unpackWARs=&quot;true&quot; autoDeploy=&quot;ture&quot;&gt;</code></pre>
<p><strong>高难度面试题</strong></p>
<p>请你谈谈网站是如何进行访问的</p>
<ul>
<li><p>输入一个域名：回车</p>
</li>
<li><p>检查本机的hosts配置文件下有没有这个域名的映射</p>
<ul>
<li>有，直接返回对应的ip地址，这个地址中有我们要访问的web程序</li>
<li>没有，去DNS服务器找，找到的话就返回，找不到就返回找不到</li>
</ul>
</li>
<li><p>可以配置一下环境变量</p>
</li>
</ul>
<h3 id="3-4、发布一个web网站"><a href="#3-4、发布一个web网站" class="headerlink" title="3.4、发布一个web网站"></a>3.4、发布一个web网站</h3><p>不会就先模仿</p>
<ul>
<li>将自己写的网站，放到服务器（Tomcat）中指定的web应用文件夹下（webapps）下，就可以访问了。</li>
</ul>
<p>网站应该有的结构</p>
<pre><code class="java">--webapps:Tomcat服务器的web目录
    -ROOT
    -kuangstudy:网站的目录名
        -WEB-INF
            -class:java程序
            -lib:web应用所依赖的jar包
            -web.xml:网站的配置文件
        -index.html默认的首页
        -static
            -css
                -style.css
            -js
            -img
</code></pre>
<p>HTTP协议：面试</p>
<p>Maven：构建工具</p>
<ul>
<li>Maven安装包</li>
</ul>
<p>Servlet入门</p>
<ul>
<li>HelloWorld</li>
<li>Servlet配置</li>
<li>原理</li>
</ul>
<h2 id="4、HTTP"><a href="#4、HTTP" class="headerlink" title="4、HTTP"></a>4、HTTP</h2><h3 id="4-1、什么是HTTP"><a href="#4-1、什么是HTTP" class="headerlink" title="4.1、什么是HTTP"></a>4.1、什么是HTTP</h3><p>​     HTTP（超文本传输协议）是一个简单的请求响应协议，它通常运行在TCP之上。</p>
<ul>
<li>文本：html，字符串。</li>
<li>超文本：图片，音乐，视频….</li>
<li>端口80</li>
</ul>
<p>HTTPS：安全的</p>
<ul>
<li>443</li>
</ul>
<h3 id="4-2、两个时代"><a href="#4-2、两个时代" class="headerlink" title="4.2、两个时代"></a>4.2、两个时代</h3><ul>
<li>http1.0<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接。</li>
</ul>
</li>
<li>http2.0<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。</li>
</ul>
</li>
</ul>
<h3 id="4-3、Http请求"><a href="#4-3、Http请求" class="headerlink" title="4.3、Http请求"></a>4.3、Http请求</h3><ul>
<li>客户端–发请求–</li>
</ul>
<p>百度：</p>
<pre><code class="java">Ruquest URL:https://www.baidu.com/   请求地址
Request Method:GET        get方法/post方法
Status Code:200  ok    状态码:200
Remote(远程) Address:14.215.177.39:443</code></pre>
<pre><code class="java">Accept:text/html
Accpet-Encoding:gzip,deflate, br
Accpet-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive</code></pre>
<p><strong>请求行</strong></p>
<ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：Get，Post，HEAD，DELETE，PUT，TRACT….<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post：请求能携带的参数没有限制，大小没有限制，不会再浏览器的URL地址栏显示数据内容，安全，但不高效</li>
</ul>
</li>
</ul>
<p><strong>消息头</strong></p>
<pre><code class="java">Accpt:告诉浏览器，他所支持的数局类型
Accpt-Encoding:支持哪种编码格式    GBK UTF-8 GB2312 Iso8859-1
Accpt-Language:告诉浏览器，他的语言环境
Cache-Control:缓存控制
Connertion:告诉浏览器，请求完成是断开还是保持连接
HOST:主机</code></pre>
<h3 id="4-4、Http响应"><a href="#4-4、Http响应" class="headerlink" title="4.4、Http响应"></a>4.4、Http响应</h3><ul>
<li>服务器—响应—客户端</li>
</ul>
<p>百度：</p>
<pre><code class="java">Cache-Control:private     缓存控制
Connection:keep-Alive     连续
Content-Encoding:gzip     编码
Content-Type:text/html    类型</code></pre>
<p><strong>响应体</strong></p>
<pre><code class="java">Accpt:告诉浏览器，他所支持的数局类型
Accpt-Encoding:支持哪种编码格式    GBK UTF-8 GB2312 Iso8859-1
Accpt-Language:告诉浏览器，他的语言环境
Cache-Control:缓存控制
Connertion:告诉浏览器，请求完成是断开还是保持连接
HOST:主机

Refrush:告诉客户端刷新频率
Location:让网页重新定位   </code></pre>
<p><strong>响应状态码</strong></p>
<p>200：请求响应成功</p>
<p>3XX：请求重定向</p>
<ul>
<li>重定向：你重新到我给你的新位置</li>
</ul>
<p>4XX：找不到资源   404</p>
<ul>
<li>资源不存在</li>
</ul>
<p>5XX：服务器代码错误    500          502：网关错误</p>
<p><strong>常见面试题</strong></p>
<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<h2 id="5、Maven"><a href="#5、Maven" class="headerlink" title="5、Maven"></a>5、Maven</h2><p><strong>为什么要学习这个技术？</strong></p>
<p>1.在Javaweb开发中，需要使用大量的Jar包，我们手动去导入</p>
<p>2.如何能够让一个东西自动帮我导入和配置这个jar包。</p>
<p>​    由此Maven诞生了</p>
<h3 id="5-1、Maven项目架构管理工具"><a href="#5-1、Maven项目架构管理工具" class="headerlink" title="5.1、Maven项目架构管理工具"></a>5.1、Maven项目架构管理工具</h3><p>我们目前用来就是方便导入jar包的！</p>
<p>Maven的核心思想：约定大于配置</p>
<ul>
<li>有约束，不要去违反</li>
</ul>
<p>Maven会规定好你该如何去编写我们的Java代码，必须按规定来</p>
<h3 id="5-2、下载安装Maven"><a href="#5-2、下载安装Maven" class="headerlink" title="5.2、下载安装Maven"></a>5.2、下载安装Maven</h3><p>官网：<a href="https://maven.apache.org/" target="_blank" rel="noopener">https://maven.apache.org/</a></p>
<p>下载完成后，解压即可</p>
<h3 id="5-3、配置环境变量"><a href="#5-3、配置环境变量" class="headerlink" title="5.3、配置环境变量"></a>5.3、配置环境变量</h3><p>在我们的系统环境中</p>
<p>配置如下配置</p>
<ul>
<li>M2_HOME      maven目录下的bin目录</li>
<li>MAVEN_HOME    maven的目录</li>
<li>在系统的path中配置%MAVEN_HOME%\bin</li>
</ul>
<p>测试Maven是否安装成功，保证必须配置完毕</p>
<pre><code class="java">mvn -version</code></pre>
<h3 id="5-4、阿里云镜像"><a href="#5-4、阿里云镜像" class="headerlink" title="5.4、阿里云镜像"></a>5.4、阿里云镜像</h3><ul>
<li>镜像：mirrors<ul>
<li>作用：加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<pre><code class="xml"> &lt;mirror&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt;
     &lt;mirrorof&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorof&gt;
        &lt;name&gt; Nexus aliyun&lt;/name&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;

    &lt;/mirror&gt;</code></pre>
<h3 id="5-5、本地仓库"><a href="#5-5、本地仓库" class="headerlink" title="5.5、本地仓库"></a>5.5、本地仓库</h3><p><strong>建立一个本地仓库:</strong>localRepository</p>
<pre><code class="xml"> &lt;localRepository&gt;D:\Program Files (x86)\apache-maven-3.6.3-bin\apache-maven-3.6.3\maven-repo&lt;/localRepository&gt;</code></pre>
<h3 id="5-6、在idea中使用Maven"><a href="#5-6、在idea中使用Maven" class="headerlink" title="5.6、在idea中使用Maven"></a>5.6、在idea中使用Maven</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110110131290.png" alt="image-20201110110131290"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110110541132.png" alt="image-20201110110541132"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110110840932.png" alt="image-20201110110840932"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110111213580.png" alt="image-20201110111213580"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110113737211.png" alt="image-20201110113737211"></p>
<h3 id="5-7、创建一个普通的Maven项目"><a href="#5-7、创建一个普通的Maven项目" class="headerlink" title="5.7、创建一个普通的Maven项目"></a>5.7、创建一个普通的Maven项目</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110114656095.png" alt="image-20201110114656095"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110115708908.png" alt="image-20201110115708908"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110120425839.png" alt="image-20201110120425839"></p>
<h3 id="5-8、在IDEA中标记文件夹内容"><a href="#5-8、在IDEA中标记文件夹内容" class="headerlink" title="5.8、在IDEA中标记文件夹内容"></a>5.8、在IDEA中标记文件夹内容</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110120531117.png" alt="image-20201110120531117"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110120814218.png" alt="image-20201110120814218"></p>
<h3 id="5-9、在IDEA中配置TOmcat"><a href="#5-9、在IDEA中配置TOmcat" class="headerlink" title="5.9、在IDEA中配置TOmcat"></a>5.9、在IDEA中配置TOmcat</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110121243196.png" alt="image-20201110121243196"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110121426242.png" alt="image-20201110121426242"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110121755243.png" alt="image-20201110121755243"></p>
<p>解决警告问题</p>
<p>为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110122105184.png" alt="image-20201110122105184"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110122256726.png" alt="image-20201110122256726"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110122557719.png" alt="image-20201110122557719"></p>
<h3 id="5-10、pom文件"><a href="#5-10、pom文件" class="headerlink" title="5.10、pom文件"></a>5.10、pom文件</h3><p>pom.xml是Maven的核心配置文件</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110123405151.png" alt="image-20201110123405151"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110124220240.png" alt="image-20201110124220240"></p>
<p><strong>Maven的高级之处在于：</strong>他会帮你导入这个jar包所依赖的其他jar包</p>
<p>maven由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="xml">&lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110125041883.png" alt="image-20201110125041883"></p>
<p><strong>百度Maven仓库即可找到对应的jar包</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.kuang&lt;/groupId&gt;
  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;

  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;
  &lt;!-- FIXME change it to the project&#39;s website --&gt;
  &lt;url&gt;http://www.example.com&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.8.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.22.1&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.2.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="5-11、IDEA操作"><a href="#5-11、IDEA操作" class="headerlink" title="5.11、IDEA操作"></a>5.11、IDEA操作</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201110125420366.png" alt="image-20201110125420366"></p>
<h2 id="6、-Servlet"><a href="#6、-Servlet" class="headerlink" title="6、 Servlet"></a>6、 Servlet</h2><h3 id="6-1、Servlet简介"><a href="#6-1、Servlet简介" class="headerlink" title="6.1、Servlet简介"></a>6.1、Servlet简介</h3><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供了一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个步骤：<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的java类部署到服务器中。</li>
</ul>
</li>
</ul>
<p>把实现了Servlet接口的Java程序叫做，Servlet</p>
<h3 id="6-2、HelloServlet"><a href="#6-2、HelloServlet" class="headerlink" title="6.2、HelloServlet"></a>6.2、HelloServlet</h3><p>Maven导入Servlet包和Jsp包</p>
<pre><code class="xml">&lt;dependencies&gt;

    &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;



&lt;/dependencies&gt;</code></pre>
<ol>
<li><p>构建一个普通的Maven项目，删除里面的src目录，以后我们的学习就是在这个项目里面建立Moudel；这个空的工程就是Maven的主工程。</p>
</li>
<li><p>关于Maven父子工程的理解 ：</p>
<p>父项目中会有</p>
</li>
</ol>
<pre><code class="xml">&lt;moudles&gt;
    &lt;module&gt;servlet-01&lt;/module&gt;
&lt;/moudles&gt;</code></pre>
<p>​    子项目中会有</p>
<pre><code class="xml">&lt;parent&gt;
        &lt;artifactId&gt;javaweb-01-servlet&lt;/artifactId&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;</code></pre>
<p>父项目中的jar包子项目可以直接使用</p>
<pre><code class="xml">son extends father</code></pre>
<ol start="3">
<li>Maven环境优化<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整<ol>
<li>在main目录下添加java包和resources</li>
<li>在java包中创建class</li>
</ol>
</li>
</ol>
</li>
<li>编写一个Servlet程序<ol>
<li>编写一个普通类</li>
<li>实现Servlet接口，这里我们直接继承HttpServlet</li>
</ol>
</li>
</ol>
<pre><code class="java">public class HelloServlet  extends HttpServlet {
    //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter();//Ctrl+Alt+v自动生成个对象    响应流
        writer.print(&quot;HelloServlet&quot;);


    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req,resp);
        //doGet(req, resp);这样递归会导致内存溢出
    }
}
</code></pre>
<ol start="5">
<li><p>编写Servlet的映射</p>
<p>为什么需要映射：我们写的是JAVA程序，但是我们需要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet，还需要给他一个浏览器可以访问的路径</p>
<p>在web.xml中</p>
<pre><code class="xml">&lt;!--最新的web.xml--&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;

&lt;/web-app&gt;</code></pre>
</li>
</ol>
<pre><code class="xml">   &lt;!--    注册Servlet--&gt;
   &lt;servlet&gt;
       &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
       &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;!--    servlet的请求路径（映射路径）--&gt;
       &lt;servlet-mapping&gt;
           &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
           &lt;url-pattern&gt;/Hello&lt;/url-pattern&gt;
       &lt;/servlet-mapping&gt;
</code></pre>
<ol start="6">
<li><p>配置Tomcat</p>
<p>注意：配置项目发布的路径就可以了</p>
</li>
<li><p>启动测试</p>
</li>
</ol>
<h3 id="6-3、Servlet原理"><a href="#6-3、Servlet原理" class="headerlink" title="6.3、Servlet原理"></a>6.3、Servlet原理</h3><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求后，会</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201112165230005.png" alt="image-20201112165230005"></p>
<h3 id="6-4、Mapping问题"><a href="#6-4、Mapping问题" class="headerlink" title="6.4、Mapping问题"></a>6.4、Mapping问题</h3><ol>
<li>一个Servlet请求可以指定一个映射路径</li>
</ol>
<pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<ol start="2">
<li><p>一个Servlet请求可以指定多个映射路径</p>
<pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre>
</li>
<li><p>一个Servlet请求可以指定通用映射路径</p>
</li>
</ol>
<pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre>
<ol start="4">
<li>默认请求路径</li>
</ol>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre>
<ol start="5">
<li>指定一些后缀或者前缀等等</li>
</ol>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*.doc&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre>
<h3 id="6-5、ServletContext"><a href="#6-5、ServletContext" class="headerlink" title="6.5、ServletContext"></a>6.5、ServletContext</h3><p>web容器在启动的时候，它会为每个web程序都创建一个ServletContext对象，他代表了当前的web应用</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201114124435157.png" alt="image-20201114124435157"></p>
<h4 id="1、共享数据"><a href="#1、共享数据" class="headerlink" title="1、共享数据"></a>1、共享数据</h4><p>我在这个Servlet中保存的数据，可以在另外一个servlet中拿到</p>
<pre><code class="java">//用context.setAttribute将数据放到ServletContext中      
        //this.getServletConfig();  Servlet配置
        //this.getInitParameter();  初始化参数
        //this.getServletContext(); Servlet上下文
        ServletContext context = this.getServletContext();

        String username = &quot;秦疆&quot;; //数据
        context.setAttribute(&quot;username&quot;,username);//将一个数据保存到ServletContext中，键（名字）为username，值为username</code></pre>
<pre><code class="java">//通过context.getAttribute拿到数据
public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doGet(req, resp);

        ServletContext context = this.getServletContext();
        String username =(String)context.getAttribute(&quot;username&quot;);//将context.getAttribute转为String类型

        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字&quot;+username);



    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }</code></pre>
<pre><code class="java">//配置web.xml文件
&lt;servlet&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.GetServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</code></pre>
<p>测试访问结果：</p>
<h4 id="2、获取初始化参数"><a href="#2、获取初始化参数" class="headerlink" title="2、获取初始化参数"></a>2、获取初始化参数</h4><pre><code class="xml">&lt;!--在web.xml中配置一些web应用的参数--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc://localhost:3306/mybatis&lt;/param-value&gt;
    &lt;/context-param&gt;</code></pre>
<pre><code class="java">ServletContext context = this.getServletContext();
        String url = context.getInitParameter(&quot;url&quot;);
        resp.getWriter().print(url);</code></pre>
<h4 id="3、请求转发"><a href="#3、请求转发" class="headerlink" title="3、请求转发"></a>3、请求转发</h4><p>请求转发</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201114124932600.png" alt="image-20201114124932600"></p>
<p>重定向</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201114125010745.png" alt="image-20201114125010745"></p>
<pre><code class="java">public class ServletDemo04 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);


        ServletContext context = this.getServletContext();
        System.out.println(&quot;进入了ServletDemo04&quot;);
        //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;);转发的请求路径
        //requestDispatcher.forward(req,resp);调用forward实现请求转发
        context.getRequestDispatcher(&quot;/gp&quot;).forward(req,resp);
    }</code></pre>
<pre><code class="xml">&lt;servlet&gt;
        &lt;servlet-name&gt;sd4&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.ServletDemo04&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sd4&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/sd4&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</code></pre>
<h4 id="4、读取资源文件"><a href="#4、读取资源文件" class="headerlink" title="4、读取资源文件"></a>4、读取资源文件</h4><p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称    classpath（类路径）</p>
<p><strong>思路：</strong></p>
<p>需要一个文件流</p>
<pre><code class="java">public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);

        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&quot;username&quot;);
        String pwd = prop.getProperty(&quot;password&quot;);

        resp.getWriter().print(user + &quot;:&quot; + pwd);
    }</code></pre>
<pre><code class="properties">username=root
password=123456</code></pre>
<p>访问测试即可ok</p>
<h3 id="6-6、HttpServletResponse"><a href="#6-6、HttpServletResponse" class="headerlink" title="6.6、HttpServletResponse"></a>6.6、HttpServletResponse</h3><p><strong>响应：</strong></p>
<p>​        web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse对象；</p>
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletrRequest。</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse</li>
</ul>
<h4 id="1、简单分类"><a href="#1、简单分类" class="headerlink" title="1、简单分类"></a>1、简单分类</h4><p><strong>负责向浏览器发送数据的方法</strong></p>
<pre><code class="java">ServletOutputStream getOutputStream() throws IOException;
PrintWriter getWrite() throws IOException;</code></pre>
<p><strong>负责向浏览器发送响应头的方法</strong></p>
<pre><code class="java">void setCharacterEncoding(String var1);

void setContentLength(int var1);

void setContentlengthLong(long var1);

void setContentType(String var1);

void setDateHeader(String var1, long var2);

void addDateHeader(String var1, long var2);

void setHeader(String var1, String var2);

void addHeader(String var1, String var2);

void setIntHeader(String var1, int var2);

void addIntHeader(String var1, int var2);

</code></pre>
<p><strong>响应状态码：</strong></p>
<p>200：请求响应成功</p>
<p>3XX：请求重定向</p>
<ul>
<li>重定向：你重新到我给你的新位置</li>
</ul>
<p>4XX：找不到资源   404</p>
<ul>
<li>资源不存在</li>
</ul>
<p>5XX：服务器代码错误    500          502：网关错误</p>
<h4 id="2、常见应用"><a href="#2、常见应用" class="headerlink" title="2、常见应用"></a>2、常见应用</h4><ol>
<li>向浏览器输出消息</li>
<li>下载文件<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区的数据输出到客户端</li>
</ol>
</li>
</ol>
<pre><code class="java">public class FileServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);
//        1. 要获取下载文件的路径
        String realPath =&quot;D:\\Develop\\javaweb-01-servlet\\response\\src\\main\\resources\\1.png&quot;;
        System.out.println(&quot;下载文件的路径: &quot;+realPath);
//        2. 下载的文件名是啥
        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
//        3. 设置想办法让浏览器能够支持(&quot;Content-Disposition&quot;)下载我们需要的东西,中文文件名URLEncoder.encode(fileName,&quot;UTF-8&quot;)编码，否则会乱码
        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));
//        4. 获取下载文件的输入流
        FileInputStream in = new FileInputStream(realPath);
//        5. 创建缓冲区
        int len = 0;
        byte[] buffer = new byte[1024];
//        6. 获取OutputStream对象
        ServletOutputStream out = resp.getOutputStream();
//        7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区的数据输出到客户端
        while((len=in.read(buffer))&gt;0){
            out.write(buffer,0,len);
        }
//        8.关闭流
        in.close();
        out.close();


    }</code></pre>
<h4 id="3、验证码的功能"><a href="#3、验证码的功能" class="headerlink" title="3、验证码的功能"></a>3、验证码的功能</h4><ul>
<li>前端实现</li>
<li>后端实现，需要用到Java的图片类，生产一个图片</li>
</ul>
<pre><code class="java">public class imageServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);
        //如何让浏览器三秒自动刷新一次
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);

        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics();//笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpg&quot;);
        //网站存在缓存，不让网站缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-Cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-Cache&quot;);

        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());



    }
    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0 ; i &lt; 7-num.length() ; i++){
            sb.append(0);
        }
        num = sb.toString() + num;
        return num;
    }</code></pre>
<p>记得更改web.xml文件</p>
<h4 id="4、实现重定向"><a href="#4、实现重定向" class="headerlink" title="4、实现重定向"></a>4、实现重定向</h4><p>B一个web资源收到客户端A请求后，B他会通知A客户端去访问另一个web资源C，这个过程叫重定向。</p>
<p>常见场景：</p>
<ul>
<li><p>用户登录</p>
<pre><code class="java">void sendRedirect (String var1) throws IOExcepion;</code></pre>
</li>
</ul>
<p>测试：</p>
<pre><code class="java">public class RedirectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);
//两种方法重定向
        //第一种:
        resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);
        resp.setStatus(302);
        //第二种
        resp.sendRedirect(&quot;/r/img&quot;);
</code></pre>
<p>面试题：请你聊聊重定向跟转发的区别？</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化</li>
<li>重定向的时候，url地址栏会发生变化</li>
</ul>
<p><strong>处理登陆请求：</strong></p>
<pre><code class="java">public class RequestTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //处理请求
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);

        System.out.println(username + &quot;:&quot; + password);

        //重定向的时候一定要注意，路径问题，否则404
        resp.sendRedirect(&quot;/r/success.jsp&quot;);
</code></pre>
<pre><code class="html">&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Hello World!&lt;/h2&gt;
&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;
&lt;%-- %{pageContext.request.contextPath}代表当前的项目--%&gt;
&lt;form action=&quot;${pageContext.request.contextPath}/login&quot;method=&quot;get&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Success&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="6-7、HttpServletRequest"><a href="#6-7、HttpServletRequest" class="headerlink" title="6.7、HttpServletRequest"></a>6.7、HttpServletRequest</h3><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这HttpServletRequest的方法，获得客户端的所有信息 </p>
<h4 id="1-、获取前端传递的参数，并请求转发"><a href="#1-、获取前端传递的参数，并请求转发" class="headerlink" title="1 、获取前端传递的参数，并请求转发"></a>1 、获取前端传递的参数，并请求转发</h4><pre><code class="java">getParameter(String s)//返回字符串
getparameterValues(String s[])//返回数组</code></pre>
<pre><code class="java">public class LoginServlet  extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);
        //解决控制台乱码问题
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        req.setCharacterEncoding(&quot;utf-8&quot;);

        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        String[] hobbys = req.getParameterValues(&quot;hobbys&quot;);
        System.out.println(&quot;====================================&quot;);
        System.out.println(username);
        System.out.println(password);
        System.out.println(Arrays.toString(hobbys));
        System.out.println(&quot;====================================&quot;);


        //这里的 / 代表当前的web应用
        req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);


    }</code></pre>
<pre><code class="jsp">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;%--    这里表单的意思是用post的方式提交表单，到login请求--%&gt;
    &lt;form action=&quot;${pageContext.request.contextPath}/login&quot; method=&quot;post&quot;&gt;
        用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
        密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;

        爱好:
        &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;女孩&quot;&gt;女孩
        &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;代码&quot;&gt;代码
        &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;唱歌&quot;&gt;唱歌
        &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;电影&quot;&gt;电影&lt;br&gt;

        &lt;input type=&quot;submit&quot;&gt;
    &lt;/form&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="jsp">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;登陆成功&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="7、Cookie、Session"><a href="#7、Cookie、Session" class="headerlink" title="7、Cookie、Session"></a>7、Cookie、Session</h2><h3 id="7-1、会话"><a href="#7-1、会话" class="headerlink" title="7.1、会话"></a>7.1、会话</h3><p><strong>会话：</strong>用户打开一个浏览器，点击了很多链接，访问了多个web资源，关闭浏览器，这个过程称之为会话</p>
<p><strong>有状态会话：</strong>一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过</p>
<p><strong>一个网站，怎么证明你来过？</strong></p>
<p>客户端                        服务端</p>
<ol>
<li>服务端给客户端一个信件，客户端下次访问时服务端带上信件就可以了；cookie</li>
<li>服务器登记你来过了，下次你来的时候我来匹配你；session</li>
</ol>
<h3 id="7-2、保存会话的两种技术"><a href="#7-2、保存会话的两种技术" class="headerlink" title="7.2、保存会话的两种技术"></a>7.2、保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术（响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息我们可以把信息或数据放在Session中</li>
</ul>
<p><strong>常见场景：</strong>网站登录之后，你下次不用再登陆了，第二次访问直接就上去了。</p>
<h3 id="7-3、Cookie"><a href="#7-3、Cookie" class="headerlink" title="7.3、Cookie"></a>7.3、Cookie</h3><ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<pre><code class="java">Cookie[] cookies = req.getCookies();//获取Cookie
cookie.getName();//获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
Cookie cookie = new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);//新建一个cookie
cookie.setMaxAge(24*60*60);//设置cookie的有效期
resp.addCookie(cookie);//响应一个cookie给客户端</code></pre>
<p>cookie：一般会保存在用户目录下appdata文件下。</p>
<pre><code class="java">public class CookieDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doGet(req, resp);
       //服务器，告诉你，你来的时候，把这个时间封装成一个信件，你下次带上，我就知道你来了

       //解决中文乱码问题
       req.setCharacterEncoding(&quot;utf-8&quot;);
       resp.setCharacterEncoding(&quot;utf-8&quot;);


        PrintWriter out = resp.getWriter();

        //Cookie,服务器从客户端获取
        Cookie[] cookies = req.getCookies();//这里返回数组，说明Cookie可能存在多个

        //判断Cookie是否存在
        if (cookies!=null){
            //如果存在怎么办
            out.write(&quot;你上次访问的时间是:&quot;);
            for (int i = 0; i&lt; cookies.length; i++){
                Cookie cookie = cookies[i];
                //获取cookies的名字
                if (cookie.getName().equals(&quot;lastLoginTime&quot;)){
                    //获取cookie中的值
                    long lastLoginTime = Long.parseLong(cookie.getValue());
                    Date date = new Date(lastLoginTime);
                    out.write(date.toLocaleString());
                }
            }
        }else {
            out.write(&quot;这是您第一次访问本站&quot;);
        }
        //服务端给客户端响应一个cookie
        Cookie cookie = new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);
        //设置cookie的有效期为1天
        cookie.setMaxAge(24*60*60);
        resp.addCookie(cookie);

    }
</code></pre>
<pre><code class="xml">&lt;servlet&gt;
        &lt;servlet-name&gt;CookieDemo01&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.CookieDemo01&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;CookieDemo01&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/c1&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</code></pre>
<p><strong>一个网站cookie是否存在上限</strong></p>
<ul>
<li>一个Cookie只能保存一个信息</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie</li>
<li>Cookie大小有限制4KB</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie：</strong></p>
<ul>
<li>不设置有效期，关闭浏览器，自动失效</li>
<li>设置有效期为0</li>
</ul>
<pre><code class="java">//创建一个cookie，没名字必须跟要删除的名字保持一致
Cookie cookie = new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);
        //设置cookie的有效期为0，立马过期
        cookie.setMaxAge(0);
        resp.addCookie(cookie);</code></pre>
<h3 id="7-4、Session（重点）"><a href="#7-4、Session（重点）" class="headerlink" title="7.4、Session（重点）"></a>7.4、Session（重点）</h3><p>什么是Session：</p>
<ul>
<li>服务器会给每一个用户(浏览器)创建一个Session对象</li>
<li>一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在</li>
<li>用户登录之后，整个网站都可以访问（保存用户的信息，保存购物车的信息）</li>
</ul>
<p><strong>Session和cookie的区别：</strong></p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）</li>
<li>Session把用户的数据写到独占Session中，在服务器端保存（保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务器创建</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>保存一个登录用户的信息</li>
<li>购物车信息</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中</li>
</ul>
<p><strong>使用Session：</strong></p>
<pre><code class="java">package com.kuang.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //解决乱码问题
        req.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);

        //得到Session
        HttpSession session = req.getSession();

        //给Session中存东西
        session.setAttribute(&quot;name&quot;,&quot;秦疆&quot;);

        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if(session.isNew()){
            resp.getWriter().write(&quot;session创建成功，ID:&quot;+sessionId);
        }else {
            resp.getWriter().write(&quot;session已经创建，ID:&quot;+sessionId);

        }
        //Session创建的时候做了什么事情
        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);
        resp.addCookie(cookie);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<p>会话自动过期：web.xml配置</p>
<pre><code class="java">&lt;!--设置session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;--15分钟后session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;</code></pre>
<h2 id="8、JSP"><a href="#8、JSP" class="headerlink" title="8、JSP"></a>8、JSP</h2><h3 id="8-1、什么是JSP"><a href="#8-1、什么是JSP" class="headerlink" title="8.1、什么是JSP"></a>8.1、什么是JSP</h3><p>java servlet Pages:Java服务器端页面，也和servlet一样，用于动态Web技术。</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别：<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面可以嵌入JAVA代码，为用户提供动态数据</li>
</ul>
</li>
</ul>
<h3 id="8-2、JSP原理"><a href="#8-2、JSP原理" class="headerlink" title="8.2、JSP原理"></a>8.2、JSP原理</h3><p>思路：JSP到底是怎么执行的？</p>
<ul>
<li>代码层面没有任何问题</li>
<li>服务器内部工作<ul>
<li>tomcat中有一个work目录</li>
<li>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录</li>
<li>发现页面转换成java程序</li>
</ul>
</li>
</ul>
<p>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</p>
<p>JSP继承HttpJspBase，HttpJspBase继承HttpServlet</p>
<pre><code class="java">&lt;!--在jsp中的html代码--&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Hello World!&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="java">out.write(&quot;&lt;html&gt;\n&quot;);
out.write(&quot;&lt;body&gt;\n&quot;);
out.write(&quot;&lt;h2&gt;Hello World!&lt;/h2&gt;\n&quot;);
out.write(&quot;&lt;/body&gt;&quot;);
out.write(&quot;&lt;/html&gt;&quot;);</code></pre>
<p>JSP本质就是一个Servlet</p>
<pre><code class="java">//初始化
    public void _jspInit(){

    }
//销毁
    public void _jspDEstory(){

    }
//JSPService
    public void _jspService(.HttpServletRequest  request,HttpServletResponse response)</code></pre>
<ol>
<li><p>判断请求</p>
</li>
<li><p>内置一些对象</p>
<pre><code class="java">final javax.servlet.jsp.PageContext.pageContext;//页面上下文
javax.servlet.http.HttpSession = null;//session
final javax.servlet.ServletContext application;//application
final javax.servlet.ServletConfig;//config
javax.servlet.jap.JspWrite out =null;//out
final java.lang.Object page = this;//page:当前页
HttpServletRequest request;//请求
HttpServletResponse response//响应</code></pre>
</li>
<li><p>输出页面前增加的代码</p>
<pre><code class="java">response.setContextType(&quot;text/html&quot;);//设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,true);
_jspx_page_context = pageContext;
application = pageContext .getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;</code></pre>
</li>
<li><p>以上的这些对象我们可以直接使用</p>
</li>
</ol>
<p>在JSP页面中：</p>
<p>只要是JAVA代码就会原封不动的输出</p>
<p>如果是HTML代码，就会被转换为：</p>
<pre><code class="java">out.write(&quot;&lt;html&gt;\r\n&quot;);</code></pre>
<p>这样的格式输出到前端</p>
<h3 id="8-3、JSP基本语法"><a href="#8-3、JSP基本语法" class="headerlink" title="8.3、JSP基本语法"></a>8.3、JSP基本语法</h3><p><strong>JSP表达式</strong></p>
<pre><code class="jsp">&lt;%--JSP表达式
    作用:z用来将程序的输出，输出到客户端
        &lt;%=变量或者表达式%&gt;
--%&gt;
    &lt;%=new java.util.Date()%&gt;</code></pre>
<p><strong>jsp脚本片段</strong></p>
<pre><code class="jsp">&lt;%
int sum = 0;
for (int i = 1;i&lt;=100; i++){
    sum+=1;
    }
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
%&gt;</code></pre>
<p><strong>在代码中嵌入html元素</strong></p>
<pre><code class="jsp">&lt;%
for (int i = 0; i&lt;5; i++){
%&gt;

&lt;h1&gt;Hello,World &lt;%=i%&gt;&lt;/h1&gt;

&lt;%
}
%&gt;</code></pre>
<p><strong>jsp声明</strong></p>
<pre><code class="jsp">&lt;%!
    static{
        System.out.println(&quot;Loading servlet!&quot;);
    }
    private  int globalvar = 0;

    public void kuang(){
        System.out.println(&quot;进入了方法kuang！&quot;);
    }

%&gt;</code></pre>
<p>JSP声明：会被编译到JSP生成java的类中！其他的，就会被生成到jspService方法中。</p>
<pre><code class="jsp">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;

&lt;%--注释--%&gt;</code></pre>
<p>JSP的注释，不会在客户端显示，HTML的会</p>
<h3 id="8-4、JSP指令"><a href="#8-4、JSP指令" class="headerlink" title="8.4、JSP指令"></a>8.4、JSP指令</h3><pre><code class="jsp">&lt;%@page args....%&gt;
&lt;%@include file=&quot;&quot;%&gt;

    &lt;%--@include会将两个页面合而为一--%&gt;
    &lt;%@include file=&quot;common/header.jsp&quot;%&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;%@include file=&quot;common/footer.jsp&quot;%&gt;

    &lt;%--jsp标签
    jsp:include:拼接页面，本质是三个
    --%&gt;
    &lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;</code></pre>
<p><strong>错误页面</strong></p>
<pre><code class="xml">&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/error/404.jsp&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
<h3 id="8-5、9大内置对象"><a href="#8-5、9大内置对象" class="headerlink" title="8.5、9大内置对象"></a>8.5、9大内置对象</h3><ul>
<li>PageContext  存东西</li>
<li>Request  存东西</li>
<li>Response</li>
<li>Session  存东西</li>
<li>Application  [ServletContext]   存东西</li>
<li>config  [ServletConfig]</li>
<li>out</li>
<li>page</li>
<li>exception</li>
</ul>
<pre><code class="jsp">&lt;%--内置对象--%&gt;
&lt;%
    pageContext.setAttribute(&quot;name1&quot;,&quot;秦疆1号&quot;);
    //保存的数据只在一个页面中有效
    request.setAttribute(&quot;name2&quot;,&quot;秦疆2号&quot;);
    //保存的数据只在一次请求中有效，请求转发会携带这个数据
    session.setAttribute(&quot;name3&quot;,&quot;秦疆3号&quot;);
    //保存的数据只在一次会话中有效
    application.setAttribute(&quot;name4&quot;,&quot;秦疆4号&quot;);
    //保存的数据在服务器中有效
%&gt;

&lt;%
    //从pageContext取出，我们通过寻找的方式来
    //从底层到高层（作用域）
    String name1 = (String) pageContext.findAttribute(&quot;name1&quot;);
    String name2 = (String) pageContext.findAttribute(&quot;name2&quot;);
    String name3 = (String) pageContext.findAttribute(&quot;name3&quot;);
    String name4 = (String) pageContext.findAttribute(&quot;name4&quot;);
    String name5 = (String) pageContext.findAttribute(&quot;name5&quot;);

%&gt;
&lt;%--使用EL表达式输出  ${}--%&gt;

&lt;h1&gt;取出的值为:&lt;/h1&gt;
&lt;h3&gt;${name1}&lt;/h3&gt;
&lt;h3&gt;${name2}&lt;/h3&gt;
&lt;h3&gt;${name3}&lt;/h3&gt;
&lt;h3&gt;${name4}&lt;/h3&gt;
&lt;h3&gt;${name5}&lt;/h3&gt;</code></pre>
<p>request : 客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻页面</p>
<p>session：客户向服务器发送请求，产生的数据，用户看完一会还有用，比如：购物车</p>
<p>application : 客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可以用，比如：聊天数据</p>
<h3 id="8-6、JSP标签，JSTL，EL表达式"><a href="#8-6、JSP标签，JSTL，EL表达式" class="headerlink" title="8.6、JSP标签，JSTL，EL表达式"></a>8.6、JSP标签，JSTL，EL表达式</h3><pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;taglibs&lt;/groupId&gt;
      &lt;artifactId&gt;standard&lt;/artifactId&gt;
      &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;/dependency&gt;</code></pre>
<p>EL表达式：</p>
<ul>
<li>获取数据</li>
<li>执行运算</li>
<li>获取web开发的常用对象</li>
</ul>
<pre><code class="jsp">&lt;!--jsp:forward  
从一个JSP文件向另一个文件传递一个包含用户请求的request对象--&gt;
</code></pre>
<p><strong>JSTL</strong></p>
<p>引入JSTL核心标签库</p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201208122516078.png" alt="image-20201208122516078"></p>
<p><strong>JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的taglib</li>
<li>使用其中的方法</li>
<li>在Tomcat也需要引入jstl的包，否则会报错：JSTL解析错误</li>
</ul>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%--必须加上，否则el表达式无法解析--%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h4&gt;if 测试&lt;/h4&gt;
&lt;%--
EL表达式获取表单中的数据
${param.参数名}
--%&gt;
&lt;hr&gt;

&lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${param.username}&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
&lt;/form&gt;

&lt;%--
判断如果提交的用户名是管理员，则登陆成功
--%&gt;
&lt;c:if test=&quot;${param.username==&#39;admin&#39;}&quot; var=&quot;iaAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎您&quot;/&gt;
&lt;/c:if&gt;
&lt;c:out value=&quot;${iaAdmin}&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>c:set     c:when</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;95&quot;/&gt;


&lt;c:choose&gt;
    &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=80}&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=70}&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
&lt;/c:choose&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>forEach</strong></p>
<pre><code class="jsp">&lt;%--
var   每一次遍历出来的对象
items    要遍历的对象
begin    哪里开始
end        哪里结束
step    步长
--%&gt;
&lt;%
    ArrayLiat&lt;String&gt; people = new ArrayLiat&lt;&gt;();
    people.add(0,&quot;张三&quot;);
    people.add(1,&quot;李四&quot;);
    people.add(2,&quot;王五&quot;);
    people.add(3,&quot;赵六&quot;);
    request.setAttribute(&quot;list&quot;,people);
%&gt;

&lt;c:forEach var= &quot;people&quot; items=&quot;${list}&quot;&gt;
    &lt;c:out value =&quot;${people}&quot;/&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot;&gt;
    &lt;c:out value =&quot;${people}&quot;/&gt;
&lt;/c:forEach&gt;</code></pre>
<h3 id="9、JavaBean"><a href="#9、JavaBean" class="headerlink" title="9、JavaBean"></a>9、JavaBean</h3><p>实体类</p>
<p>JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法</li>
</ul>
<p><strong>一般用来和数据库的字段做映射    ORM</strong></p>
<p>ORM：对应关系映射</p>
<ul>
<li>表—-&gt;类</li>
<li>字段—–&gt;属性</li>
<li>行记录—-&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>秦疆1号</td>
<td>3</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>秦疆2号</td>
<td>18</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>秦疆3号</td>
<td>100</td>
<td>西安</td>
</tr>
</tbody></table>
<pre><code class="java">class People{
    private int id;
    private String name;
    private int age;
    private String address;
}
class A{
    new people(1,&quot;秦疆1号&quot;,3,&quot;西安&quot;);
    new people(2,&quot;秦疆2号&quot;,18,&quot;西安&quot;);
    new people(3,&quot;秦疆3号&quot;,100,&quot;西安&quot;);
}</code></pre>
<pre><code class="java">package com.kuang.pojo;
//实体类：我们一般都是和数据库中的表结构一一对应
public class People {
    private int id;
    private String name;
    private int age;
    private String address;

    public People() {
    }

    public People(int id, String name, int age, String address) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
</code></pre>
<h2 id="9、MVC三层架构"><a href="#9、MVC三层架构" class="headerlink" title="9、MVC三层架构"></a>9、MVC三层架构</h2><p>什么是MVC：Model     view     Controller    模型，视图，控制器</p>
<h3 id="10-1、-早些年"><a href="#10-1、-早些年" class="headerlink" title="10.1、 早些年"></a>10.1、 早些年</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201218111615978.png" alt="image-20201218111615978"></p>
<p>用户直接访问控制层，控制层就可以直接操作数据库库</p>
<pre><code class="java">servlet --CRUD --数据库
弊端：程序十分臃肿，不利于维护 //jbdc写在servlet里
servlet的代码中:处理请求，响应，试图跳转，处理JDBC，处理业务代码，处理逻辑代码</code></pre>
<h3 id="10-2、三层架构"><a href="#10-2、三层架构" class="headerlink" title="10.2、三层架构"></a>10.2、三层架构</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201218112654961.png" alt="image-20201218112654961"></p>
<p>Model：</p>
<ul>
<li>业务处理：业务逻辑（Servlet）</li>
<li>数据持久层：CRUD（Dao）</li>
</ul>
<p>View：</p>
<ul>
<li>展示数据</li>
<li>提供链接发起的Servlet请求</li>
</ul>
<p>Controller（Servlet）：</p>
<ul>
<li>接收用户的请求：（req：请求参数、Session信息….）</li>
<li>交给业务层处理对应的代码</li>
<li>控制视图的跳转</li>
</ul>
<pre><code class="java">登录--&gt;接收用户的请求--&gt;处理用户的请求(获取用户登录的参数，username，pasword)--&gt;交给业务层处理登陆业务(判断用户名和密码是否正确:事务)--&gt;Dao层查询用户名和密码是否正确--&gt;数据库</code></pre>
<h2 id="11、Filter"><a href="#11、Filter" class="headerlink" title="11、Filter"></a>11、Filter</h2><p>Filter:过滤器，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证</li>
</ul>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/11/07/JavaWeb/image-20201218114117171.png" alt="image-20201218114117171"></p>
<p>Filter开发步骤：</p>
<ul>
<li>导包</li>
<li>编写过滤器</li>
</ul>
<pre><code class="java">import javax.servlet.*;
import java.io.IOException;

public class Filter implements javax.servlet.Filter {
    //初始化
    public void init(FilterConfig filterConfig) throws ServletException {

    }
    //Chain：链
    /*
    1.过滤中的所有代码，在过滤特定请求的时候都会执行
    2.必须要让过滤器继续执行
    chain.doGilter(request,response)
    */
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    request.setCharacterEncoding(&quot;utf-8&quot;);
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);

    System.out.println(&quot;Filter执行前...&quot;);
    chain.doFilter(request,response);//让我们的请求继续走，如果不写，程序到这里就被拦截停止
    System.out.println(&quot;Filter执行后...&quot;);
    }

    public void destroy() {
        System.out.println(&quot;Filter销毁&quot;);

    }
}</code></pre>
<p>web.xml</p>
<pre><code class="xml">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.kuang.pojo.Filter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;Filter&lt;/filter-name&gt;
    &lt;!--只要是servlet的任何请求，都会经过这个过滤器--&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase-IO</title>
    <url>/Mr-lee-MQ.hithub.io/2020/09/20/Javase-IO/</url>
    <content><![CDATA[<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O<a id="more"></a></h1><h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><p>Java中的I/O操作主要是指使用Java.io包下的内容，进行输入，输出操作。输入也叫做读取数据，输出也叫做写出数据。</p>
<ul>
<li>根据数据的流向分为:输入流和输出流<ul>
<li>输入流:把数据从其它设备上读取到内存中的流</li>
<li>输出流:把数据从内存中写到其它设备上的流。</li>
</ul>
</li>
<li>格局数据的类型分为:字节流和字符流。</li>
</ul>
<p><a href="https://www.wailian.work/image/QmMm4p" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200921_152057.png" alt="sp200921_152057.png"></a></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流-OutputStream"><a href="#字节输出流-OutputStream" class="headerlink" title="字节输出流 OutputStream"></a>字节输出流 OutputStream</h3><p>OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。输出流接受输出字节并将这些字节发送到某个接收器。</p>
<pre><code class="java">/*
Java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

    public void close();关闭此输出流并释放与此流相关联的任何系统资源。
    public void flush();刷新此输出流并强制任何缓冲的输出字节被写出。
    public void write(byte[] b);将b.length字节从指定的字节数组写入到此输出流。
    public void write(byte[] b, int off, int len);从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。
    public abstract void write(int b);将指定的字节输出流。


*/</code></pre>
<pre><code class="java">/*
java.io.FileOutputStream extends OutputStream

FileOutputStream:文件字节输出流
作用:把内存中的数据写入到硬盘的文件中

    构造方法：
    FileOutputStream(String name)创建一个具有指定名称的文件中写入数据的输出文件流。
    FileOutputStream(File file)创建一个向指定File对象表示的文件中写入数据的文件输出流。
    参数：写入数据的目的
        String name:目的地是一个文件的路径。
        File file:目的地是一个文件
    构造方法的作用:
        1.创建一个FileOutputStream对象
        2.会根据构造方法中传递的文件/文件路径，创建一个空的文件。
        3.会把FileOutputStream对象指向创建好的文件。

    写入数据的原理：
        Java程序--&gt;JVM(java虚拟机)--&gt;OS(操作系统)--&gt;OS调用写数据的方法--&gt;把数据写入文件中

        字节输出流的使用步骤(重点):
            1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地。
            2.调用FileOutputStream对象中的方法write，把数据写入到文件中。
            3.释放资源(流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率)

*/


public class Demo01OutputStream{
    public static void main(String[] args){
        //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
        FileOutputStream fos = new FileOutputStream(&quot;09.IOAndProperties\\a.txt&quot;);
        //调用FileOutputStream对象中的方法write，把数据写入到文件中。
        //public abstract void write(int b);将指定的字节输出流。
        fos.write(97);
        fos.close();

    }

}</code></pre>
<p><strong>文件存储原理</strong></p>
<p><a href="https://www.wailian.work/image/QmMtHG" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200922_155941.png" alt="sp200922_155941.png"></a></p>
<h3 id="字节输出流写多个字节的方法"><a href="#字节输出流写多个字节的方法" class="headerlink" title="字节输出流写多个字节的方法"></a>字节输出流写多个字节的方法</h3><pre><code class="java">/*
一次写多个字节的方法:
    public void write(byte[] b):将b.length字节从指定的字节数组写入此输出流
    public void write(byte[], int off, int len):从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。

*/

 public class Demo02OutputStream{
     public static void main(String[] args){
         //创建FileOutputStream对象，构造方法
         FileOutputStream fos = new FileOutputStream(new File(&quot;09_IOAndProperties\\b.txt&quot;));
         //调用FileOutputStream对象中的方法write，把数据写入到文件中。
         //在文件中显示100，写个字节
         fos.write(49);
         fos.write(48);
         fos.write(48);

         /*
             public void write(byte[] b):将b.length字节从指定的字节数组写入此输出流。
             一次写多个字节:
                 如果写的第一个字节是正数，那么显示的时候会查询ASCII码表。
                 如果写的第一个字母是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表(GBK)


         */
         byte[] bytes = {-65,-66,-67,68,69};//[烤暘E]
         fos.write(bytes);

         /*
         public void write(byte[], int off, int len):把字节数组的一部分写入文件中
         从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。
         int off:数组的开始索引
         int len:写几个字节

         */
         fos.write(byte, 1, 2);//BC


         /*
         写入字符的方法：可以使用String类中的方法把字符串，转换为字节数组。
         byte[] getBytes()  把字符串转换为字节数组
         */
         byte[] bytes2 = &quot;你好&quot;.getBytes();
         System.out.println(Arrays.toString(bytes2));//[-28, -67, -96, -27, -91, -67]
         fos.write(bytes2);



         //释放资源
         fos.close();
     }
 }</code></pre>
<h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>每次运行程序时，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢</p>
<pre><code class="java">/*
追加写/续写：使用两个参数的构造方法
    FileOutputStream(String name, boolean append)创建一个向具有指定  name  的文件中写入数据的输出文件流
    FileOutputStream(File file, boolean append)创建一个向指定File对象表示的文件中写入数据的文件输出流。
    参数：
        String name，File file:写入数据的目的地
        boolean append:追加写开关
            true:创建对象不会覆盖源文件，继续在文件的末尾追加写数据
            false:创建一个新文件，覆盖源文件
写换行：写换行符号
    windows:\r\n
    linux:/n
    mac:/r

*/
public class Demo03OutputStream{
    public static void main(String[] args){
      FileOutputStream fos = new fileOutputStream(&quot;09_IOAndProperties\\c.txt,true&quot;);
        for(int i = 1;i&lt;=10;i++){
            fos.write(&quot;你好&quot;.getBytes());
            fos.write(&quot;\r\n&quot;.getBytes());
        }
        fos.close();
    }
}</code></pre>
<h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p>Java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。他定义了字节输入流的基本共性功能方法。</p>
<pre><code class="java">/*
    Java.io.InputStream:字节输入流
    此抽象类是表示字节输入流的所有类的超类。

    定义了所有子类共性的方法：
        int read()从输入流中读取数据的下一个字节。
        int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
        void close()关闭此输入流并释放与该流关联的所有系统资源。
    Java.io.FileInputStream extends InputStream
    FileInputStream:文件字节输入流
    作用：把硬盘文件中的数据。读取到内存中使用

    构造方法:
        FileInputStream(String name)
        FileInputStream(File file)
        参数：读取文件的数据源
            String name：文件的路径
            File file：文件
        构造方法的使用：
            1.会创建一个FileInputStream对象
            2.会把FileInputStream对象指定构造方法中要读取的文件


*/</code></pre>
<h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><p>读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1。</p>
<pre><code class="java">/*
读取数据的原理(硬盘--&gt;内存)
    java程序--&gt;JVM--&gt;OS--&gt;OS读取数据的方法--&gt;读取文件

字节输入流的使用步骤(重点)
    1.创建FileInputStream对象，构造方法中绑定要读取的数据源
    2.使用FileInputStream对象中的方法read，读取文件
    3.释放资源
*/

public class Demo01InputStream{
    public static void main(String[] args){
        //创建FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream(&quot;09_IOAndProperties\\a.txt&quot;);
        //使用FileInputStream对象中的方法read，读取文件
        //int read()读取文件中的一个字节并返回，读取到文件的末尾返回-1。
        int len = fis.read();
        System.out.println(len);//97  a

        len = fis.read();
        System.out.println(len);//98  b

        len = fis.read();
        System.out.println(len);//99  c

        len = fis.read();
        System.out.println(len);//  -1

        len = fis.read();
        System.out.println(len);//  -1


        /*
        读取文件是一个重复的过程，所以可以用循环优化
        while循环结束条件，读取到-1的时候结束

        */


        int len =0;//记录读取到的字节
        while((len = fis.read())!= -1){
            System.out.println((char)len);//abc
        }



        //释放资源
        fis.close();
    }

}</code></pre>
<p><strong>文件读取一个字节原理</strong></p>
<p><a href="https://www.wailian.work/image/QmMdKc" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200923_081602.png" alt="sp200923_081602.png"></a></p>
<h3 id="字节输入流一次读取多个字节"><a href="#字节输入流一次读取多个字节" class="headerlink" title="字节输入流一次读取多个字节"></a>字节输入流一次读取多个字节</h3><pre><code class="java">/*
字节输入流一次读取多个字节的方法:
    int read(byte[] b)从输入流中读取一定数量的字符，并将其存储在缓冲区数组b中。
明确两件事情：
    1.方法的参数byte[] 的作用?
    起到缓冲作用，存储每次读取到的多个字节
    数组的长度一般定义为1024(1KB)或者1024的整数倍
    2.方法的返回值int 是什么?
    每次读取的有效字节个数    
String类的构造方法
    String(byte[] bytes):把字节数组转换为字符串
    String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 
        offset:数组的开始索引
        length:转换的字节个数

*/
public class Demo02InputStream{
    public static void main(String[] args){
        //创建FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream(&quot;09_IOAndProperties\\b.txt&quot;);
        //使用FileInputStream对象的方法read读取文件
        //int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组  b 中。
        byte[] bytes = new byte[2];
        int len = fis.read(bytes);
        System.out.println(len);//2
        System.out.println(Array.toString(bytes));//[65, 66]
        System.out.println(new String(bytes));//AB

        len = fis.read(bytes);
        System.out.println(len);//2
        System.out.println(new String(bytes));//CD

        len = fis.read(bytes);
        System.out.println(len);//1
        System.out.println(new String(bytes));//ED

        len = fis.read(bytes);
        System.out.println(len);//-1
        System.out.println(new String(bytes));//ED


        /*
        读取也是一个重复的过程，可以使用循环优化
        用while循环
        while循环结束的条件，读取到-1结束 
        */

        byte[] bytes = new byte[1024];//存储读到的多个字节
        int len = 0;//记录每次读取的有效字节个数
        while((len = fis.read(bytes))!=-1){
            //String(byte[] bytes, int offset, int length)把字节数组的一部分转换为字符串
            offset:数组的开始索引
            length:转换的字节个数
         System.out.println(new String(bytes,0,len));
        }




        //释放资源
        fid.close();
    }
}</code></pre>
<p><strong>文件读取多个字节原理</strong></p>
<p><a href="https://www.wailian.work/image/QmMHOf" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200923_085831.png" alt="sp200923_085831.png"></a></p>
<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><p><a href="https://www.wailian.work/image/QmMni6" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200923_092941.png" alt="sp200923_092941.png"></a></p>
<pre><code class="java">/*
文件复制的练习：一读一写

明确：
    数据源：c\\1.jpg
    书救援的目的地: d\\1.jpg

文件复制的步骤：
    1.创建一个字节输入流对象，构造方法中绑定要读取的数据源
    2.创建一个字节输出流对象，构造方法中绑定要写入的目的地
    3.使用字节输入流对象中的方法read读取文件
    4.使用字节输出流中的方法write，把读取到的字节写入到目的地文件中
    5.释放资源
*/

public class Demo01CopyFile{
    public static void main(String[] args){
        //创建一个字节输入流对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream(&quot;c:\\1.jpg&quot;);
        //创建一个字节输出流对象，构造方法中绑定要写入的目的地
        FileOutputStream fos = new FileOutputStream(&quot;d:\\1.jpg&quot;);




        //第一种方法：使用字节输入流对象中的方法read读取文件
        int len = 0;
        while((len = fis.read())!=-1){
            //使用字节输出流中的方法write，把读取到的字节写入到目的地文件中
            fos.write(len);
        }

        //第二种方法：使用数组缓冲读取多个字节，写入多个字节
        byte[] bytes = new byte[1024];
        //使用字节输入流对象中的方法read读取文件
        int len = 0;//每次 读取的有效字节个数
        while(len = fis.read(bytes)!=-1){
            //使用字节输出流中的方法write，把读取到的字节写入到目的地文件中
            fos.write(bytes, 0,len);
        }




        //释放资源(先关闭写的，后关闭取的)
        fos.close();
        fis.close();

    }

}
</code></pre>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>当使用字节流读取文本文件时，可能会有一些问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能会占用多个字节存储。所以java提供了一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="字符输入流-Reader"><a href="#字符输入流-Reader" class="headerlink" title="字符输入流  [Reader]"></a>字符输入流  [Reader]</h3><p>java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。他定义了字符输入流的基本共性功能方法。</p>
<pre><code class="java">/*
java.io.Reader:字符输入流，是字符输入流的超类，定义了一些共性的成员方法，是一个抽象类

共性的成员方法：
    int read() 读取单个字符并返回。
    int read(char[] cbuf) 一次读取多个字符，将字符写入数组。
    void close() 关闭该流并释放与之关联的所有资源

java.io.FileReader extends InputStreamReader extends Reader

FileReader:文件字符输入流
作用:把硬盘文件中的数据以字符的方式读取到内存中

构造方法:
    FileReader(String fileName)
    FileReader(File file)
    参数:读取文件的数据源
        String fileName:文件的路径
        File file:一个文件
    fileReader构造方法的作用:
        1.创建一个FileReader对象
        2.会把FileReader对象指向要读取的文件

字符输入流的使用步骤:
    1.创建FileReader对象，构造方法中绑定要读取的数据源
    2.使用FileReader对象中的方法read读取文件
    3.释放资源

*/

public class Demo02Reader{
    public static void main(String[] args) throws IOException{
        //1.创建FileReader对象，构造方法中绑定要读取的数据源
        FileReader fr = new FileReader(&quot;09_IOAndProperties\\c.txt&quot;);
        //2.使用FileReader对象中的方法read读取文件
        //int read()读取单个字符并返回。
        int len = 0;
        while((len = fr.read())!=-1){
            System.out.println((char)len);
        }

        //int read(char[] cbuf)一次读取多个字符，将字符写入数组。
        char[] cs = new char[1024];//存储读取到的多个字符
        int len = 0;//记录的是每次读取的有效字符个数
        while((len = fr.read(cs))!=-1){
            /*
            String类的构造方法
            String(char[] value)把字符数组转换为字符串
            String(char[] value, int offset, int count)把字符数组的一部分转换为字符串

            */
            System.out.println(new String(cs, 0, len));


        }
        //3.释放资源
        fr.close();
    }
}</code></pre>
<h3 id="字符输出流-Writer"><a href="#字符输出流-Writer" class="headerlink" title="字符输出流 [Writer]"></a>字符输出流 [Writer]</h3><p>java.io.Write抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。他定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">/*
java.io.Writer:字符输出流，是所有字符输出流的最顶层的父类，是一个抽象类

共性的成员方法:
    void write(int c)  写入单个字符
    void write(char[] cbuf)  写入字符数组
    abstract void write(char[] cbuf, int off, int len)  写入字符数组的一部分，off数组的开始索引，len写的字符个数。
    void write(String str)写入字符串。
    void write(String str, int off, int len)  写入字符串的某一部分，off字符串的开始索引，len写的字符个数。
    void flush()  刷新该流的缓冲。
    void close()  关闭此流，但不要先刷新它


    java.io.FileWriter extends OutputStreamWrite extends Writer
    FileWrite:文件字符输出流
    作用:把内存中字符数据写到文件中

    构造方法:
        FileWrite(File file)根据给定的 File 对象构造出一个FileWrite 对象。
        FileWrite(String fileName) 根据给定的文件名构造一个FileWrite对象。
        参数:写入数据的目的地
            String fileName:文件的路径
            File file:是一个文件
        构造方法的作用:
            1.会创建一个FileWrite对象。
            2.会根据构造方法中传递的文件/文件的路径，创建文件
            3.会把FileWrite对象指向创建好的文件

    字符输出流的使用步骤:
        1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        2.使用FileWrite中的方法write，把数据写入到内存缓冲区中(字符转换为字节的过程)
        3.使用FileWriter中的方法flush，把内存缓冲区的数据，刷新到文件中。
        4.释放资源(会把内存缓冲区中的数据刷新到文件中)


*/

public class Demo01Writer{
    public static void main(String[] args){
        //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        FileWriter fw = new FileWriter(&quot;09_IOAndProperties\\d.txt&quot;);
        //使用FileWrite中的方法write，把数据写入到内存缓冲区中(字符转换为字节的过程)
        //void write(int c) 写入单个字符。
        fw.write(97);
        //3.使用FileWriter中的方法flush，把内存缓冲区的数据，刷新到文件中。
        fw.flush();
        //4.释放资源(会把内存缓冲区中的数据刷新到文件中)
        fw.close();

    }
}</code></pre>
<h3 id="关闭和刷新的区别"><a href="#关闭和刷新的区别" class="headerlink" title="关闭和刷新的区别"></a>关闭和刷新的区别</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush方法了</p>
<pre><code class="java">/*
flush和close方法的区别
    flush:刷新缓冲区，该对象可以继续使用
    close:先刷新缓冲区，然后再通知系统释放资源，流对象不能再使用了。
*/</code></pre>
<h3 id="字符输出流写数据的其他方法"><a href="#字符输出流写数据的其他方法" class="headerlink" title="字符输出流写数据的其他方法"></a>字符输出流写数据的其他方法</h3><pre><code class="java">    void write(char[] cbuf)写入字符数组
    abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分，off数组开始索引，len写的字符个数。
    void write(String str)写入字符串
    void write(String str, int off, int len)写入字符串的某一部分，off字符串的开始索引，len写的字符个数。</code></pre>
<h3 id="字符输出流的续写和换行"><a href="#字符输出流的续写和换行" class="headerlink" title="字符输出流的续写和换行"></a>字符输出流的续写和换行</h3><pre><code class="java">/*
续写和换行
续写,追加写:使用两个参数的构造方法
    FileWriter(String fileName, boolean append)
    FileWriter(File file, boolean append)
    参数:
        String fileName,file file:写入数据的目的地
        boolean append:续写开关 
            true:不会创建新的文件覆盖源文件，可以续写
            false:创建新的文件覆盖源文件
    换行:换行符号
        window:\r\n
        linux:/n
        mac:/r

*/</code></pre>
<h2 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h2><p>在实际开发中，不能直接把异常抛出，应该使用try….catch….finally代码块。</p>
<pre><code class="java">/*
在1.7之前使用 try..catch..finally处理流中的异常
格式：
    try{
        可能会产生异常的代码
    }catch(异常类变量 变量名){
        异常的处理逻辑
    }finally{
        一定会执行的代码
        资源释放
    }
*/

public class Demo01TryCatch{
    public static void main(String[] args){
        //提高变量fw的作用域，让finally可以使用
        //变量在定义的时候，可以没有值，但在使用的时候必须有值
        //fw = new FileWriter(&quot;09_IOAndProperties\\g.txt&quot;, true);执行失败，fw没有值，fw.close会报错
        FileWriter fw = null;
        try{
            //可能会产生异常的代码
            fw = new FileWriter(&quot;09_IOAndProperties\\g.txt&quot;,teue);
            for(int i = 0; i&lt;10 ;i++){
                fw.write(&quot;HelloWorld&quot;+i+&quot;\r\n&quot;);
            }

        }catch(IOException){
            //异常的处理逻辑
            System.out.println(e);
        }finally{
            //一定会执行的代码
            try{
                //fw.close方法声明抛出了IOException异常对象。
                fw.close(); 
            } catch(IOException e){
                e.printStackTrace();
            }

        }
    }
}</code></pre>
<p><strong>JDK1.7的新特性</strong></p>
<pre><code class="java">/*
JDK7新特性
在try的后面可以增加一个()，在括号中可以定义流对象
那么这个流对象的作用域就在try中有效
try中的代码执行完毕，会自动把流对象释放，不用写finally
格式：
    try(定义流对象.....){
    可能会产生异常的代码
    }catch(异常类变量 变量名){
        异常的处理逻辑
    }

*/</code></pre>
<p><strong>JDK9新特性</strong></p>
<pre><code class="java">/*
JDK9新特性
try的前面可以定义流对象
在try后面的()中可以直接引入流对象的名称(变量名)
在try代码执行完毕之后，流对象也可以释放掉，不用写finally
格式：
    A a = new A();
    B b = new B();
    try(a, b){
    可能会产生异常的代码
    }catch(异常类的变量 变量名){
        异常的处理逻辑
    }

*/</code></pre>
<h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><p>Properties类表示了一个持久的属性集。Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>
<pre><code class="java">/*
java.util.Properties集合 extends Hashtable&lt;k,v&gt; implement Map&lt;k,v&gt;

Properties类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
Properties集合是一个唯一和IO流结合的集合
    可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
    可以使用Properties集合中的方法load，把硬盘中保存的文件(键值对)，读取到集合中使用。

    属性列表中每个键及其对应值都是一个字符串。
        Properties集合时一个双列集合，key和value默认都是字符串。

*/


public class Demo01Properties{
    public static void main(String[] args){
        show01();
    }
    /*
    使用Properties集合存储数据。遍历取出Properties集合中的数据
    Properties集合是一个双列集合，key和value默认都是字符串
    Properties集合有一些操作字符串的特有方法
        Object setPropersites(String key, String value)调用Hashtable的方法 put。
        String getProperty(String key) 通过key找到value值，此方法相当于Map集合中的get(key)方法。
        Set&lt;String&gt; stringPropertyNames() 返回此属性列表的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的keySet方法

    */
    private static void show01(){    
        //创建Properties集合对象
        Properties prop = new Properties();
        //使用setProperty往集合中添加数据
        prop.setProperty(&quot;赵丽颖&quot;， &quot;168&quot;);
        prop.setProperty(&quot;迪丽热巴&quot;， &quot;165&quot;);
        prop.setProperty(&quot;古力娜扎&quot;， &quot;160&quot;);

        //使用stringPropertyNames把集合中的键取出,存储到一个Set集合中
        Set&lt;String&gt; set = prop.stringPropertyName();

        //遍历Set集合，取出Properties集合的每一个键
        for (String key : set){
            //使用getProperty方法通过key获取value
            string value = prop.getProperty(key);
            System.out.println(key+&quot;=&quot;+value);
        }

    }

}</code></pre>
<pre><code class="java">/*
可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
    void store(OutputStream out, String comments)
    void store(Writer writer, String comments)
    参数:
        OutputStream out:字节输出流，不能写入中文
        Writer write:字符输出流，可以写中文
        String comments:注释，用来解释说明保存的文件是做什么的，不能使用中文，会产生乱码，默认是Unicode编码，一般使用&quot;&quot;空字符串。

        使用步骤:
            1.创建一个Properties集合对象，添加数据。
            2.创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地
            3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入硬盘中存储。
            4.释放资源。

*/
public class Demo01Properties{
    public static void main(String[] args){
        show02();
}
    private static void show02(){
        //创建Properties集合对象
        Properties prop = new Properties();
        //使用setProperty往集合中添加数据
        prop.setProperty(&quot;赵丽颖&quot;， &quot;168&quot;);
        prop.setProperty(&quot;迪丽热巴&quot;， &quot;165&quot;);
        prop.setProperty(&quot;古力娜扎&quot;， &quot;160&quot;); 

        //创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地.
        FileWriter fw = new FileWriter(&quot;09_IOAndProperties\\prop.txt&quot;);
        //使用Properties集合中的方法store,把集合中的临时数据，持久化写入硬盘中存储
        prop.store(fw, &quot;save data&quot;);
        //释放资源
        fw.close();


    }

</code></pre>
<pre><code class="java">/*
可以使用Properties集合中的方法load，把硬盘中保存的文件(键值对)，读取到集合中使用。

*/</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_常用类</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/28/Javase-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类<a id="more"></a></h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><p>​        java.lang.Object 类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化时，最终找到的父类就是Object。</p>
<p>如果一个类没有特别指明父类，那么<strong>默认则继承自Object类</strong></p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><pre><code class="java">/*
    java.lang.Object类
    是类层结构的根类（最顶层）类，每个类都使用Object作为超（父）类。
    所有对象（包括数组）都实现这个类的方法。

*/

public class Demo01ToString{
    public static void main(String[] args){
        /*
        Person 类默认继承了Object类，所以可以使用Object类中的ToString方法
        String  toString()返回该对象的字符串表示。

        */
        Person p = new Person (&quot;张三&quot;，18);
        String s = p.toString ();
        System.out.println(s);

        //直接打印对象的名字，其实就是调用对象的toString方法           // p = p.toString();
        System.out.println(p);

}</code></pre>
<pre><code class="java">public class Person{
    public Person (String name ,int age){
        this.name = name;
        this.age = age;
    }
    /*
        直接打印对象的地址值没有意义，需重写Object类的toString方法
        直接打印对象的属性（name,age）
    */
   /* @override
    public String toString(){
        return &quot;Person {name = &quot;+name+&quot;,age = &quot;+age+&quot;}&quot;;
        */

    //     Alt + insert + toString快捷键

    }
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.anme = name;
    }
     public String getAge(){
        return Age;
    }
    public void setAge(String name){
        this.anme = Age;
    }


}</code></pre>
<p>看一个类是否重写了toString 方法，直接打印这个类对应对象的名字即可，如果没有重写toString方法，那么打印的就是对象的地址值（默认），如果重写toString方法，那么就按照重写的方式打印。</p>
<pre><code class="java">Random r = new Random();
System.out.println(r);   地址值

Scanner sc = new Scanner(System.in);
System.out.println(sc);   //重写toString方法

ArrayList&lt;Inneger&gt; list = new ArrayList&lt;&gt;();
list.add (1);
list.add (2);
System.out.println(list);//[1,2]重写toString方法</code></pre>
<h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h3><pre><code class="java">public class Demo02Equals{
    public static void main(String[] args){
        /*
            Person类继承了object类，所以可以用object类的equals方法
            boolean equals(Object obj)
            指示其他某个对象是否与此对象&quot;相等&quot;。


        Object类 equals方法源码：
            public boolean equals(Object obj){
                return (this == obj);
            }
            参数：
                Object obj ：可以传递任意的对象
            方法体：
            == :比较运算符，返回的就是一个布尔值 true,false
            基本数据类型：比较的是值
            引用数据类型：比较的是地址
          this：哪个对象调用的方法，方法中的this就是那个对象；p1调用的equals方法，所以this就是p1。
          obj：传递过来的参数p2。
        */

        Person p1 = new Person(name:&quot;迪丽热巴&quot;，age: 18);
        Person p2 = new Person(name:&quot;古力娜扎&quot;，age: 18);

        boolean b = p1.equals(p2);
        System.out.println(b);  //false
    }
}</code></pre>
<h3 id="重写Object类的equals方法"><a href="#重写Object类的equals方法" class="headerlink" title="重写Object类的equals方法"></a>重写Object类的equals方法</h3><p>​    Object类的equals方法默认比较的是两个对象的地址值，没有意义。所以我们需要重写equals方法，比较两个对象的属性值（name,age）对象的属性值一样好，返回true；否则返回false</p>
<p>问题：</p>
<p>​    隐含一个多态</p>
<p>​    Object  obj = p2 =new Person (“古力娜扎”，18)；</p>
<p>​    多态弊端：无法使用子类特有的内容（属性，方法）</p>
<p>​    解决：可以使用向下转型（强转）把Object类型转换为Person。</p>
<pre><code class="java">@override 
public boolean equals (Object obj){
    //增加一个判断，传递的参数obj是this本身，直接返回true
    if(obj == this ){
        return true;
    }
    //增加一个判断，传递的参数obj是null，直接返回false
    if(obj == null){
        return false;
    }
    /*
        增加一个判断，是Person类型再转换，防止类型转换异常classCastException
    */
    if(obj instanceof Person){
        //使用向下转型（强转）把Object类型转换为Person
    Person p = (Person)obj;
    //比较两个对象的属性：一个是调用方法的是this（p1），一个是p（obj = p2）
    this.name.equals(p.name)&amp;&amp; this.age == p.age;
        return b;
}
    //不是Person类型直接返回false
        return false;
    }
</code></pre>
<p>快捷键：Alt + Insert + equals（） and hashCode()</p>
<h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p>在JDK7添加了一个Object类，他提供一些方法来操作对象，他由一些静态的使用方法组成，这些方法是null-save（空指针安全）或null-tolerant（容忍空指针的），用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象。</p>
<ul>
<li>在比较两个对象时，Object类的equals方法容易抛出空指针异常，而Objects类中的equlas方法就优化了这个问题。</li>
</ul>
<pre><code class="java">public class Demo03objects{
    public static void main(String[] args){
        //String s1 = &quot;abc&quot;;
        String s1 = null;
        String S2 = &quot;abc&quot;;
        //boolean b = s1.equals(s2); //NullPointException   null是不能调用方法的，会抛出空指针异常
        //System.out.println(b);

        Objects的equals源码
        /*
            public static boolean equals(Object a,Object b){
            return (a==b)||(a!= null &amp;&amp; a.equals(b));
            }

        */
        boolean b2 = Object.equals(s1,s2);
        System.out.println(b2);
    }
}</code></pre>
<h3 id="Object类和Objects类总结"><a href="#Object类和Objects类总结" class="headerlink" title="Object类和Objects类总结"></a>Object类和Objects类总结</h3><ul>
<li><p>Object类介绍</p>
<ul>
<li>Object类是所有类的父类，一个类都会直接或间接的继承自该类</li>
<li>该类中提供了一些非常常用的方法。</li>
</ul>
</li>
<li><p>toString（）方法</p>
<ul>
<li>作用：打印对象的信息</li>
<li>重写前：打印的是包名类名@地址名</li>
<li>重写后：打印的是对象中的属性值</li>
</ul>
</li>
<li><p>equals </p>
<ul>
<li>作用：比较两个对象的</li>
<li>重写前：比较两个对象的地址值</li>
<li>重写后：比较两个对象的属性值</li>
</ul>
</li>
<li><p>Objects类</p>
<ul>
<li>equals（）方法<ul>
<li>比较两个对象是否相同，但是加了一些健壮性的判断。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时间跟日期"><a href="#时间跟日期" class="headerlink" title="时间跟日期"></a>时间跟日期</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.yntl.Date 类，表示特定的瞬间，精确到毫秒。</p>
<pre><code class="java">//毫秒值的作用：可以对时间和日期进行计算。
//将日期转换为毫秒，计算后，再将毫秒转换为日期
//1000毫秒 = 1秒
//时间原点：1970年1月1日00.00.00
public class DemoDate{
    public static void main(String[] args){
        System.out.println(System.currentTimeMillis());
        //获取当前系统时间到时间原点经历了多少毫秒。
    }

}</code></pre>
<pre><code class="java">public class Demo02Date{
    public static void main(String[] args){
        demo01();
        demo02();
    }
    /*
    Demo01:
    Date类的空参数构造方法：
        Date() 获取的就是当前系统的日期和时间

    Demo02:
    Date类的带参数构造方法：
        Date(long date):传递毫秒值，把毫秒转换为Date日期

    Demo03:
    Date类的成员方法：
    long getTime()  把日期转换为毫秒 相当于System.currentTimeMillis()
        返回自1970年1月1日00：00：00 GMT 以来此Date对象表示的毫秒数。

    */
    private static void demo01(){
        Date date = new Date();
        System.out.println(date);
        //Sun Aug 08 15:25:00 CST 2088
    }


    private static void demo02(){
        Date d1 = new Date(0L);
        System.out.println(d1);
        //Thu Jan 01 08:00:00 CST 1970
    }

    private static void demo03(){
        Date date = new Date();
        long time = date.getTime();
        System.out.println(time);//3556589625

    }
}
</code></pre>
<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>​        java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换，也就是Date对象和String 对象之间进行来回转换。</p>
<ul>
<li>格式化：按照指定的格式，从Date对象转换为String对象</li>
<li>解析：按照制定的格式，从String对象转换为Date对象</li>
</ul>
<pre><code class="java">/*
    java.text.DateFormat:是时间日期格式化子类的抽象类
    作用：格式化    解析  
    成员方法：
        String format(Date date) 按照指定的模式，把Date日期，格式化为符合模式的字符串。
        Date parse(String source)把符合模式的字符串，解析为Date日期。
    DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat的子类
    java.text.SimpleDateFormat extends DateFormat
    构造方法：
        SimpleDateFormat(String pattern)用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat
        参数：
            String pattern:传递指定的模式
        模式：区分大小写。
        Y    年
        M    月
        d    日
        H    时
        m    分
        s    秒
    写对应的格式，会把模式替换为对应的日期和时间
    &quot;YYYY-MM-dd HH:mm:ss&quot;
    &quot;YYYY年MM月dd日 HH时mm分ss秒&quot;
  注意：模式中的字母不能更改，但是连接符可以改变

*/
public class Demo01DateFormat{
    public static void main(String[] args){
        demo01();
    }
    /*
    demo01：
    使用DateFormat类中的format，把日期格式化为文本
    String format(Date date)  按照指定的模式，把Date日期，格式化为符合模式的字符串
    使用步骤：
        1.创建SimpDateFormat对象，构造方法中传递指定的模式
        2.调用SimpDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串（文本）

    demo02：
    使用DateFOrmat类中的方法，把文本解析为日期
    Date parse(String source)把符合模式的字符串解析为日期
    使用步骤：
        1.创建SimpleDateFormat对象，构造方法中传递指定的模式
        2.调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期。
    注意：
        parse方法声明了一个异常（ParseException）解析异常
        如果字符串和构造方法中的模式不一样，那么程序就会抛出此异常。
        要么throws继续声明抛出异常，要么try   catch自己处理这个异常。
    */

    private static void demo01(){
     //1.创建SimpDateFormat对象，构造方法中传递指定的模式
        SimpDateFormat sdf = new SimpDateFormat(YYYY年MM月dd日 HH时mm分ss秒);
     //2.调用SimpDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串（文本）
        Date date = new Date();
        String text = sdf.format(date);
        System.out.println(date);
        //Sun Aug 08 17:00:34 CST 2088
        System.out.println(text);
        //2088年08月08日17时00分10秒       
    }


    private static void demo02(){
        //1.创建SimpDateFormat对象，构造方法中传递指定的模式
        SimpDateFormat sdf = new SimpDateFormat(YYYY年MM月dd日 HH时mm分ss秒);
        //2.调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期。
        Date date = sdf.parse(2088年08月08日17时00分10秒);
        System.out.println(date);
    }

}</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用日期和时间相关的API，计算出一个人已经出生了多少天</p>
<p>思路：</p>
<ul>
<li>获取当前时间对应的毫秒值</li>
<li>获取自己出生日期对应的毫秒值</li>
<li>两个时间相见（当前日期-出生日期）</li>
</ul>
<pre><code class="java">/*
    分析：
    1.使用Scanner类中的方法next，获取出生值
    2.使用DateFormat中的方法parse，把字符串的出生日期解析为Date格式
    3.把Date格式的出生日期转换为毫秒值
    4.获取当前的日期，转换为毫秒值
    5.使用当前日期的毫秒值-出生日期的毫秒值
    6.把毫秒值的差值转换为天(s/1000/60/60/24)
*/

public class Demo02Test{
    public static void main(String[] args){
     //1.使用Scanner类中的方法next，获取出生值
     Scanner sc = new Scanner(System.in);
     System.out.println(&quot;请输入您的出生日期，格式为yyyy-MM-dd&quot;);
     String birthdayDateString = sc.next();
     //2.使用DateFormat中的方法parse，把字符串的出生日期解析为Date格式
        SimpleDateFormat sdf = new SimpleDateFormat(yyyy-MM-dd);
        Date birthdayDate = sdf.parse(birthdayDateString);
     //3.把Date格式的出生日期转换为毫秒值  
        long Date birthdayDate = birthdayDate.getTime();
      //4.获取当前的日期，转换为毫秒值
      long todayTime = new Date().getTime();
      //5.使用当前日期的毫秒值-出生日期的毫秒值
      long time = todayTime-birthdayDateTime;
      //6.把毫秒值的差值转换为天(s/1000/60/60/24)
      System.out.println(time/1000/60/60/24);
    }
}</code></pre>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><pre><code class="java">/*
    java.util.Calendar类：日历类
    Calendar类是一个抽象类，里边提供了很多操作日历的方法(YEAR MOUTH,DAY_OF_MOUTH,HOUR)
    Calendar类无法直接创建对象使用，里边有个静态方法叫getInstance(),该方法返回了Calendar类的子类对象。
    static Calendar getInstance() 使用默认时区和语言环境获得一个日历。
*/


public class Demo01Calendar{
    public static void main(String[] args){
        Calendar c = Calendar.getInstance();//多态
        System.out.println(c);
    }
}</code></pre>
<p><strong>常用方法</strong></p>
<ul>
<li>public int get (int field):    返回给定日历字段的值</li>
<li>public void set (int field,int value): 将给定的日历字段设置为定值。</li>
<li>public abstract void add(int field,int amount): 根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>public Date getTime():返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。  </li>
</ul>
<pre><code class="java">/*
    Calendar类的成员方法：
        public int get (int field):    返回给定日历字段的值
        public void set (int field,int value): 将给定的日历字段设置为定值。
        public abstract void add(int field,int amount): 根据日历的规则，为给定的日历字段添加或减去指定的时间量。
        public Date getTime():返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。  
    成员方法的参数：
        int field :日历类的字段，可以使用Calendar类的静态变量获取。

*/


public class Demo02Calendar{
    public static void main(String[] args){
        demo01();
        demo02();
    }


    /*
        Demo01:
        public int get(int field):返回给定日历字段的值
        参数：传递指定的日历字段（YEAR MOUTH...）
        返回值：日历字段代表具体的值


        Demo02:
        public void set (int field,int value): 将给定的日历字段设置为定值。
        参数：
            int field:传递指定的日历字段(YEAR,MOUTH)
            int value:传递的字段设置的具体值

        Demo03:
        public abstract void add(int field,int amount): 根据日历的规则，为给定的日历字段添加或减去指定的时间量。
        参数：
            int field:传递指定的日历字段(YEAR,MOUTH)
            int amount:增加/减少的值
                正数：增加
                负数：减少

        Demo04:
            public Date getTime():返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。
            日历对象转换为日期对象

    */
    private static void demo01(){
        //使用getInstance方法获取Calendar对象
        Calendar c = Calendar.getInstance();
        int year = c.get(Calendar.YEAR);
        System.out.println(year);

        int mouth = c.get(Calendar.MOUTH);
        Syatem.out.println(mouth+1);

        int date = c.get(Calendar.DATE);
        System.out.println(date);
        /*
        2088
        8
        8
        */
    }


    private static void demo02(){
        //使用getInstance方法获取Calendar对象
        Calendar c = Calendar.getInstance();

        //设置年为9999
        c.set(Calendar.YEAR,9999);
        //设置月为9
        c.set(Calendar.MONTH,9);
        //同时设置
        c.set(8888,8,8);

        int year = c.get(Calendar.YEAR);
        System.out.println(year);

        int mouth = c.get(Calendar.MOUTH);
        Syatem.out.println(mouth+1);

        int date = c.get(Calendar.DATE);
        System.out.println(date);

    }


    private static void demo03(){
        //使用getInstance方法获取Calendar对象
        Calendar c = Calendar.getInstance();

        //年增加两年
        c.add(Calendar.YEAR,2);

        int year = c.get(Calendar.YEAR);
        System.out.println(year);
    }


    private static void demo04(){
        //使用getInstance方法获取Calendar对象
        Calendar c = Calendar.getInstance();
        Date date = c.getTime();
        System.out.println(date);
    }

}</code></pre>
<h3 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h3><ul>
<li><strong>Date类</strong><ul>
<li>构造方法<ul>
<li>Date（）:   根据当前系统时间创建日期对象</li>
<li>Date（long time）:根据传入的毫秒值时间创建日期对象。</li>
</ul>
</li>
<li>成员方法<ul>
<li>long getTime（）:获取当前日期对象的毫秒值时间</li>
<li>String toLocaleString（）:根据本地格式转换日期对象</li>
</ul>
</li>
</ul>
</li>
<li><strong>DateFormat类或SimpleDateFormat类</strong><ul>
<li>构造方法<ul>
<li>SImpleDateFormat(String s):根据指定模板创建日期格式化对象。</li>
</ul>
</li>
<li>成员方法<ul>
<li>String format （Date d）:根据指定格式格式化日期对象</li>
<li>Date parse (String  s )：根据指定格式解析字符串。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Calendar</strong><ul>
<li>创建对象方式</li>
</ul>
</li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>​        java.lang.System类中提供了大量的静态方法，可以获取与系统相关信息或系统及操作，在System类的API文档中。</p>
<ul>
<li>public static long currentTimeMills（）：返回以毫米为单位的当前时间。</li>
<li>public static void arraycopy（Object src ,int srcPos,Object dest,int destPos,int length）:将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p><strong>public static long currentTimeMills（）</strong></p>
<p>验证for循环打印数字1~9999所需要的时间（毫秒）</p>
<pre><code class="java">public class SystemTest{
    public  static void main(String[] args){
        long start = System.currentTimeMillis();
        for (int i = 0;i &lt;10000; i++){
            System.out.println(i);
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));
    }

}</code></pre>
<p><strong>public static void arraycopy（Object src ,int srcPos,Object dest,int destPos,int length）</strong></p>
<pre><code class="java">public class Demmo01System{
    public static void main(String[] args){
        demo02();
    }

    /*
        public ststic void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);
        将数组中指定的数据拷贝到另一个数组中。
        参数：
            src  源数组
            srcPos  源数组中的起始位置
            dest  目标数组
            destPos  目标数据中的起始位置
            length  要复制的数组元素的数量   
    */
}</code></pre>
<pre><code class="java">/*
练习：
    将src数组的前三个元素，复制到dest数组的前三个位置上
    复制元素前：src数组元素[1,2,3,4,5],dest数组元素[6,7,8,9,10]
    复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]
*/

private static void demo02(){
    //定义源数组
    int [] src = {1,2,3,4,5};
    //定义目标数组
    int [] dest = {6,7,8,9,10};
     System.out.println(&quot;复制前:&quot;+ Arrays.toString(dest));
    //使用System类的方法arrayscopy将src数组中前三个元素，复制到dest数组的前三个位置上
    System.arraycopy(src,0,dest,0,3);
    System.out.println(&quot;复制后&quot;+Arrays.tostring(dest));
    }
}
</code></pre>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><h3 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h3><p>由于String类的对象内容不可改变时，所以每当进行字符串拼接时，总会在内存中创建一个新的对象。例如：</p>
<pre><code class="java">public class StringDemo{
    public static void main(String[] args){
        String s = &quot;Hello&quot;;
        s +=&quot;World&quot;;
        System.out.println(s);
    }
}</code></pre>
<p>在API中对String类有这样的描述：<strong>字符串是常量(被final修饰的数组)</strong>，他们的值在创建后不可能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即“hello”,”World”,”hello World”。根据变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWorld。</p>
<p><strong>String类和StringBuilder类的区别</strong></p>
<p>String类</p>
<ul>
<li>字符串是常量，他们的值在创建之后不能修改</li>
<li>字符串的底层是一个被final修饰的数组，不能改变，是一个常量</li>
</ul>
<blockquote>
<p>private final byte [] value</p>
</blockquote>
<ul>
<li>进行字符串的相加，内存就会多出两个字符串，占用空间多，效率低下</li>
</ul>
<p>StringBuilder类</p>
<ul>
<li>字符串缓冲区，可以提高字符串的操作效率</li>
<li>底层也是一个数组，但是没有被final修饰，可以改变长度。</li>
</ul>
<blockquote>
<p>byte[] value = new byte[16];</p>
</blockquote>
<ul>
<li>StringBuilder在内存中，始终是一个数组，占用空间少，效率高，如果超出了StringBuilder的容量，会自动扩容。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>public  StringBuilder():构造一个空的StringBuilder容器。</li>
<li>public  StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<pre><code class="java">public class StringBuilderDemo{
    public static void main(String[] args){
        StringBuilder sb1 = new StringBuilder();
        System.out.println(sb1);  //空白
        //使用带参构造
        StringBuilder sb2 = new StringBuilder(&quot;itcast&quot;);
        System.out.println(sb2);
        //itcast
    }
}</code></pre>
<pre><code class="java">/*
    java.lang.StringBuilder类：字符缓冲区，可以而提高字符串的效率。
    构造方法：
    public  StringBuilder():构造一个空的StringBuilder容器。
    public  StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去。
*/


public class Demo01StringBuilder{
    public static void main(String[] args){
       StringBUilder bu1 = new StringBuilder();
        System.out.println(&quot;bu1:&quot;+bu1);//bu1:  

        StringBuilder bu2 = new StringBuilder(&quot;abc&quot;);
        System.out.println(&quot;bu2:&quot;+bu2);//bu2:abc
    }
}</code></pre>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code class="java">public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象本身。


public String toString():将当前StringBuilder对象转换为String对象。</code></pre>
<p><strong>append方法</strong></p>
<pre><code class="java">/*
    StringBuilder类的成员方法
    public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象本身。
    参数：
        可以是任意的数据类型。

*/
public class Demo02StringBuilder{
    public static void main(String[] args){
        //创建StringBuilder对象
         StringBuilder bu1 = new StringBuilder();
        //使用append方法，往StringBuilder方法中添加数据。
        StringBuilder bu2 = bu1.append(&quot;abc&quot;);
        System.out.println(bu1);//abc
        System.out.println(bu2);//abc
        //地址相同，是同一个对象。


        //使用append方法无需接受返回值。
        bu1.append(&quot;abc&quot;);
        bu1.append(&quot;1&quot;);
        bu1.append(true);
        bu1.append(8.8);
        bu1.append(&#39;中&#39;)；
        System.out.println(bu1);//abc1ture8.8中

        /*
       链式方程：方法的返回值是一个对象，可以根据对象继续调用方法。 
        */
                      bu1.append(&quot;abc&quot;).append(1).append(true).append(8.5).append(&#39;中&#39;);
        System.out.println(bu1);//abc1ture8.8中

    }
}</code></pre>
<ul>
<li>toString方法</li>
</ul>
<pre><code class="java">/*
StringBuilder和String可以互相转换：
String--&gt;StringBuilder:
    可以使用StringBuilder的构造方法
        StringBuilder(String str)构造一个字符串生成器，并初始化为指定的字符串内容。

StringBuilder--&gt;String:
可以使用StringBuilder中的toString方法
    public String toString():将当前StringBuilder对象转换为String对象。

*/
public class Demo03StringBuilder{
    public static void main(String[] args){
        //String--&gt;StringBuilder
        String str = &quot;Hello&quot;;
        System.out.println(&quot;str: &quot;+str);
        StringBuilder bu = new StringBuilder(str);
        //往StringBuilder中添加数据
        bu.append(&quot;World&quot;);
        System.out.println(&quot;bu:&quot;+bu);

        //StringBuilder--&gt;String
        String s = bu.toString();
        System.out.println(&quot;s:&quot;+s);
    }
}
</code></pre>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型的数据，使用起来非常方便，但是没有对应的方法来操作这些数据，所以我们可以使用一个类，把基本类型的数据包装起来，这个叫包装类，在包装类中可以定义一些方法，用来操作基本类型的数据。</p>
<pre><code class="java">byte        Byte
short        Short
int            Integer
long        Long
float        Float
double        Double
char        Character
boolean        Boolean</code></pre>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为“装箱”与“拆箱”。</p>
<ul>
<li>装箱：从基本类型转换为包装类对象</li>
<li>拆箱：从包装类对象转换为对应的基本类型。</li>
</ul>
<p>基本数值—&gt;包装对象</p>
<pre><code class="java">Integer i = new Integer(4);//使用构造函数函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法</code></pre>
<p>包装对象—&gt;基本数值</p>
<pre><code class="java">int num = i.intValue();</code></pre>
<pre><code class="java">/*
    装箱：把基本类型的数据，包装到包装类中(基本类型的数据--&gt;保包装类)

    构造方法：
        Integer(int value) 构造一个新分配的Integer对象，它表示指定的 int值
        Integer(String s) 构造一个新分配的Integer对象，他表示String参数所指示的int值。
        传递的字符串，必须是基本类型的字符串，否则会抛出异常&quot;100&quot;正确&quot;a&quot;抛异常。

    静态方法：
        static Integer valueOf(int i)返回一个表示指定的int值的Integer实例。
        static Integer valueOf(String s)返回保存指定的String的值得Integer对象。
    拆箱：在包装类中取出基本类型的数据(包装类--&gt;基本类型的数据)
    成员方法：
        int intValue()以int类型返回该Integer的值。

*/
public class Demo01Integer{
    public static void main(String[] args){
    //装箱
        Integer in1 = new Integer(1);
        System.out.println(in1);//重写了toString方法

        Integer in2 = new Integer(&quot;1&quot;);
        System.out.println(in2);//1

        //静态方法
        Integer in3 = Inegter.valueOf(1);
        System.out.println(in3);

        //Integer in4 = Integer.valueOf(&quot;a&quot;);
        //NumberFormatException数字格式化异常
        Inegter in4 = Inegter.valueOf(&quot;1&quot;);
        System.out..println(in4);

    //拆箱
        int i = in1.intValue();
        System.out.println(i);
    }
}</code></pre>
<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>基本类型的数据和包装类之间可以自动的相互转换</p>
<pre><code class="java">public class Demo02Integer{
    public static void main(String[] args){
        /*
            自动装箱：直接把int类型的整数赋值给包装类

        */
        Integer in = 1;

        /*
        自动拆箱：in是包装类，无法直接参与运算，可以自动转换为基本类型的数据，在参与计算。
        in + 2;就相当于in.intValue() + 3 = 3;
        in = in + 2;就相当于 in = new Integer(3);自动装箱

        */
        in = in + 2 ;
        System.out.println(in);

        //ArrayLIst集合无法直接存储整数，可以存储包装类
        Arraylist&lt;Integer&gt; list = new ArrayList&lt;&gt;();

        list.add(1);//自动装箱  list.add(new Integer(1));

        int a = list..get(0);//自动装箱list.get(0).intValue();

    }
}</code></pre>
<h3 id="基本类型和字符串之间的转换"><a href="#基本类型和字符串之间的转换" class="headerlink" title="基本类型和字符串之间的转换"></a>基本类型和字符串之间的转换</h3><p><strong>基本类型转换为String</strong></p>
<p>基本类型转换String总共有三种方式</p>
<ul>
<li>基本类型直接与“”相连即可。如：34+“”</li>
<li>使用包装类中的静态方法</li>
</ul>
<p>static String toString(int  i)返回一个表示指定整数的String对象</p>
<ul>
<li>使用String类中的静态方法</li>
</ul>
<p>static  String  valueOf(int  i)返回int参数的字符串表示形式</p>
<p><strong>String转换为对应的基本类型</strong></p>
<p>除了Character类之外，其他所有包装类都具有parseXXX静态方法可以将字符串参数转换为对应的基本类型</p>
<ul>
<li>public   static    byte    parseByte(String s):将字符串参数转换为对应的byte基本类型</li>
<li>public   static    short    parseShort(String s):将字符串参数转换为对应的short基本类型</li>
<li>public   static    int    parseInt(String s):将字符串参数转换为对应的int基本类型</li>
<li>public   static    long    parseLong(String s):将字符串参数转换为对应的long基本类型</li>
<li>public   static    float    parseFloat(String s):将字符串参数转换为对应的float基本类型</li>
<li>public   static    double    parseDouble(String s):将字符串参数转换为对应的double基本类型</li>
<li>public   static    boolean    parseBoolean(String s):将字符串参数转换为对应的boolean基本类型</li>
</ul>
<p><strong>代码使用：</strong></p>
<pre><code class="java">/*
    基本类型--&gt;字符串
    三种方法
*/
public class Demo03Integer{
    public static void main(String[] args){
        String s1 = 100 + &quot;&quot;;
        System.out.println(s1 + 200);


        String s2 = Integer.toString(100);
        System.out.println(s2 + 200);

        String s3 = String.valueOf(100);
        System.out.println(s3 + 200);
    }
}</code></pre>
<pre><code class="java">/*
字符串--&gt;基本类型

*/
public class Demo03Integer{
    public static void main(String[] args){
        int i = Integer.parseInt(&quot;100&quot;);
        System.out.println(i+200);
    }
}</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_异常</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/27/Javase-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制<a id="more"></a></h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><ul>
<li>实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求，你的程序要打开某个软件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。</li>
<li>软件程序运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫<strong>异常</strong>，英文是<strong>Exception</strong>，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</li>
<li>异常指程序运行中出现的不期而至的各种情况，如：文件找不到，网络连接失败，非法参数等。</li>
<li>异常发生在程序运行期间，他影响了正常的程序执行流程。</li>
</ul>
<pre><code class="java">//死循环，错误
public class Demo01{
    public static void main(String[] args){
        new Demo01().a();
    }
    public void a(){
        b();
    }
    public void b(){
        a();
    }
}</code></pre>
<pre><code class="java">//异常
public class Demo01(){
    public static void main(String[] args){
        System.out.println(11/0);
    }
}</code></pre>
<h2 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h2><ul>
<li>要理解Java异常处理是如何工作的，你需要掌握以下<strong>三种类型的异常</strong>：<ul>
<li><strong>检查型异常</strong>：最具的代表性异常就是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常</strong>：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误</strong>：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如,当栈溢出时，一个错误就发生了，他们在编译也检查不到的</li>
</ul>
</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><ul>
<li>Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。</li>
<li>在Java API中已经定义了许多异常类，这些异常类分为两大类，<strong>错误Error</strong>和<strong>异常Exception</strong></li>
</ul>
<p><a href="https://www.wailian.work/image/QmvyJG" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/12/sp200827_200438.png" alt="sp200827_200438.png"></a></p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError），链接错误（LinkageError）.这些错误是不可查的，因为他们在应用程序的控制和处理能力之外，而且绝大多数使程序运行时不允许出现的状况。</li>
</ul>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul>
<li>在Exception分支中有一个重要的子类RuntimeException（运行时异常）<ul>
<li>ArraylndexOutOfBoundsException(数组下标越界)</li>
<li>NullPointerExcep（空指针异常）</li>
<li>ArithmeticException(算数异常)</li>
<li>MissingResourceException(丢失资源)</li>
<li>ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
<li><strong>Error和Exception的区别</strong>：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能地去处理这些异常。</li>
</ul>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理的五个关键字:try ,catch,finally,throw,throws</li>
</ul>
<pre><code class="java">public class Test{
   public static void main(String[] args){

       int a = 1;
       int b = 0;    

       try{
           //try监控区域
           System.out.println(a/b);
       }catch {ArithmeticException e}{//catch  想要捕获的异常类型
               System.out.println(&quot;程序出现异常，变量b不能为0&quot;);
       }finally {//处理善后工作
           System.out.println(&quot;finally&quot;);
       }

       //finally可以不用，无论有没有异常都会执行
   } 
}</code></pre>
<ul>
<li>可以连续捕获异常，但范围要逐渐变大。捕获到异常后，后面的不再执行。</li>
<li>快捷键   Ctrl   Alt  +  T</li>
</ul>
<pre><code class="java">public static void main(String[] args){
    int a = 1;
    int b = 0;
    public void test(int a,int b) throws ArithemticExceotion{
      if(b == 0){
            throw new ArithmeticException();
            //主动抛出异常，一般在方法中使用  
    }
    }
}</code></pre>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常，用户自定义异常类，只需继承<strong>Exception</strong>类即可</li>
<li>使用自定义异常类步骤<ul>
<li>创建自定义异常类</li>
<li>在方法中通过 throw关键字抛出异常对象</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处可通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调查者中捕获并处理异常。</li>
</ul>
</li>
</ul>
<pre><code class="java">//自定义异常
public class MyException extends Exception{
    //传递数字&gt;10;
    private int detail;
    public MyException(int a){
        this.detail = a;
    }
    //toString:异常的打印信息
    @override
    public String toString(){
        return &quot;MyException{&quot; + &quot;detail=&quot; + detail +
    &#39;}&#39;;
    }
}</code></pre>
<pre><code class="java">public class Test{
    //可能会存在的异常的方法
    static void test (int a) throws MyException{
        System.out.println(&quot;传递的参数为：&quot; + a);

        if(a&gt;10){
            throw new MyException(a);//抛出
        }
        System.out.println(&quot;ok&quot;);
    }


    public static void main (String[] args){
        try{
            test(a);
        } catch(MyException e){
            System.out.println(&quot;MyException=&gt;&quot;+e);
        }
    }
}</code></pre>
<h3 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h3><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</li>
<li>在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常</li>
<li>对于不确定的代码，也可以加try-catch，处理潜在的异常</li>
<li>尽量去处理异常，切忌只是简单的调用printStackTrace（）去打印输出。</li>
<li>具体如何处理异常，要根据不同业务需求和异常类型去决定‘</li>
<li>尽量添加finally语句块去释放占用的资源。</li>
</ul>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_数组</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/21/Javase-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组<a id="more"></a></h1><h2 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h2><ul>
<li>数组是相同类型数据的有序集合</li>
<li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成</li>
<li>每一个数据称做一个数组元素，每个数组元素可以通过一个下标来访问他们。</li>
</ul>
<h2 id="数组的声明和创建"><a href="#数组的声明和创建" class="headerlink" title="数组的声明和创建"></a>数组的声明和创建</h2><ul>
<li>首先必须声明数组变量，才能在程序中使用数组，下面是声明数组变量的语法</li>
</ul>
<pre><code class="java">dataType[] arrayRefVar    //首选的方法
    或
dataType arrayRefVar[]        //效果相同，但不是首选方法</code></pre>
<ul>
<li>Java语言使用new操作符来创建数组，语法如下</li>
</ul>
<pre><code class="java">dataType[] arrayRefVar = new dataType[arraySize];</code></pre>
<ul>
<li>数组的元素是通过索引访问的，数组索引从0开始。</li>
<li>获取数组长度   arrays.lengh</li>
</ul>
<pre><code class="java">public class ArrayDemo01{
    //变量的类型   变量的名字  =  变量的值
    //数组类型
    public static void main (String [] args){
        int[] nums;    //定义两种都可
        int nums2[];
        nums = new int[10];    //这里可以存放10个int类型的数字

        //给数组元素赋值
        num[0] = 1;
        num[1] = 2;
        num[2] = 3;
        num[3] = 4;
        num[4] = 5;
        num[5] = 6;
        num[6] = 7;
        num[7] = 8;
        num[8] = 9;
        num[9] = 10;

        //计算所有元素的和
        int sum = 0;
        for (int i = 0; i&lt;nums.length ;i++){
            sum = sum + nums[i];
        }
        System.out.println(&quot;总和为：&quot;+sum);
    }

}</code></pre>
<h2 id="三种初始化及内存分析"><a href="#三种初始化及内存分析" class="headerlink" title="三种初始化及内存分析"></a>三种初始化及内存分析</h2><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><ul>
<li>堆<ul>
<li>存放new的对象和数组</li>
<li>可以被所有线程共享，不会存放别的对象引用</li>
</ul>
</li>
<li>栈<ul>
<li>存放基础变量类型（会包含这个基础类型的具体数值）</li>
<li>引用对象的变量（会存放这个引用在堆里面的具体地址）</li>
</ul>
</li>
<li>方法区<ul>
<li>可以被所有线程共享</li>
<li>包含了所有的class和static变量</li>
</ul>
</li>
</ul>
<h3 id="三种初始化"><a href="#三种初始化" class="headerlink" title="三种初始化"></a>三种初始化</h3><ul>
<li>静态初始化</li>
</ul>
<pre><code class="java">int [] a = {1,2,3};
Man[] mans = {new Man(1,1),new Man(2,2)};</code></pre>
<ul>
<li>动态初始化</li>
</ul>
<pre><code class="java">int[] a = new int [2];
a[0] = 1;
a[1] = 2;</code></pre>
<ul>
<li>数组的默认初始化<ul>
<li>数组是引用类型，它的元素相当于类的实例变量，因此 数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</li>
</ul>
</li>
</ul>
<h2 id="下标越界及小结"><a href="#下标越界及小结" class="headerlink" title="下标越界及小结"></a>下标越界及小结</h2><h3 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h3><ul>
<li>其长度是固定的。数组一旦被创建，它的大小就是不可以改变的。</li>
<li>其元素必须是相同类型，不允许出现混合类型</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong>。</li>
</ul>
<h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><ul>
<li>下标的合法区间：[0，length-1]，如果越界就会报错</li>
</ul>
<pre><code class="java">public static void main(String[] args){
    int [] a =new int [2];
    System.out.println(a[2]);
}</code></pre>
<ul>
<li>ArrayindexOutOfBoundException:数组下标越界异常</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>数组是相同数据类型（数据类型可以为任意类型）的有序集合</li>
<li>数组也是对象。数组元素相当于对象的成员变量</li>
<li>数组长度是确定的，不可变的。如果越界，则报ArrayindexOutOfBounds</li>
</ul>
<h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><pre><code class="java">public static void main(String[] args){
    int array[] = {1,2,3,4,5};
    //打印全部的数组元素
    for(int i =0; i &lt; array.length ; i++ ){
        System.out.println(array[i]);
    }
    System.out.println(&quot;==============&quot;);

    //计算所有元素的和
    int sum = 0;
    for(int i = 0;i&lt;array.length;i++){
        sum +=array[i];
    }
    System.out.println(&quot;sum=&quot;+sum);
    System.out.println(&quot;==============&quot;);

    //查找最大元素
    int max = array[0];
    for (int i = 1; i&lt; array.length;i++){
        if (array[i]&gt;max){
            max = array[i];
        }
    }
    System.out.println(&quot;max=&quot;+max);
}</code></pre>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><pre><code class="java">public static void main(String[] args){
    int array[] = {1,2,3,4,5};
    for(int array : array){
         System.out.println(array[i]);   
    }</code></pre>
<h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><pre><code class="java">public static int [] reverse(int [] arrays){
    int [] result = new int [array.length];
    //反转的操作
    for(int i = 0,j = result.length-1;i&lt; array.length;i++,j--){
        result[j] = array[i];
    }
    return result;
}</code></pre>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成数组的数组，比如二维数组就是个特殊的一维数组，其每一个元素都是一个一维数组。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code class="java">int a[][] = new int[2][5];</code></pre>
<pre><code class="java">int[][] array = {{1,2},{2,3},{3,4}};
for(int i = 0;j &lt;array[i].length;j++){
    for (int j = 0;j&lt;array[i].length;j++){
        System.out.println(array[i][j]);
    }
}</code></pre>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul>
<li>数组的工具类java.util.Arrays</li>
<li>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</li>
<li>查看JDK帮助文档</li>
<li>Array类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而不用适用对象来调用。</li>
</ul>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul>
<li>给数组赋值：通过fill方法</li>
<li>对数组排序：通过sort方法，按升序。</li>
<li>比较数组：通过equals方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找操作。</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两层循环，外层冒泡轮数，里层依次比较，时间复杂度为O(n2)。</p>
<pre><code class="java">public cclass ArrayDemo{
   public static int main (String[] args){

   }

    //冒泡排序
    //1.比较数组中，相邻的元素，如果第一个数比第二个数大，我们就交换它们的位置
    //2.每一次比较，都会产生一个最大，或者最小的数字
    //3.下一轮则可以减少一次排序
    //4.依次循环直到结束。

    public static void sort(int [] array){
        //外层循环，判断我们这个要走多少次；
        for(int i = 0; i&lt;array.length-1; i++){

            boolean flag = false;//通过flag标志位减少没有意义的比较
            //内层循环，比较判断两个数，如果第一个数比第二个数大，则交换位置
            for(int j = 0;j&lt;array.length-1-i; j++){
                //第一个数和第二个数比较
                if(array[j+1]&gt;array[j]){

                    //如果第一个数大于第二个数，交换位置
                    temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                    flag = true;
                }
            }
            if(flag==false){
                break;
            }

        }
        return array;
    }


}

</code></pre>
<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>数据结构</p>
<p>为了解决二维数组中的很多值是默认值为0，因此记录了很多没有意义的数据。</p>
<p>解决办法：稀疏数组。</p>
<h3 id="稀疏数组介绍"><a href="#稀疏数组介绍" class="headerlink" title="稀疏数组介绍"></a>稀疏数组介绍</h3><ul>
<li>当一个数组中大部分元素为0，或者为同一个值的数组时，可以用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式是：<ul>
<li>记录数组一共有几行几列，有多少个不同值</li>
<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ul>
</li>
<li>如下图所示：左边为原始数组，右边为稀疏数组</li>
</ul>
<p><a href="https://www.wailian.work/image/Qmv35p" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/12/sp200822_222512.png" alt="sp200822_222512.png"></a></p>
<pre><code class="java">public class ArrayDemo{
    public static void main(String[] args){
        //1.创建一个二维数组 11*11    0：没有棋子  1：黑棋  2：白棋
        int[][] array1 = new int [11][11];
        array1[1][2] = 1;
        array1[2][3] = 2;
        //输出原始的数组
        System.out.println(&quot;输出原始的数组&quot;);

        for(int [] ints :array1){
            for(int anInt :ints){
                System.out.println(anInt+&quot;\t&quot;);
            }
            System.out.println();
        }
        //转换为稀疏数组保存
        //获取有效值的个数
        int sum = 0;
        for(int i = 0; i&lt;11; i++){
            for(int j =0;j&lt;11; j++){
              if(array1[i][j]!=0){
                  sum++;
              }  
            }
        }
        System.out.println(&quot;有效值的个数:&quot;+sum);

        //2.创建一个稀疏数组的数组
        int[][] array2 = new int[sum+1][3];
        array2[0][0] = 11;
        array2[0][1] = 11;
        array2[0][2] = sum;

        //遍历二维数组，将非零的值存放到稀疏数组。
        int count = 0;
        for(int i = 0;i&lt;array1.length; i++){
            for(int j =0; j&lt;array1.length;j++){
                if(array1[i][j]!=0){
                    count++;
                    array2[count][0] = i;
                    array2[count][1] = j;
                    array2[count][2] = array1[i][j];
                }
            }
        }
        //输出稀疏数组
        System.out.println(&quot;稀疏数组&quot;);

        for(int i = 0;i&lt;array2.length;i++){
            System.out.println(array2[i][0]+&quot;\t&quot;+array2[i][1]+&quot;\t&quot;+array2[i][2]+&quot;\t&quot;);
        }

        System.out.println(&quot;==================&quot;);
        System.out.println(&quot;还原&quot;)；
            //1.读取稀疏数组
            int[][] array3 = new int [array2[0][0]][array2[0][1]];
        //2.给其中的元素还原它的值
        for(int i = 1;i&lt;array2.length;i++){
            array3[array2[i][0]][array2[i][1]] = array2[i][2];
        }
        //3.打印
        System.out.println(&quot;输出还原的数组&quot;)；
            for(int [] ints:array1){
                for(int anInt: ints){
                    System.out.println(anInt+&quot;\t&quot;);
                }
                System.out.println();
            }
    }
}</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_方法</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/20/Javase-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法<a id="more"></a></h1><pre><code class="java">System.out.println()

    System   系统类
    out      对象
    println  方法</code></pre>
<p>方法即是功能块。一个方法完成一个功能，有利于后期的拓展。</p>
<p>命名规则：首字母小写，后用驼峰命名法。</p>
<pre><code class="java">public class Demo01{
    public static void main(String[] args){
     int sum = add(1,2);
     System.out println(sum);
    }
    //add就是方法
    public static int add(int a,int b){
        return a+b; 
    }
}</code></pre>
<p>方法包含一个方法头和一个方法体。</p>
<ul>
<li>修饰符：定义该方法的访问类型</li>
<li>返回值类型：方法可能会返回值</li>
<li>方法名：方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>参数类型：方法被调用时，传递值给参数。<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据</li>
<li>实参：调用方法时实际传给方法的数据</li>
</ul>
</li>
<li>方法体：包含具体的语句，定义该方法的功能。</li>
</ul>
<pre><code class="java">修饰符 返回值类型 方法名（参数类型 参数名）{
    ...
    方法体
    ...
    return 返回值;
}</code></pre>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p>
<p>方法重载的规则：</p>
<ul>
<li>方法名称必须相同</li>
<li>参数列表必须不同</li>
<li>方法的返回值类型可以相同也可以不同</li>
<li>仅仅返回类型不同不足以成为方法的重载。</li>
</ul>
<p>实现理论：</p>
<p>方法名相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器会报错。</p>
<pre><code class="java">public class ADHero extends Hero {
    public void attack() {
        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);
    }

    public void attack(Hero h1) {
        System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;);
    }

    public void attack(Hero h1, Hero h2) {
        System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;);
    }

    public static void main(String[] args) {
        ADHero bh = new ADHero();
        bh.name = &quot;赏金猎人&quot;;

        Hero h1 = new Hero();
        h1.name = &quot;盖伦&quot;;
        Hero h2 = new Hero();
        h2.name = &quot;提莫&quot;;

        bh.attack(h1);
        bh.attack(h1, h2);
    }

}</code></pre>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>一个方法中只能指定一个可变参数，他必须是方法的最后一个参数，任何普通的参数必须在他之前声明。</p>
<pre><code class="java">//输入若干个double类型数据，比较大小后输出最大值
public class Demo01{
   public static void main(String args[]){
       printMax(...number:34,3,3,2,56.5);
       printMax(new double[]{1,2,3});
   } 
    public static void printMax(double... number){
        if(number.length == 0){
            System.out.println(&quot;No argument passed&quot;);
            return;
        }
        double result = number[0];
        //排序
        for(int i = 1;i&lt; number.length;i++){
            if(number[i]&gt;result){
                result = number[i];
            }
        }
        System.out.println(&quot;The max value is &quot; + result)；
    }
}</code></pre>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归就是A方法调用A方法，即自己调用自己。</p>
<p>递归结构包括两部分</p>
<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将进入死循环</li>
<li>递归体：什么时候需要调用自身方法。 </li>
</ul>
<pre><code class="java">//阶乘的算法
public class Demo06{
    public static void main(String[] arge){

    }
    public static int f(int n){
        if(n == 1){
            return 1;
        }else{
            return n*f(n:n-1);
        }
    }
}
</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase-集合</title>
    <url>/Mr-lee-MQ.hithub.io/2020/09/09/Javase-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合<a id="more"></a></h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>栈</strong></p>
<ul>
<li><strong>栈：stack</strong>，又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除工作，不允许在其他任何位置进行添加，查找，删除等操作</li>
</ul>
<p>简单来说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li>先进后出（即，存进去的元素，要在他后面的元素依次取出之后，才能取出该元素）。例如，子弹压入弹夹，先压进去的子弹在下面，后压进去的子弹在上面，开枪时，先弹出上面的子弹，才能弹出下面的子弹。</li>
<li>栈的入口，出口都是在栈的顶端位置</li>
</ul>
<p><a href="https://www.wailian.work/image/QmMI4o" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200909_102757.png" alt="sp200909_102757.png"></a></p>
<p><strong>队列</strong></p>
<ul>
<li><strong>队列：queue</strong>，简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下特点：</p>
<ul>
<li><strong>先进先出</strong>，（即存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如：小火车过山洞，车头先进去，车尾后出来。</li>
<li>队列的入口，出口各占一侧，例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li><strong>数组：Array</strong>，是有序的元素数列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号可以快速找到租房子的人。</li>
</ul>
<p>简单来说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><strong>查找元素快</strong>：通过索引，可以快速访问指定位置的元素</li>
<li><strong>增删元素慢</strong>：指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。</li>
</ul>
<p><a href="https://www.wailian.work/image/QmM9MN" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200909_105827.png" alt="sp200909_105827.png"></a></p>
<p><strong>链表</strong></p>
<ul>
<li><strong>链表：linked list</strong>，由一系列节点node（链表中每一个元素称为结点）组成，结点可以在运动时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有<strong>单向链表和双向链表</strong>。此处说的是单向链表。</li>
</ul>
<p>简单来说，采用该结构的集合，对元素的存取有如下特点：</p>
<p><strong>单向链表</strong>：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）</p>
<p><strong>双向链表</strong>：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序集合。</p>
<ul>
<li>多个结点之间，通过地址进行连接。例如：多个人手拉手，每个人使用自己的右手拉住下一个人的左手，依次类推，这样多个人就连在一起了。</li>
<li>查找元素慢：想查找某个元素，需要通过连接的结点，依次向后查找指定元素。</li>
<li>增删元素快：只需要修改连接下个元素的地址即可。</li>
</ul>
<p><strong>红黑树</strong></p>
<ul>
<li><strong>二叉树：binary tree</strong>,是每个结点不超过2的有序树。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点都最多只能有两个子结点。</p>
<p><strong>二叉树</strong>是每个节点最多有两个子树的树结构，顶点的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p><strong>红黑树</strong>本身就是一个二叉查找树，将节点插入后，该树仍然是一颗二叉查找树，也就意味着树的键值仍然是有序的。</p>
<ul>
<li><p><strong>特点：</strong>趋近于平衡树，<strong>查询的速度非常快</strong>，查询叶子节点最大次数和最小次数不能超过2倍。</p>
</li>
<li><p><strong>约束：</strong></p>
<ul>
<li>节点可以是红色的或者是黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点（空节点）是黑色的</li>
<li>每个红色的节点的子节点是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同。</li>
</ul>
</li>
<li><p><strong>排序树/查找树</strong></p>
</li>
</ul>
<p>在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大。</p>
<ul>
<li><strong>平衡树</strong></li>
</ul>
<p>左子树和右子树数量相等。</p>
<p><a href="https://www.wailian.work/image/QmMOOR" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200909_152303.png" alt="sp200909_152303.png"></a></p>
<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><h3 id="ArrayList集合概述和基本使用"><a href="#ArrayList集合概述和基本使用" class="headerlink" title="ArrayList集合概述和基本使用"></a>ArrayList集合概述和基本使用</h3><p>java.util.ArrayList是大小可变的数组的实现，存储在内的数据称为元素，此类提供一些方法来操作内部存储的元素，ArrayList中可不断添加元素，其大小也自动增长。</p>
<pre><code class="java">/*
数组的长度不可以发生改变。
但是ArrayList集合的长度是可以随意变化的。

对于ArrayList来说，由一个尖括号&lt;E&gt;代表泛型。
泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。
注意：泛型只能是引用类型，不能是基本类型。

注意事项：
    对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。如果内容为空，得到的是空的中括号。
*/

public class Demo02ArrayList{
    public static void main(String[] args){
        //创建了一个ArrayList集合，集合的名称是list，里面装的全都是String字符串类型的数据。
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        System.out.println(list);//[]

        //向集合中添加数据，需要用到add方法。
        list.add(&quot;赵丽颖&quot;);
        list.add(&quot;迪丽热巴&quot;);
        System.out.println(list);//[赵丽颖, 迪丽热巴]
    } 

}</code></pre>
<h3 id="ArrayLiat集合常用方法及遍历"><a href="#ArrayLiat集合常用方法及遍历" class="headerlink" title="ArrayLiat集合常用方法及遍历"></a>ArrayLiat集合常用方法及遍历</h3><pre><code class="java">/*
ArrayList当中的常用方法：
    public boolean add(E e);向集合中添加元素，参数类型和泛型一致
    public E get(int index);从集合中获取元素，参数是索引编号，返回值就是对应位置的元素。
    public E remove(int index);从集合中删除元素，参数是索引编号，返回值就是被删掉的元素。
    public int size();获取集合的尺寸长度，返回值是集合中包含的元素个数。
*/

public class Demo03ArrayListMethod{
    public static void main(String []args){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        System.out.println(list);//[]

        //向集合中添加元素：add
        boolean success = list.add(&quot;柳岩&quot;);
        System.out.println(list);//柳岩
        System.out.println(&quot;添加的动作是否成功：&quot;+ success);//true
        list.add(&quot;高圆圆&quot;);
        list.add(&quot;赵又廷&quot;);
        System.out.println(list);//[柳岩， 高圆圆， 赵又廷]

        //从集合中获取元素：get。索引从0开始。
        String name  = list.get(2);
        System.out.println(&quot;第二号索引位置：&quot;+name);//赵又廷

        //从集合中删除元素：remove。索引从0开始。
        String whoRemoved = list.remove(3);
        System.out.println(&quot;被删除的人是：&quot;+whoRemoved);
        System.out.println(list);

        //获取集合的长度尺寸，也就是其中元素的个数
        int size = list.size();
        System.out.println(&quot;集合的长度是：&quot;+size);
    }
}</code></pre>
<p>遍历集合</p>
<pre><code class="java">public class Demo04ArrayListEach{
    public static void main(String[] args){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;迪丽热巴&quot;);
        list.add(&quot;古力娜扎&quot;);
        list.add(&quot;马尔扎哈&quot;);

        //遍历集合
        for(int i = 0; i &lt; list.size(); i++){
            System.out.println(list.get(i));
        }
    }
}</code></pre>
<h3 id="ArrayList集合存储基本数据类型"><a href="#ArrayList集合存储基本数据类型" class="headerlink" title="ArrayList集合存储基本数据类型"></a>ArrayList集合存储基本数据类型</h3><pre><code class="java">/*
如果希望向集合ArrayList当中存储基本数据类型，必须使用基本类型对应的包装类。
*/

public class Demo05ArrayListBasic{
    public static void main(String[] args){
        ArrayList&lt;String&gt; listA = new ArrayList&lt;&gt;();
        //错误写法!泛型只能是引用类型，不能是基本类型

        ArrayList&lt;Integer&gt; listC = new ArrayList&lt;&gt;();
        listC.add(100);
        listC.add(200);
        System.out.println(list);//[100, 200]

        int num = listC.get(1);
        System.out.println(num);
    }
}</code></pre>
<h3 id="数值添加到集合"><a href="#数值添加到集合" class="headerlink" title="数值添加到集合"></a>数值添加到集合</h3><p>生成6个1~33之间的随机数，添加到集合，并遍历集合。</p>
<pre><code class="java">public class Test01ArrayList{
    public static void main(String[] args){
        //创建Random对象
        Random random = new Random();

        //创建ArrayList对象
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();

        //添加随机数到集合
        for (int i =0;i&lt;6;i++){
            int r = random.nextInt(33) + 1;
            list.add(r);
        }

        //遍历集合输出
        for (int i = 0;i &lt;list.size();i++){
            System.out.println(list.get(i));
        }
    }
}</code></pre>
<h3 id="对象添加到集合"><a href="#对象添加到集合" class="headerlink" title="对象添加到集合"></a>对象添加到集合</h3><p>自定义4个学生对象，添加到集合，并遍历</p>
<pre><code class="java">public class Test02ArrayList{
    public static void main(String[] args){
        //创建集合对象
        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();
        //创建学生对象
        Student s1 = new Student(&quot;赵丽颖&quot;,18);
        Student s2 = new Student(&quot;唐嫣&quot;,20);
        Student s3 = new Student(&quot;景甜&quot;,25);
        Student s4 = new Student(&quot;柳岩&quot;,19);

        //把学生对象作为元素添加到集合中
        list.add(s1);
        list.add(s2);
        list.add(s3);
        list.add(s4);

        //遍历集合
        for(int x = 0; x &lt; list.size(); x++){
            Student s = list.get(x);
            System.out.println(s.getName()+&quot;---&quot;+s.getAge());
        }
    }
}</code></pre>
<h3 id="打印集合方法"><a href="#打印集合方法" class="headerlink" title="打印集合方法"></a>打印集合方法</h3><p>定义指定格式打印集合的方法（ArrayList类型作为参数），使用{}扩起集合，使用@分隔每个元素。格式按照{元素@元素@元素}。</p>
<pre><code class="java">public class Test03ArrayList{
    public static void main(String[] args){
        //创建集合对象
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();

        //添加字符串到集合中
        list.add(&quot;张三丰&quot;);
        list.add(&quot;宋远桥&quot;);
        list.add(&quot;张无忌&quot;);
        list.add(&quot;殷梨亭&quot;);

        //调用方法
        printArrayList(list);
    }


    public static void printArrayList(ArrayList&lt;String&gt; list){
        System.out.println(&quot;{&quot;);
        for(int i = 0; i &lt; list.size(); i++){
          String name = list.get(i);
            if(i == list.size()-1){
                System/out.println(name +&quot;}&quot;);
            }else{
                System.out.print(name + &quot;@&quot;);
            }
        }
    }   
}</code></pre>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合按照其存储结构可以分为两大类，分别是单列集合Collection和双列集合Map。</p>
<ul>
<li>Collection:单列集合类的根接口，用于存储一系列符合某种规则的元素，他有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序，元素可重复。Set的特点是元素无序，而且不可重复 。</li>
<li>List接口的主要实现类是 java.util.ArrayList 和java.util.LinkedList。</li>
<li>Set接口的主要实现类是java.util.HashSet 和 java.util.TreeSet。</li>
</ul>
<p><a href="https://www.wailian.work/image/QmMzTK" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200914_131004.png" alt="sp200914_131004.png"></a></p>
<h3 id="单列集合的体系结构"><a href="#单列集合的体系结构" class="headerlink" title="单列集合的体系结构"></a>单列集合的体系结构</h3><ul>
<li>Collection：单列集合最顶端的接口<ul>
<li>List集合：是单列集合的一种，有索引，可以存储重复元素，可以保证存储顺序<ul>
<li>ArrayList：底层是数组实现的，查询快，增删慢。</li>
<li>LinkList：底层是链表实现的，查询慢，增删快。</li>
</ul>
</li>
<li>Set集合：无索引，不可以存储重复元素，存储无序。<ul>
<li>HashSet：底层是哈希表和红黑树实现的，无索引，不可以存储重复元素，存储无序。</li>
<li>LinkedHashSet：底层是哈希表和链表实现的，无索引，不可以存储重复的元素，可以保证存取顺序。</li>
<li>TreeSet：底层是二叉树实现。一般用于排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Collection集合常用方法"><a href="#Collection集合常用方法" class="headerlink" title="Collection集合常用方法"></a>Collection集合常用方法</h3><pre><code class="java">boolean add(E e);        向集合中添加元素

boolean remove(E e);    删除集合中的某个元素

void clear();            清空集合所有元素

boolean contains(E e);    判断集合中是否包含某个元素

boolean isEmpty();        判断集合是否为空
int size();                获取集合的长度
Object[] toArray();        将集合转成一个数组</code></pre>
<pre><code class="java">/*
boolean add(E e);        向集合中添加元素

boolean remove(E e);    删除集合中的某个元素

void clear();            清空集合所有元素

boolean contains(E e);    判断集合中是否包含某个元素

boolean isEmpty();        判断集合是否为空
int size();                获取集合的长度
Object[] toArray();        将集合转成一个数组
*/


public class Test01{
    public static void main(String[] args){
        //创建集合对象
        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
        //boolean add(E e);  向集合中添加元素
        coll.add(&quot;hello&quot;);
        coll.add(&quot;world&quot;);
        coll.add(&quot;heima&quot;);
        coll.add(&quot;java&quot;);
        System.out.println(coll);//[hello, world, heima, java]


        //boolean remove(E e);  删除集合中的某个元素
        boolean result = coll.remove(&quot;hello2&quot;)；
        System.out.println(result);//true
        System.out.println(coll);//[world, heima, java]


        //void clear();   清空集合所有的元素
        coll.clear();
        System.out.println(coll);  //[]


        //boolean contains(E e);  判断集合中是否包含某个元素
        boolean result = coll.contains(&quot;java&quot;);
        System.out.println(result);  //true


        //boolean isEmpty();  判断集合是否为空。
        System.out.println(coll.isEmpty());  //true


        //int size();  获取集合长度
        System.out.println(coll.size());


        //Object[] toArray();
        Object[] arr = coll.toArray()
        //遍历数组
        for(int i = 0;i &lt; arr.length; i++){
            System.out.println(arr[i]);
        }

    }

}</code></pre>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><pre><code class="java">/*
java.util.List接口extends Collection接口
List接口的特点：
    有序的集合，存储元素和取出元素的顺序是一致的。
    有索引，包含了一些带索引的方法。
    允许存储重复的元素。


List接口中带索引的方法(特有)：
    public void add(int index, E element):将指定的元素，添加到该集合中的指定位置上。
    public E get(int index):返回集合中指定位置的元素。
    public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素。
    public E set(int index, E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素。

注意：
    操作索引的时候，一定要防止索引越界异常。
    IndexOutOfBoundsException:索引越界异常，集合会报。
    ArrayIndexOutOfBoundsException:数组索引越界异常。
    StringIndexOutOfBoundsException:字符串索引越界异常。


*/

public class Demo01List{
    public static void main(String[] args){
        //创建一个List集合对象，多态
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        //使用add方发往集合中添加元素
        list.add(&quot;a&quot;);
        list.add(&quot;b&quot;);
        lisr.add(&quot;c&quot;);
        list.add(&quot;d&quot;);
        list,add(&quot;a&quot;);
        //打印集合
        System.out.println(list);//[a, b, c, d, a]


//public void add(int index, E element):将指定的元素，添加到该集合中的指定位置上。
//在c和d之间添加一个itheima
        list.add(3,&quot;itheima&quot;);
        System.out.println(list);//[a, b, c, itheima, d, a]


//public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素。
//移除元素
        String removeE = list.remove(2);
        System.out.println(&quot;被移除的元素：&quot;+removeE);//被移除的元素c
        System.out.println(list);//[a, b, itheima, d, a]


//public E set(int index, E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素。
//把最后一个a，替换成A
        String setE = list.set(4, &quot;A&quot;);
        System.out.println(&quot;被替换的元素:&quot;+ setE);//被替换的元素：a
        System.out.println(list);//[a, b, itheima, d, A]


//List集合遍历有3种方式
        //使用普通的for循环
        for(int i = 0; i &lt;list.size(); i++){
            //public E get (int index);返回集合中指定位置的元素。
            String s = list.get(i);
            System.out.println(s);
        }
        System.out.println(&quot;-----------------&quot;);
        //使用迭代器
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        System.out.println(&quot;--------------&quot;);
        //使用增强for
        for(String s: list){
            System.out.println(s);
        }

    }
}</code></pre>
<h3 id="ArrayList集合-1"><a href="#ArrayList集合-1" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><p>​        java.util.ArrayList集合是数据存储的结构是<strong>数组</strong>结构。<strong>元素增删慢，查找快。</strong>由于日常开发中使用最多的功能为查询结构，遍历数据，所以ArrayList是最常用的集合。</p>
<p>原因：</p>
<p>​    底层是一个数组结构，添加一个元素是将整个数组复制以后，再添加一个长度。所以增删慢。效率低。</p>
<h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><p>​        java.util.LinkedList集合数据存储的结构是<strong>链表</strong>结构。<strong>方便元素添加删除</strong>的集合。LinkedList是一个<strong>双向链表</strong>。</p>
<pre><code class="java">/*
LinkedList集合的特点：
    1.底层是一个链表结构：查询慢，增删快
    2.里面包含了大量操作首尾元素的方法。
    注意：使用LinkedList集合特有的方法，不能使用多态。

*/</code></pre>
<pre><code class="java">public void addFirst(E e):将指定元素插入此列表的开头
public void addLast(E e):将指定元素添加到此列表的结尾
public void push(E e):将元素推入此列表所表示的堆栈。

public E getFirst():返回此列表的第一个元素
public E getLast():返回此列表的最后一个元素

public E removeFirst():移除并返回此列表的第一个元素
public E removeLast():移除并返回此列表的最后一个元素
public E pop():从此列表所表示的堆栈处弹出一个元素

public boolean isEmpty():如果列表不包含元素，则返回true</code></pre>
<pre><code class="java">public class Demo02LinkedList{
    public static void main(String[] args){
        show01();
    }

    //public void addFirst(E e):将指定元素插入此列表的开头
    private static void show01(){
        //创建LinkedList集合对象
        LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();
        //使用add方法往集合中添加元素
        linked.add(&quot;a&quot;);
        linked.add(&quot;b&quot;);
        linked.add(&quot;c&quot;);
        System.out.println(linked);//[a, b, c]
        //public void addFirst(E e):将指定元素插入此列表的开头。
        linked.addFirst(&quot;www&quot;);
        System.out.println(linked);//[www, a, b, c]
    }
}</code></pre>
<h3 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h3><p>Vector类可以实现可增长的对象<strong>数组</strong>。Vector是同步的。单线程。</p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h3><p>​        java.util.HashSet是Set接口的一个实现类，它所存储的元素的元素是不可重复的，并且元素都是无序的（即存储顺序不一致）HashSet底层的实现是HashMap支持。</p>
<p>​        HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找技能。保证元素唯一性的方式依赖于hashCode和equals方法。</p>
<pre><code class="java">/*
Set接口的特点：
    1.不允许存储重复的元素
    2.没有索引，没有带索引的方法，也不能使用普通的for循环遍历
HashSet特点：
    1.不允许存储重复的元素
    2.没有索引，没有带索引的方法，也不能使用普通的for循环遍历
    3.是一个无序的集合，存储元素和取出元素的顺序有可能不一致
    4.底层是一个哈希表结构(查询的速度非常快)

*/


public class Demo01Set{
    public static void main(String[] args){
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        //使用add方法添加元素
        set.add(&quot;1&quot;);
        set.add(&quot;3&quot;);
        set.add(&quot;2&quot;);
        set.add(&quot;1&quot;);
        //使用迭代器遍历set集合
        Iterator&lt;Integer&gt; it = set.iterator();
        while (it.hasNext()){
        Integer n = it.next();
        System.out.println(n);//1,2,3
        }
        //使用增强for遍历set集合
        System.out.println(&quot;------------&quot;);
        for (Integer i : set){
            System.out.println(i);
        }

    }
}</code></pre>
<h3 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h3><p>​        <strong>JDK1.8之前，哈希表底层采用数组+ 链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。</strong>但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而在JDK1.8中，<strong>哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样就大大减少了查找时间</strong></p>
<pre><code class="java"> /*
 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）
 在Object类有一个方法，可以获取对象的哈希值
 int hashCode()    返回该对象的哈希码值
 hashCode的源码：
     public native int hashCode();
     native:代表该方法调用的是本地操作系统的方法
 */

public class Demo01HashCode{
    public static void mian(String[] args){
        //Person类继承了Object类，所以可以使用Object类的hashCode方法
        Person p1 = new Person();
        int h1 = p1.hashCode();
        System.out.println(h1);
        //47851648225
        Person p2 = new Person();
        int h2 = p2.hashCode();
        System.out.println(h2);
        //421560258416  


        /*
        toString方法的源码：
            reyurn getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());

        */
        System.out.println(p1);
        //com.itheima.demo03.hashCode.Person@841461c
        System.out.println(p2);
        //com.itheima.demo03.hashCode.Person@156654b



        /*
        String类的哈希值
            String类重写Object类的hashCode方法

        */
        String s1 = new String(&quot;abc&quot;);
        String s2 = new String(&quot;abc&quot;);
        System.out.println(s1.hashCode());//96354
        System.out.println(s2,hashCode());//96354

        System.out.println(&quot;重地&quot;.hashCode());//1179395
         System.out.println(&quot;通话&quot;.hashCode());//1179395

    }
}</code></pre>
<p><a href="https://www.wailian.work/image/QmMJEr" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200917_100959.png" alt="sp200917_100959.png"></a></p>
<h3 id="Set集合存储元素不重复的原理"><a href="#Set集合存储元素不重复的原理" class="headerlink" title="Set集合存储元素不重复的原理"></a>Set集合存储元素不重复的原理</h3><pre><code class="java">![sp200917_200305](Javase-集合/sp200917_200305.png/*
    Set集合不允许存储重复元素的原理
*/

public class Demo02HashSetSaveString {
    public static void main(String[] args){
        //创建HashSet集合对象
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        String s1 = new String(&quot;abc&quot;);
        String s2 = new String(&quot;abc&quot;);
        set.add(s1);
        set.add(s2);

        set.add(&quot;重地&quot;);
        set.add(&quot;通话&quot;);
        set.add(&quot;abc&quot;);
        System.out.println(set);//[重地， 通话， abc]
    }
}</code></pre>
<p><a href="https://www.wailian.work/image/QmMUM1" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200917_200305.png" alt="sp200917_200305.png"></a></p>
<h3 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h3><p>给HashSet中存放自定义元素类型时，需要重写对象中的hashCode方法和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p>
<pre><code class="java">/*
    HashSet 存储自定义类型元素

    set集合报错元素唯一：
        存储的元素(String，Integer,...Student,Person.),必须重写hashCode方法和equlas方法。
    需求：
        同名同年龄的人，视为同一个人，只能存储一次。

*/

public class Demo03HashSetSavePerson{
    public static void main(String[] args){
        //创建HashSet集合存储Person
        HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();
        Person p1 = new Person(&quot;小美女&quot;,18);
        Person p2 = new Person(&quot;小美女&quot;,18);
        Person p3 = new Person(&quot;小美女&quot;,19);
        System.out.println(p1.hashCode());
        System.out.println(p2.hashCode());//哈希值不同

        System.out.println(p1==p2);//false
        System.out.println(p1.equals p2);//false

        set.add(p1);
        set.add(p2);
        set.add(p3);

        System.out.println(set);
    }
}</code></pre>
<p><strong>Person类重写hashCode方法和equlas方法。</strong></p>
<pre><code class="java">public class Person{
    private String name;
    private int age;

    public Person(){

    }

    public Person(String name, int  age){
        this.name = name;
        this.age = age;

    } 


    @Override  //重写equals方法
    public boolean equals(Object o){
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == Person.age &amp;&amp; Object.equals(name, person.name);
    }


    @Override   //重写hashCode方法
    public int hashCode(){

        return Object.hash(name, age);
    }


    @Override   //重写toString方法
    public String toString(){
        return &quot;Person {&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39;+ 
                &quot;, age = &quot;+ age +&#39;}&#39;&quot;        
                       }
    }



    public String getName(){
        return name;

    }
    public void setName(String name){
        this.name = name;
    }
}</code></pre>
<h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><p>它是由链表和哈希表组合的一个数据存储结构。此链接列表定义了迭代顺序，即按照将元素插到set中的顺序进行迭代。</p>
<p>注意：</p>
<p>​    插入顺序不受set中重新插入的元素的影响。</p>
<pre><code class="java">/*
    java.util.LinkedHashSet集合 extends HashSet集合
    LInkedHashSet集合的特点：
        底层是一个哈希表(数组+链表/红黑树)+链表(多的这条链表用于记录元素的存储顺序，保证元素有序)
*/

public class Demo04LinkedhashSet {
    public static void main(String[] args){
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;www&quot;);
        set.add(&quot;abc&quot;);
        set.add(&quot;abc&quot;);
        set.add(&quot;itcast&quot;);
        System.out.println(set);//[abc, www, itcast]无序，不允许重复。

        LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;();
        linked.add(&quot;www&quot;);
        linked.add(&quot;abc&quot;);
        linked.add(&quot;abc&quot;);
        linked.add(&quot;itcast&quot;);
        System.out.println(linked);//[www, abc, itcast]有序，不允许重复。
    }
}</code></pre>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>注意事项：</p>
<p>​    1.一个方法的参数列表，只能有一个可变参数。</p>
<p>​    2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</p>
<pre><code class="java">/*
可变参数：是JDK1.5之后出现的新特性
适用前提：
    当方法的参数列表数据类型已经确定，但是参数个数不确定，就可以使用可变参数。

是用格式：定义方法时使用
    修饰符 返回值类型 方法名 (数据类型...变量名){}
可变参数原理：
    可变参数底层是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数
    传递的参数个数，可以是0个(不传递)，1,2...多个

*/

public class Demo01VarArgs{
    public static void mian(String[] args){
        int i = add(10,20,12,56);
        System.out.println(i);

}
    /*
    定义计算(0~n)整数和的方法
    已知:计算整数的和，数据类型已经确定int
    但是参数的个数不确定，就可以使用可变参数
    add();就会创建一个长度为0的数组
    */
    public static int add(int...arr){
      //定义一个初始化的变量，记录累加求和
        int sum = 0;
        //遍历数组，获取数组中的每一个元素
        for(int i : arr){
            sum += i;
        }
        //把求到的和返回
        return sum;
    }


}</code></pre>
<p><strong>可变参数的特殊写法</strong></p>
<pre><code class="java">public static void metmod(Object...){

}</code></pre>
<h2 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h2><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>java.utils.Collections是集合工具类，用来对集合进行操作。</p>
<p>部分方法如下:</p>
<pre><code class="java">/*
public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)    :往集合中添加一些元素

public static void shuffle(List&lt;&gt; list)    :打乱集合顺序。

public static &lt;T&gt; void sort(List&lt;T&gt; list)    :将集合中元素按照默认规则排序。

public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super.T&gt; )    :将集合中元素按照指定规则排序。
*/</code></pre>
<pre><code class="java">/*
    public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)    :往集合中添加一些元素

    public static void shuffle(List&lt;&gt; list)    :打乱集合顺序。
*/

public class Demo01Collections {
    public static void main(String[] args){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        //往集合中添加多个元素
                              Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);
        //可变参数，参数个数不受限制
        System.out.println(list);//[a, b, c, d, e]

      //打乱集合顺序
       Collections.shuffle(list);
        System.out.println(list);//[b, d, c, a, e]        
    }
}</code></pre>
<pre><code class="java">/*
public static &lt;T&gt; void sort(List&lt;T&gt; list)    :将集合中元素按照默认规则排序。

注意：
    sort(list&lt;T&gt; list)适用前提
    被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法compareTo定义排序的规则。
    Comparable接口的排序规则:
        自己(this)-参数:升序

*/

public class Demo02Sort{
    public static void main(String[] args){
        ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();
        list.add(1);
        list.add(3);
        liat.add(2);
        System.out.println(list01);//[1, 3, 2]

        //使用sort方法
        Collections.sort(list01);//默认是升序

        System.out.println(list01);//[1, 2, 3]

    }
}</code></pre>
<pre><code class="java">/*
public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super.T&gt; )    :将集合中元素按照指定规则排序。

Comparator和Comparable的区别：
    Comparable: 自己(this)和别人(参数)比较，自己需要实现Comparable接口，重写比较的规则compare方法。
    Comparator: 相当于找了一个第三方的裁判比较两个。

Comparator的排序规则:
    o1-o2:升序
    o2-o1:降序
*/

public class Demo03sort{
    public static void main(String[] args){
        ArrayLiat&lt;Integer&gt; List01 = new ArrayList&lt;&gt;();
        list01.add(1);
        list01.add(3);
        list01.add(2);
        System.out.println(list01);//[1, 3, 2]

        Collections.sort(list01, {
            //重写比较的规则
            @Override
            public int compare(Integer01, Integer02){
                return o1-o2;  //升序
                return o2-o1;  //降序
            }
        });

        System.out.println(list01);


        //自定义类型,需要重写toString 

        ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;();
        list02.add(new Student(&quot;迪丽热巴&quot;, 18));
        list02.add(new Student(&quot;古力娜扎&quot;, 20));
        liat02.add(new Student(&quot;杨幂&quot;, 17));

        Collections.sort(list02, {
            @Override
            public int compare(Student 01, Student 02){
                //按照年龄升序
                return 01.getAge() - 02.getAge();
                //如果两个人年龄相同，再使用姓名的第一个字母比较
                if(result == 0){
                    result = 01.getName().charAt(0) - 02.getName().charAt(0);
                }
                return result;
            }

        });
        System.out.println(list02);
    }
}</code></pre>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>此键映射到值得对象。一个映射不能包含重复的建；每个键最多只能映射到一个值。</p>
<ul>
<li>Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</li>
<li>Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找对应的值。</li>
<li>Collection 中的集合称为单列集合，Map 中的集合称为双列集合。</li>
<li>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<p><a href="https://www.wailian.work/image/QmMkN9" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200919_232025.png" alt="sp200919_232025.png"></a></p>
<pre><code class="java">/*
Map集合的特点:
    1.Map集合是一个双列集合，一个元素包含两个值(一个key，一个value)
    2.Map集合中的元素，key和value的数据类型可以相同，也可以不同。
    3.Map集合中的元素，key是不允许重复的，value是可以重复的。
    4.Map集合中的元素，key和value是一一对应。


HashMap集合的特点:
    1.hashMap集合底层是哈希表，查询速度快。
        JDK1.8之前，数组+单向链表
        JDK1.8之后，数组+单向链表/红黑树(链表的长度超过8):提高查询的速度。
    2.hashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致。

LinkedHashMap的特点:
    1.LinkedHashMap集合底层是哈希表+链表(保证迭代顺序)
    2.LinkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序是一致的

*/

public class Demo01Map{
    public static void main(String[] args){
        show01();

    }

    /*
    public  V put(K key, V value):把指定的键与指定的值添加到Map集合中。
    返回值：V
        存储键值对的时候，key不重复，返回值V是null
        存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值。


    */

    public static show01(){
        //创建Map集合对象，多态
        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();

        map.put(&quot;冷锋&quot;，&quot;龙小云&quot;);
        map.put(&quot;杨过&quot;，&quot;小龙女&quot;);
        map.put(&quot;尹志平&quot;，&quot;小龙女&quot;);

        System.out.println(map);
        //{杨过=小龙女， 尹志平=小龙女， 冷锋=龙小云}
    }



    /*
    public V remove(Object key):把指定的键所对应的的键值对元素 在Map集合中删除，返回被删除元素的值。
    返回值:V
        key存在，v返回被删除的值
        key不存在，v返回null
    */
    private static void show02(){
        //创建Map集合对象
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;赵丽颖&quot;,168);
        map.put(&quot;杨颖&quot;,165);
        map.put(&quot;林志玲&quot;,178);
        System.out.println(map);

        Integer v1 = map.remove(&quot;林志玲&quot;);
        System.out.println(&quot;v1&quot;+v1);//v1：178

        System.out.println(map);
    }


    /*
    public V get(Object key) 根据指定的键，在Map集合中获取对应的值。
        返回值:
            key存在，返回对应的value值
            key不存在，返回null

    */
    private static void show03(){
         //创建Map集合对象
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;赵丽颖&quot;,168);
        map.put(&quot;杨颖&quot;,165);
        map.put(&quot;林志玲&quot;,178);

        Integer v1 = map.get(&quot;杨颖&quot;);
        System.out.println(&quot;v1:&quot;+v1);//v1:165
    }



   /*
   boolean containsKey(Object key) 判断集合中是否包含指定的键。
       包含返回true，不包含返回false

   */
     //创建Map集合对象
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;赵丽颖&quot;,168);
        map.put(&quot;杨颖&quot;,165);
        map.put(&quot;林志玲&quot;,178);

        boolean b1 = map.containsKey(&quot;赵丽颖&quot;);
        System.out.println(&quot;b1:&quot; +b1);//ture
}</code></pre>
<h3 id="Map集合遍历-键找值方式"><a href="#Map集合遍历-键找值方式" class="headerlink" title="Map集合遍历   键找值方式"></a>Map集合遍历   键找值方式</h3><p>键找值方式:即通过元素的键，获取键所对应的值</p>
<p>分析步骤:<br>    1.获取Map中所有的键，由于键是唯一性的，所以返回一个Set集合存储所有的键。方法提示:keyset();</p>
<p>​    2.遍历键的Set集合，得到每一个键。</p>
<ol start="3">
<li>根据键，获取键所对应的值，方法提示:get（K key）;</li>
</ol>
<p><a href="https://www.wailian.work/image/QmMEWV" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200920_093430.png" alt="sp200920_093430.png"></a></p>
<pre><code class="java">/*
    Map集合的第一种遍历方式:通过键找值的方式
    Map集合中的方法:
        Set&lt;K&gt; keySet()  返回此映射中包含的键的Set视图
    实现步骤:
        1.使用Map集合中的方法keySet()，把Map集合所有的key取出来，存储到一个Set集合中
        2.遍历Set集合，获取Map集合中的每一个key
        3.通过Map集合中的方法get(key),通过key找到value

*/


public class Demo02KeySet{
    public static void main(String[] args){
        //创建Map集合对象
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;赵丽颖&quot;,168);
        map.put(&quot;杨颖&quot;,165);
        map.put(&quot;林志玲&quot;,178);

        //1.使用Map集合中的方法keySet()，把Map集合所有的key取出来，存储到一个Set集合中
        Set&lt;String&gt; set = map.keySet();

        //2.遍历Set集合，获取Map集合中的每一个key
        //使用迭代器遍历Set集合
        Integer&lt;String&gt; it = set.iterator();
        while (it.hasNext()){
            String key = it.next();

        //3.通过Map集合中的方法get(key),通过key找到value
            Integer value = map.get(key);
            System.out.println(key+ &quot;=&quot; +value);

        }
        System.out.println(&quot;----------------&quot;);

        //使用增强for遍历Set集合
        for(String key : set){
           Integer value = map.get(key);
            System.out.println(key+ &quot;=&quot; +value); 
        }
    }
}</code></pre>
<h3 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h3><p>我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，他们在Map中是一一对应的关系，这一对对象又称作Map中的一个Entry(项)。Entry将键值对的对应关系封装成对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对Entry对象中获取对应的键与对应的值</p>
<p><a href="https://www.wailian.work/image/QmM8Ek" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/11/sp200920_105105.png" alt="sp200920_105105.png"></a></p>
<pre><code class="java">/*
Map集合遍历的第二种方式：使用Entry对象遍历

    Map集合中的方法:
        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()  返回此映射中包含的映射关系的Set视图。

    实现步骤:
        1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来，存储到一个Set集合中。
        2.遍历Set集合，获取每一个Entry对象
        3.使用Entry对象中的方法getKey()和getValue()获取键与值

*/

public class Demo03EntrySet{
    public static void main(String[] args){
        //创建Map集合对象
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;赵丽颖&quot;,168);
        map.put(&quot;杨颖&quot;,165);
        map.put(&quot;林志玲&quot;,178);
        //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来，存储到一个Set集合中。
        Set &lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();

        //2.遍历Set集合，获取每一个Entry对象
        //使用迭代器遍历Set集合
        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();
        while(it.hasNext()){
            Map.Entry&lt;String, Integer&gt; entry = it.next();
            //3.使用Entry对象中的方法getKey()和getValue()获取键与值.
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.ou.println(key+&quot;=&quot;+value);
        }
        System.out.println(&quot;--------------&quot;);

    }
}</code></pre>
<h3 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h3><pre><code class="java">/*
HashMap存储自定义类型键值
Map集合保证key是唯一性的：
    作为key的元素，必须重写hashCode方法和equals方法，保证key唯一。

*/

public class Demo01HashMapSavePerson{
    public static void msin(String[] args){
        show01();
    }

    /*
    HashMap存储自定义类型键值
    key:String类型
        String类型重写hashCode方法和equals方法，保证key唯一。
    value:Person类型
        value可以重复

    */

    private static void show01(){
         //创建HashMap集合
        HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;();
        //往集合中添加元素
        map.put(&quot;北京&quot;,new Person(&quot;张三&quot;,18));
        map.put(&quot;上海&quot;,new Person(&quot;李四&quot;,19));
        map.put(&quot;广州&quot;,new Person(&quot;王五&quot;,20));
        map.put(&quot;北京&quot;,new Person(&quot;赵六&quot;,18));

        //使用keySet加增强for遍历Map集合
        Set&lt;String&gt; set = map.keySet();
        for (String key : set){
            Person value = map.get(key);
            System.out.println(key+&quot;--&gt;&quot;+value);
        }

    }
}
</code></pre>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<pre><code class="java">/*
Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。
底层原理：
    哈希表+链表(记录元素的顺序)

*/

public class Demo01LinkedHashMap{
    public static void main(String[] args){
        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;a&quot;,&quot;a&quot;);
        map.put(&quot;c&quot;,&quot;c&quot;);
        map.put(&quot;b&quot;,&quot;b&quot;);
        map.put(&quot;a&quot;,&quot;d&quot;);
        System.out.println(map);//key不允许重复，无序


        LinkedHashMap&lt;String,String&gt; Linked = new LinkedHashMap&lt;&gt;();
        Linked.put(&quot;a&quot;,&quot;a&quot;);
        Linked.put(&quot;c&quot;,&quot;c&quot;);
        Linked.put(&quot;b&quot;,&quot;b&quot;);
        Linked.put(&quot;a&quot;,&quot;d&quot;);
        System.out.println(Linked);//key不允许重复，有序{a=b, c=c, b=b}

    }



}</code></pre>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>此类实现一个哈希表，该哈希表将键映射到对应的值。任何非null对象都可以用作键或值。</p>
<pre><code class="java">/*
Hashtable:底层是一个哈希表，是一个单线程，线程安全的集合，速度慢。
HashMap:底层是一个哈希表，是一个线程不安全的集合，是多线程集合，速度快

HashMap集合(之前学的所有集合):可以存储null值，null键。
Hashtable集合:不能存储null值，null键。

Hashtable集合和Vector集合，在JDK1.2之后被HashMap和ArrayLi取代。

Hashtable的子类Properties依然活跃在历史舞台
Properties集合是唯一一个和IO流结合的集合。

*/

public class Demo02Hashtable{
    public static void main(String[] args){
        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(null,&quot;a&quot;);
        map.put(&quot;b&quot;,null);
        map.put(nill,null);
        System.out.println(map);//{null=null, b=null}

        Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;();
        table.put(null,&quot;a&quot;);
        table.put(&quot;b&quot;,null);//不允许存储空值空键，空指针异常

    }
}


</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_注解与反射</title>
    <url>/Mr-lee-MQ.hithub.io/2020/10/25/Javase-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射<a id="more"></a></h1><p><strong>什么是注解</strong></p>
<ul>
<li>Annotation是从JDK5.0开始引入的新技术</li>
<li>Annotation的作用<ul>
<li>不是程序本身，可以对程序作出解释（这一点和注释（comment）没有区别）</li>
<li><mark>可以被其他程序（编译器）读取。</mark></li>
</ul>
</li>
<li>Annotation的格式：<ul>
<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例：如：@SuppressWarnings(value=”unchecked”)。</li>
</ul>
</li>
<li>Annotation在那里可以用？<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助消息，我们可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<pre><code class="java">//什么是注解
public class Test01 extends Object{
    //@Override  重写的注解
    @Override
    public String toString(){
       return super.toString();
    }
}</code></pre>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p><strong>@Override：</strong>定义在java.lang.Override中，此注释只适合于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</p>
<p><strong>@Deprecated：</strong>定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</p>
<p><strong>@SupperessWarnings：</strong>定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。</p>
<ul>
<li>与前两个注释有所不同，你需要添加一个参数才可以正确的使用，这些参数都是已经定义好了的，我们选择性的使用就好。<ul>
<li>@SuppressWarnings(“all”)</li>
<li>@SuppressWarnings(“unchecked”)</li>
<li>@SuppressWarnings(value = {“unchecked”,”deprecation”})</li>
<li>等等</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明。</li>
<li>这些类型和他们所支持的类在java.lang.annotation包中可以找到（@Target，@Retention，@Documented，@Inherited）<ul>
<li>@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>
<li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。<ul>
<li>（SOURCE&lt;CLASS&lt;RUNTIME）</li>
</ul>
</li>
<li>@Document：说明该注解将包含在javadoc中。</li>
<li>@Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<pre><code class="java">//测试元注解

@MyAnnotation
public class Test02{
    public void test(){

    }
}

//定义一个注解
//Target  表示我们的注解可以用在哪些地方
@Target(value = {ElementType.METHOD,ElementType.TYPE})

//Retention  表示我们的注解可以用在哪些地方
@Retention(value = RetentionPolity.RUNTIME)
@interface MyAnnotation{    
}

//Docuemnted  表示是否将我们的注解生成在JAVAdoc中
@Documented

//Inherited   子类可以继承父类的注解
@Inherited
@interface MyAnntation{
}
</code></pre>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口</p>
<p>分析：</p>
<ul>
<li>@interface用来说明一个注解，<strong>格式：public  @  interface  注解名{定义内容}</strong></li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称就是参数的名称</li>
<li>返回值类型就是参数的类型</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值.</li>
</ul>
<pre><code class="java">//自定义注解
public class Test03{
    //注解可以显示赋值，如果没有默认值，我们就必须给注解赋值
    @MyAnnotation(name = &quot;秦疆&quot;)
    public void test(){}
}

@Target({ElementType.TYPE,ElementTyPE.METHOD})//目标哦作用域
@Retention(RetentionPolity.RUNTIME)//在哪个阶段有效
@interface MyAnnotation2{
    //注解的参数: 参数类型  +  参数名 ();
    String name() default&quot;&quot;;
    int age() default 0;
}

//若只有一个属性，可以定义为value，可以不用写参数</code></pre>
<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><h3 id="静态VS动态语言"><a href="#静态VS动态语言" class="headerlink" title="静态VS动态语言"></a>静态VS动态语言</h3><ul>
<li>动态语言<ul>
<li>是一类在运行时可以改变其结构的语言：例如新的函数，对象，甚至代码可以被引进，已有的函数可以被删除或者是其他结构上的改变。通俗一点说的就是在运行代码时可以根据某些条件改变自身结构。</li>
<li>主要动态语言：Object-C ， C#，JavaScript，PHP，Python等。</li>
</ul>
</li>
<li>静态语言<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java，C，C++。</li>
<li>Java不是动态语言，但Java可以称为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</li>
</ul>
</li>
</ul>
<h3 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h3><p>Reflection(反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection  API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<pre><code class="java">Class c = Class.forName(&quot;java.lang.String&quot;)</code></pre>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p>
<p>正常方式：引入需要的”包类”名称—-&gt;通过new实例化—-&gt;取得实例化对象</p>
<p>反射方式：实例化对象—-&gt;getClass()方法—-&gt;得到完整的”包类”名称</p>
<p><strong>反射机制提供的功能</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
<li>…….</li>
</ul>
<p><strong>Java反射的优点和缺点</strong></p>
<p>优点:可以实现动态创建对象和编译，体现出很大的灵活性</p>
<p>缺点:对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作</p>
<p><strong>反射相关的主要API</strong></p>
<ul>
<li>java.lang.Class:代表一个类</li>
<li>java.lang.refect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constuctor:代表类的构造器</li>
</ul>
<pre><code class="java">//什么是反射
public class Test02{

    public static void main(String[] args) throws ClassNoFoundException{
        //通过反射获取类的Class对象
        Class c1 = Class.ForName(&quot;com.kuang.reflection.User&quot;);
        System.out.println(c1);

        Class c2 = Class.forName(&quot;com.kuang.reflection.User&quot;);
        Class c3 = Class.forName(&quot;com.kuang.reflection.User&quot;);
        Class c4 = Class.forName(&quot;com.kuang.reflection.User&quot;);

        //一个类在内存中只有一个Class对象
        //一个类被加载后，类的整个结构都会被封装在Class对象中。

        System.out.println(c2.hashCode());
        System.out.println(c3.hashCode());
        System.out.println(c4.hashCode());
    }

}
//实体类：类中只有属性
class User{
    private String name;
    private int id;
    private int age;

    public User(){

    }

    piblic User (String name, int id, int age){
        this.name = name;
        this.id = id;
        this.age = age;
    }
    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }

    public int getId(){
        return id;
    }

    public void setId(int id){
        this.id = id;
    }

    public void getAge(){
        return age;
    }

    public void setAge(int age){
        this.age = age;
    }

}</code></pre>
<h3 id="CLass类"><a href="#CLass类" class="headerlink" title="CLass类"></a>CLass类</h3><p>对象照镜子后可以得到的信息：某个类的属性，方法和构造器，某个类到底实现了那些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type）的有关信息。</p>
<ul>
<li>CLass本身也是一个类</li>
<li>Class对象只能由系统建立对象</li>
<li>一个加载的类在JVM中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载，运行的类，唯有先获得对应的Class对象</li>
</ul>
<h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><pre><code class="java">static ClassforName(String name)//返回指定类名name的Class对象
Object newInstance()//调用缺省构造函数，返回Class对象的一个实例
getName()//返回此Class对象所表示的实体(类，接口，数组类或void)的名称
Class getSuperClass()//返回当前Class对象的父类的Class对象
Class[]getinterfaces()//返回当前Class对象的接口
ClassLoader getClassLoader//返回该类的类加载器
Constructor[] getConstructors()//返回一个包含某些Constructor对象的数组
Method getMothed(String name,Class ..T)//返回一个Method对象，此对象的形参类型为paramType
Field[] getDeclsredFields()//返回Field对象的一个数组</code></pre>
<h3 id="获取Class类的实例"><a href="#获取Class类的实例" class="headerlink" title="获取Class类的实例"></a>获取Class类的实例</h3><ul>
<li>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</li>
</ul>
<pre><code class="java">Class class = Person.class;</code></pre>
<ul>
<li>已知某个类的实例，调用该实例的getClass()方法获取Class对象</li>
</ul>
<pre><code class="java">Class class = person.getClass();</code></pre>
<ul>
<li>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</li>
</ul>
<pre><code class="java">Class class = Class.forName(&quot;demo01.Student&quot;);</code></pre>
<ul>
<li>内置基本数据类型可以直接用类名.Type</li>
<li>还可以利用ClassLoader</li>
</ul>
<pre><code class="java">//测试Class类的创建方式有哪些
public class Test03{
  public static void main(String[] args){
      Person person = new Student();
      System.out.println(&quot;这个人是:&quot;+person.name);

      //方式一:通过对象获得
      Class c1 = person.getClass();
      System.out.println(c1.hashCode());

      //方式二:forname获得
      Class c2 = Class.forName(&quot;com.kuang.reflection.Student&quot;);
      System.out.println(c2.hashCode());

      //方式三:通过类名.class获得
      Class c3 = Student.class;
      System.out.println(c3.hashCode());

      //方式四:基本内置类型的包装类都有一个Type属性
      Class c4 = Integer.YTPE;
      System.out.println(c4);

      //方式五:获得父类类型
      Class c5 = c1.getSuperclass();
      System.out.println(c5);
  }  
}

class Person{
    public String name;

    public Person(){

    }

    public Person(String name){
        this.name = name;
    }

    @Override
    public String toString(){
        return &quot;Person{&quot; + &quot;name = &#39;&quot; + name + &quot;\&#39;+&#39;};
    }   
}
class Student extends Person{
        public Student(){
            this.name = &quot;学生&quot;;
        }
    }

 class Teacher extends Person {
        public Teacher(){
            this.name = &quot;老师&quot;;
        }
    }</code></pre>
<h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><p>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</p>
<p>interface：接口</p>
<p>[]：数组</p>
<p>enum：枚举</p>
<p>annotation：注解@interface</p>
<p>primitive type：基本数据类型</p>
<p>void</p>
<pre><code class="java">//所有类型的Class
public class Test04{
    public static void main(String[] args){
        Class c1 = Object.class;
        Class c2 = Comparable.class;
        Class c3 = String[].class;
        Class c4 = int [][].class;
        Class c5 = Override.class;
        Class c6 = ElementType.class;//枚举
        Class c7 = Integer.class;
        Class c8 = void class;
        Class c9 = Class.class;
    }
}</code></pre>
<h2 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h2><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><ul>
<li>堆    <ul>
<li>存放new 的对象和数组</li>
<li>可以被所有线程共享，不会存放别的对象引用</li>
</ul>
</li>
<li>栈<ul>
<li>存放基本变量类型（会包含这个基础类型的具体数值）</li>
<li>引用对象的变量（会存放这个引用在堆里面的具体地址）</li>
</ul>
</li>
<li>方法区<ul>
<li>可以被所有的线程共享</li>
<li>包含了所有的class和static变量</li>
</ul>
</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul>
<li>类的加载（Load）：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。</li>
<li>类的链接（Link）：将类的二进制数据合并到JRE中。</li>
<li>类的初始化（Initialize）：JVM负责对类进行初始化。</li>
</ul>
<h3 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h3><ul>
<li>加载:将clas文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池的符号引用（常量名）替换为直接饮用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器&lt; clinit &gt;()方法的过程。类构造器&lt; clinit&gt;() 方法是由编译期自动收集类中所有类变量的复制动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ul>
<pre><code class="java">public class Test05{
    public static void main(String[] args){
        A a = new A();
        System.out.println(A,m);

        /*
        1.加载到内存，会产生一个类对应class对象
        2.链接，链接结束后  m = 0
        3.初始化
            &lt;clinit&gt;(){
                        System.out.println(&quot;A类静态代码块初始化&quot;);
                        m = 300;
                        m = 100;
            }

            m =100;

        */

    }
}

class A{
    static {
        System.out.println(&quot;A类静态代码块初始化&quot;);
        m = 300;
    }

    static int m = 100;

    public A(){
        System.out.println(&quot;A类的无参构造初始化&quot;);
    }
}</code></pre>
<h3 id="什么时候回发生类初始化"><a href="#什么时候回发生类初始化" class="headerlink" title="什么时候回发生类初始化"></a>什么时候回发生类初始化</h3><ul>
<li><p>类的主动引用（一定会发生类的初始化）</p>
<ul>
<li>当虚拟机启动，先初始化main方法所在的类。</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用。</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li>
</ul>
</li>
<li><p>类的被动引用（不会发生类的初始化）</p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用时，不会触发此类的初始化。</li>
<li>引用常量不会触发类的初始化，（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
</ul>
<pre><code class="java">//测试类什么时候会初始化
public class Test06{

    static {
        System.out.println(&quot;Main类被加载&quot;);
    }
    public static void main(String[] args){
        //1.主动调用
        Son son = new Son();
        //反射也会产生主动引用
        Class.forName(&quot;com.kuang.reflection.Son&quot;);

        //不会产生类的引用的方法
        System.out.println(Son.b);
    }

}

class Father{

    static int b = 2;
    static {
        System.out.println(&quot;父类被加载&quot;);
    }
}

class Son extends Father{
    static {
        System.out.println(&quot;子类被加载&quot;);
        m = 300;
    }

    static int m = 100;
    static final int M = 1;
}</code></pre>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时的数据结构，然后堆中生成一个代表这个类java.lang.Class对象，作为方法中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<p><strong>类加载器的作用</strong></p>
<ul>
<li>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，是来装载核心类库。该加载器无法直接获取。</li>
<li>扩展类加载器：负责jre/lib/ext目录下的jar包或_Djava.ext.dirs指定目录下的jar包装入工作库。</li>
<li>系统类加载器：负责Java-classpath 或_Djava.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。</li>
</ul>
<pre><code class="java">public class Test07{
    public static void main(String[] args){
        //获取系统类的加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //获取系统类加载的父类加载器--&gt;扩展类加载器
        ClassLOader parent = systemClassLoader.getParent();
        System.out.println(parent);

        //获取扩展类加载器的父类加载器
        ClassLoader parent1 = parent.getParent();
        System.out.println(parent1);

        //如何获得系统加载器可以加载的路径
        System.out.println(System.getProperty(&quot;java.class.path&quot;));

        //双亲委派机制:多层检测，检测安全性。



    }
}</code></pre>
<h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3><p><strong>获取运行时类的完整结构</strong></p>
<p>Field，Method，Constructor，Superclass，Interface，Annotaion</p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的Field</li>
<li>注解</li>
<li>。。。</li>
</ul>
<pre><code class="java">//获得类的信息
public class Test08{
    public static void main(String[] args){
        Class c1 = Class.forName(&quot;com.kuang.reflection.User&quot;);


        //获得类的名字
        System.out.println(c1.getName());//获得包名+类名
        System.out.println(c1.getSimpleName());//获得类名


        //获得类的属性
        System.out.println(&quot;===============&quot;);
        Field[] fields = c1.getFields();//只能找到public属性

        fields = c1.getDeclaredFields();
        for(Field field: field){
            System.out.println(field);
        }

        //获得指定属性的值
        Field name = c1.getDeclaredField(&quot;name&quot;);
        System.out.println(name);

        //获得类的方法

        Method[] methods = c1.getMethods();//获得本类及其父类的全部public 方法
        method = c1.getDeclareMethods();//获得本类的所有方法

        //获得指定方法
        //因为有重载，所以要写上参数类型
        Method getName = c1.getMethod(&quot;getName&quot;,null);
        Method setName = c1.getmethod(&quot;setName&quot;,String.class);

        //获得指定的构造器
        Constructor[] constructors = c1.getConstructors(String.class,int .class,int.class);
        System.out.println(&quot;指定:&quot;+declaredConstructor);
    }
}</code></pre>
<h2 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h2><h3 id="有了Class对象，可以做什么？"><a href="#有了Class对象，可以做什么？" class="headerlink" title="有了Class对象，可以做什么？"></a>有了Class对象，可以做什么？</h3><ul>
<li>创建类的对象:调用Class对象的newInstance（）方法<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ul>
</li>
</ul>
<p><strong>思考：难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</strong></p>
<ul>
<li>步骤如下<ul>
<li>通过Class类的getDeclaredConstructor（Class…parameterTypes）取得本类的指定形参类型的构造器。</li>
<li>向构造器的形参中传递一个数组对象进去，里面包含了构造器中所需的各个参数。</li>
<li>通过Constructor实例化对象</li>
</ul>
</li>
</ul>
<pre><code class="java">//动态的创建对象，通过反射
public class Test09{
    public static void main(String[] args){
        //获取Class对象
        Class c1 = Class.forName(&quot;com.kuang.reflection.User&quot;);
        //构造一个对象
        //User user = (User)c1.newInstance();//本质是调用了类的无参构造
        //System.out.println(user);


        //通过构造器创建对象
        Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class);
        User user2 = (User)constructor.newInstance(&quot;秦疆&quot;，001,18);
        System.out.println(user2);


        //通过反射调用普通方法
        User user3 = (User)c1.newInstance();
        //通过反射获取一个方法
        Method setName = c1.getDeclaredMethod(&quot;setName&quot;,String.class);

        //invoke:激活的意思
        //(对象，&quot;方法的值&quot;)
        setName.invoke(user3,&quot;狂神&quot;);
        System.out.println(user3.getName());

        //通过反射操作属性
        User user4 = (User)c1.newInstance();
        Field name = c1.getDeclaredField(&quot;name&quot;);

        //不能直接操作私有属性，我们需要关闭系统的安全监测，属性或者方法的setAccessible(true)
        name.setAccessible(true);
        name.set(user4,&quot;狂神2&quot;);
        System.out.println(user4.getName());
    }
}</code></pre>
<h3 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h3><p>通过反射，调用类中的方法，通过Method类完成。</p>
<ul>
<li>通过Class类的getMethod（String name,Class…parameterTypes）方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>之后使用Object invoke（Object obj,Object[]args）进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ul>
<p><strong>Object invoke （Object obj,Object…args）</strong></p>
<ul>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private，则需要在调用此invoke（）方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ul>
<p><strong>setAccessible</strong></p>
<ul>
<li>Method和Field，Constructor对象都有setAccessible（）方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，则该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问。</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施java语言访问检查。</li>
</ul>
<h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><pre><code class="java">//分析性能问题
public class Test10{
    //普通方式调用
    public static void test01(){
        User user = new User();

        long startTime = System.currentTimeMillis();

        for( int i = 0; i &lt; 100000; i++){
            user.getName();
        }

        long endTime = System.currentTimeMillis();

        System.out.println(&quot;普通方式执行10万次:&quot;+(endTime-startTime)+&quot;ms&quot;);
    }



    //反射方式调用
     public static void test02() throws NoSuchMethodException{
        User user = new User();

         Method getName = c1.getDeclaredMethod(&quot;getName&quot;,null);

        long startTime = System.currentTimeMillis();

        for( int i = 0; i &lt; 100000; i++){
            getName.invoke(user,null);
        }

        long endTime = System.currentTimeMillis();

        System.out.println(&quot;反射方式执行10万次:&quot;+(endTime-startTime)+&quot;ms&quot;);
    }


    //反射方式调用   关闭检测
         public static void test03() throws NoSuchMethodException{
        User user = new User();

         Method getName = c1.getDeclaredMethod(&quot;getName&quot;,null);
        getName.setAccessible(true);
        long startTime = System.currentTimeMillis();

        for( int i = 0; i &lt; 100000; i++){
            getName.invoke(user,null);
        }

        long endTime = System.currentTimeMillis();

        System.out.println(&quot;关闭检测后方式执行10万次:&quot;+(endTime-startTime)+&quot;ms&quot;);
    }
    public static void main(String[] args){
        test01();
        test02();
        test03();
    }

}</code></pre>
<h3 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h3><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
<li>为了通过反射操作这些类型，Java新增了ParametrizedType，GenercArrayType，TypeVariable和WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。</li>
</ul>
<pre><code class="java">ParameterizedType:表示一种参数化类型，比如Collection&lt;String&gt;

GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型

TypeVariable:是各种类型变量的公共父接口

WildcardType:代表一种通配符类型表达式</code></pre>
<h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><ul>
<li>getAnnotations</li>
<li>getAnnotation</li>
</ul>
<pre><code class="java">//反射操作注解
public class Test12{
    public static void main(String[] args){
        Class c1 = Class.forName(&quot;com.kuang.reflection.Student2&quot;);

        //通过反射获得注解
        Annotation[] annotations = c1.getAnnotations();
        for (Annotation anntation : annotations){
            System.out.println(annotation);
        }
        //获得注解的value的值
        Tablekuang tablekuang = (Tablekuang).c1.getAnnotation(Tablekuang.class);
        String value = tablekuang.value();
        System.out.println(value);

        //获得类指定的注解
        Field f = c1.getDeclaredField(&quot;name&quot;);
        Fieldkuang annotation = f.getAnnotation(Fieldkuang.class);
        System.out.println(annotation.columnName());
        System.out.println(annotation.type());
        System.out.println(annotation.length());
    }
}
@Tablekuang(&quot;db_student&quot;)
class Student2{
    @Fieldkuang(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)
    private int id;
    @Fieldkuang(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)
    private int age;
    @Fieldkuang(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)
    private String name;
    //无参构造
    public Student2(){

    }
    //有参构造
    //get，set
    //类名的注解
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Tablekuang{
        String value();
    }

    //属性的注解
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Filedkuang{
        String columnName();
        String type();
        int length();
    }
}</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javase_面向对象</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/23/Javase-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象<a id="more"></a></h1><p>Java的核心就是oop</p>
<h2 id="面向过程-amp-面向对象"><a href="#面向过程-amp-面向对象" class="headerlink" title="面向过程&amp;面向对象"></a>面向过程&amp;面向对象</h2><p>面向过程思想</p>
<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么</li>
<li>面对过程适合处理一些较为简单的问题</li>
</ul>
<p>面向对象思想</p>
<ul>
<li>物以类聚，分类的思维方式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考，最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题。</li>
</ul>
<p>对于描述复杂的事物，为了宏观上把握，从整体上能够合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向对象过程的思路去处理。</p>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li>面向对象编程（Object-Oriented Prpgramming,OOP）</li>
<li>面向对象编程的本质是：以类的方式组织代码，以对象的组织（封装）数据。</li>
<li>抽象</li>
<li><strong>三大特性</strong><ul>
<li><strong>封装</strong></li>
<li><strong>继承</strong></li>
<li><strong>多态</strong></li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。<ul>
<li><strong>对象</strong>：是具体的事物</li>
<li><strong>类</strong>：是抽象的，是对对象的抽象。</li>
</ul>
</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h2 id="回顾方法的定义"><a href="#回顾方法的定义" class="headerlink" title="回顾方法的定义"></a>回顾方法的定义</h2><pre><code class="java">//Demo01  类
public class Demo01{
    //main 方法
    public static void main (String[] args){


    }

    /*
    修饰符  返回值类型  方法名（...）{
    //方法体
    return  返回值；
    }
    */
    public String sayHello(){
        return &quot;hello,world&quot;;
    }

    public int max(int a,int b){
        return a&gt;b ? a : b;        
    }

}</code></pre>
<h3 id="break和return的区别"><a href="#break和return的区别" class="headerlink" title="break和return的区别"></a>break和return的区别</h3><ul>
<li>break: 跳出switch，结束循环</li>
<li>return: 结束方法，返回一个结果。</li>
</ul>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><ul>
<li>驼峰命名法</li>
<li>见名知意</li>
</ul>
<h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>（参数类型，参数名）….</p>
<h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><ul>
<li>静态方法  static</li>
<li>非静态方法</li>
</ul>
<pre><code class="java">//静态方法
public class Demo02{
    public static void main(String[] args){
        //静态方法调用非静态
        //实例化这个类   new
        //对象类型 对象名 = 对象值；
        Student student = new Student();
        student.say();
    }
}</code></pre>
<pre><code class="java">//非静态方法
public class Student{
    public void say(){
    System.out.println(&quot;学生说话了&quot;);
    }
}</code></pre>
<pre><code class="java">public class Demo02{
    public static void main(String[] args){...}//折叠了
    /*
    a，b都为静态方法,或都不为静态方法时，都可直接调用
    public void a(){
       b(); 
    };
    public void b(){};
    */
    //静态调用非静态时

    /*
    static是和类一起加载的
    public static void a(){
    b();
    //非静态，类实例化之后才存在
    public void b(){

    }
    }
    */
}</code></pre>
<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><pre><code class="java">public class Demo03{
    public static void main(String[] args){
        //实际参数和形式参数的类型要对应。
        int add = demo03.add(1,2);   //实参
        System.out.println(add);
    }
    //形参
    public static int add(int a,int b){
        return a+b;
    }
}</code></pre>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><pre><code class="java">//值传递
public class Demo04{
    public static void main(String[] args){
        int a = 1;
        System.out.println(a);
        Demo04.change(a);
        System.out.println(a);
    }
    //返回值为空
    public static void change(int a){
        a = 10;
    }
}</code></pre>
<pre><code class="java">//引用传递：对象，本质还是值传递
public class Demo05{
    public static void main(String[] args){
        Person perosn = new Perso();

        System.out.println(person.name);//null

        Demo05.change(person);

        System.out.println(person);//秦疆

    }
    public static void change(Person person){
        person.name = &quot;秦疆&quot;；
    } 
}
//定义了一个Person类，有一个属性：name
class Person{
    String name;//null
}</code></pre>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul>
<li><strong>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</strong><ul>
<li>动物，植物，手机，电脑。</li>
<li>Person类，Pet类，Car类，这些类都是用来定义某一类具体的事物应该具备的特点和行为。</li>
</ul>
</li>
<li><strong>对象是抽象类型的具体事例</strong><ul>
<li>张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体事例。</li>
<li>能够体现出特点，展现除功能的是具体的实例，而不是一个抽象的概念。</li>
</ul>
</li>
</ul>
<h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul>
<li><strong>使用new关键字创建对象</strong></li>
<li>使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类中的构造器也称为构造方法，是在进行创建对象的时候必须调用的。并且构造器有以下俩特点：<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回值类型，也不能写void</li>
</ul>
</li>
<li><strong>构造器必须要掌握。</strong></li>
</ul>
<pre><code class="java">//学生类
public class Stuent{
    //属性：字段
    String name;
    int age;
    //方法
    public void study(){
        System.out.println(&quot;学习&quot;);
    }
}</code></pre>
<pre><code class="java">//一个项目应该只有一个main方法
public class Appliction{
    public static void main(STring[] args){
        //类：抽象的，实例化
        //类实例化后会返回一个自己的对象
        //student对象就是一个student类的具体实例

        Student xiaoming = new Student();
        Student xiaohong = new Student();

        System.out.println(xiaoming.name);
    }
}</code></pre>
<p><strong>构造器</strong></p>
<p>   快捷键Alt + insert</p>
<p>使用new关键字时，本质是在调用构造器</p>
<p>构造器一般用来初始化值</p>
<ul>
<li>无参构造</li>
</ul>
<pre><code class="java">public class Person{
    //一个类即使什么也不写，也会存在一个方法
    //显示的定义构造器

    String name;
    //实例化初始值

    public Person (){
        this.name = &quot;qinjiang&quot;;        
    }
}</code></pre>
<pre><code class="java">public class Appliction{
    public static void main(STring[] args){
        Person person = new Person();

        System.out.println(person.name);//输出为qinjiang
    }
}</code></pre>
<ul>
<li>有参构造</li>
</ul>
<pre><code class="java">//一旦定义了有参构造，无参就必须显示定义
public Person (String name){
    this.name = name;
}</code></pre>
<h3 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h3><pre><code class="java">pubic class Application {
    public static void main(String[] args){
        Pet dog = new Pet();
        dog.name = &quot;旺财&quot;;
        dog.age = 3;
        dog.shout();

        System.out.println(dog.name);
        System.out.println(dog.age);
    }
}</code></pre>
<pre><code class="java">public class Pet{
    public String name;
    public int age;

    //无参构造
    public void shout(){
        System.out.println(&quot;叫了一声&quot;);
    }
}</code></pre>
<p>堆：存放new的对象和数组。</p>
<p>栈：存放基本变量类型和引用变量。</p>
<p><a href="https://www.wailian.work/image/QmvaGS" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/12/sp200823_233000.png" alt="sp200823_233000.png"></a></p>
<h3 id="简单小结类与对象"><a href="#简单小结类与对象" class="headerlink" title="简单小结类与对象"></a>简单小结类与对象</h3><pre><code class="java">public class Application {
    public static void main(String[] args){
        /*
        1.类与对象
            类是一个模板：抽象。对象是一个具体的实例
        2.方法
            定义，调用
        3.对象的引用
            引用类型：基本类型（8）
                对象是通过引用来操作的：栈---&gt;堆
        4.属性：字段Field 成员变量
            默认初始化：
                数字: 0   0.0 
                char: u0000
                boolbean: false
                引用: null


       修饰符   属性类型  属性名 = 属性值
         5.对象的创建和使用
             必须使用new关键字创建对象，构造器  Person kuangshen = new Person();
             对象的属性  kaungshen.name
             对象的方法   kuangshen.sleep()
         6.类
             静态的属性   属性
             动态的行为   方法



        */
    }
}</code></pre>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>该露的露，该藏的藏<ul>
<li>我们程序设计要追求 “高内聚，低耦合”。<ul>
<li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li>
<li>低耦合：仅暴露少量的方法给外部使用</li>
</ul>
</li>
</ul>
</li>
<li>封装（数据的隐藏）<ul>
<li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li>
</ul>
</li>
<li>属性私有(private)，get/set(提供可以操作私有属性的方法)</li>
</ul>
<pre><code class="java">public class Application {
    public static void main(String[] args){
        Student s1 = new Student();
        //通过调用setName方法来间接操作属性
        s1.setName(&quot;秦疆&quot;);
        System.out.println(s1.getName());
    }
}</code></pre>
<pre><code class="java">//类 private: 私有
public class Student{
    //属性私有
    private String name;      //名字
    private int id;            //学号
    private char sex;        //性别


    //提供一些可以操作这个属性的方法
    //提供一些public 的get，set方法
    //可在get，set方法中给属性限定范围（判断）


    //get  获得这个数据    
    public String getName(){
        return this.name;
    }

    //set  给这个数据设置值
    public void setName(String name){
        this.name  = name;
    }

}</code></pre>
<p>封装的意义</p>
<ul>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码的实现细节</li>
<li>统一接口</li>
<li>系统可维护增加了</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界而更好的建模。</li>
<li>extends的意思是扩展。子类是父类的拓展。</li>
<li>JAVA中类只有单继承，没有多继承。</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖，组合，聚合等。</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extend来表示。</li>
<li>子类和父类之间，从意义上讲应该具有“is  a”的关系。</li>
</ul>
<ul>
<li>object类</li>
</ul>
<p>所有的类，都默认直接或间接继承Object</p>
<ul>
<li>super</li>
<li>方法重写</li>
</ul>
<pre><code class="java">public class Person{
    public int money = 10000;

    public void say(){
        System.out.println(&quot;说了一句话&quot;);
    }
}</code></pre>
<pre><code class="java">//子类继承父类，就会拥有父类的全部方法
/*
    public 
    protected
    default
    private
*/
public class Student extends Person{

}</code></pre>
<pre><code class="java">public class Application {
    public static void main(String[] args){
        Student student = new Student();
        student.say();
    }
}</code></pre>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>子类调用父类</p>
<pre><code class="java">public class Application{
    public static void main(String[] args){
        Student student = new Student();
        student.test(&quot;秦疆&quot;);
    }
}</code></pre>
<pre><code class="java">public class Student extend Person{
    private String name = &quot;qinjiang&quot;;

    public void test(String name){
        System.out.println(name);//秦疆
        System.out.println(this.name);//秦疆
        System.out.println(super.name);//kuangshen
    }
}</code></pre>
<pre><code class="java">public class Person{
    protected String name = &quot;kuangshen&quot;;
    }
}</code></pre>
<p>继承过程中构造器的变化</p>
<pre><code class="java">public class Application{
    public static void main(String[] args){
        Student student = new Student();
        //执行结果
        //Person无参执行了
        //Student无参执行了
    }
}</code></pre>
<pre><code class="java">public class Student extends Person{
    public Student (){
        //隐藏代码:调用了父类的无参构造
        super();
        //调用父类的构造器，必须在子类构造器的第一行
        System.out.println(Student无参执行了)
    }
}</code></pre>
<pre><code class="java">public class Person(){
    public Person(){
        System.out.println(&quot;Person无参执行了&quot;)
    }
}</code></pre>
<p><strong>super注意点</strong></p>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super  必须只能出现在子类的方法或者构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<p><strong>super和this</strong></p>
<ul>
<li>代表的对象不同<ul>
<li>this：本身调用者这个对象</li>
<li>super：代表父类对象的应用</li>
</ul>
</li>
<li>前提<ul>
<li>this：没有继承也可以使用</li>
<li>super：只能在继承条件下才可以使用</li>
</ul>
</li>
<li>构造方法<ul>
<li>this（）：本类的构造</li>
<li>super（）：父类的构造</li>
</ul>
</li>
</ul>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><pre><code class="java">public class Application{
    public static void main(String[] args){

        //方法的调用只和左边定义的数据类型有关
        A a = new A();   //A
        a.test();
        //父类的引用指向了子类
        B b = new A();   //B    子类重写了父类的方法
        b.test();
    }
}</code></pre>
<pre><code class="java">public class A extends B{
    public static void test(){
        System.out.println(&quot;A=&gt;test()&quot;);
    }
}</code></pre>
<pre><code class="java">//重写是方法的重写，跟属性无关

public class B{
    public static void test(){
        System.out.println(&quot;B=&gt;test()&quot;);    }

}</code></pre>
<p><strong>重写</strong></p>
<p>需要有继承关系，子类重写父类的方法</p>
<p>重写：子类的方法和父类必须一致：方法体不同。</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大，但不可以缩小。</li>
<li>抛出的异常：范围可以被缩小，不能被扩大。</li>
</ul>
<p>为什么需要重写</p>
<ul>
<li>父类的功能，子类不一定需要，或者不满足</li>
<li>快捷键    Alt + Insrt：override;</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>动态编译：类型，可扩展</p>
</li>
<li><p>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</p>
</li>
<li><p>一个对象的实际类型是确定的，但可以指向对象的引用类型有很多。</p>
</li>
</ul>
<ul>
<li>多态存在的条件<ul>
<li>有继承关系</li>
<li>子类重写父类</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
<p>注意：多态是方法的多态，属性没有多态。</p>
<pre><code class="java">public class Person{
    public void run(){

    }

}</code></pre>
<pre><code class="java">public class Appliction{
    public static void main(String[] args){
        // new Student(); 一个对象的实际类型是确定的
        // new Person();
        //可以指向的引用类型就不确定了：父类的引用指向子类

        //Student 能调用的方法都是自己的或者继承父类的。
        Student s1 = new Student();
        //Person 父类型，可以指向子类，但是不能调用子类独有的方法
        Person s2 = new Student();  //父类的引用指向子类
        Object s3 = new Student();

        //对象能执行哪些方法，主要看对象左边的类型，和右边关系不大

        ((Student) s2).eat();//子类重写了父类的方法，执行子类的方法。
    }
}</code></pre>
<p>多态注意事项</p>
<ul>
<li>多态是方法的多态，属性没有多态</li>
<li>父类和子类，有联系。否则会类型转换异常</li>
<li>存在条件:继承关系，方法需要重写，父类引用指向子类对象。</li>
<li>不能重写的<ul>
<li>static  方法，属于类，不属于实例</li>
<li>final  常量</li>
<li>private 方法</li>
</ul>
</li>
<li>instanceof  类型转换..引用类型转换</li>
</ul>
<h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><pre><code class="java">public static void main(String[] args){
    //Object &gt; Person &gt; Student
    //Object &gt; Person &gt;Teacher
    //Object &gt; String
    Object object = new Student();

    //System.out.prinln( A instanceof B )AB间是否有父子关系
    System.out.prinln(object instanceof Student); //true
    System.out.prinln(object instanceof Person); //true
    System.out.prinln(object instanceof Object); //true
    System.out.prinln(object instanceof Teacher); //False
    System.out.prinln(object instanceof String); //False

}</code></pre>
<p><strong>类型转换</strong></p>
<pre><code class="java">public class Student extends Person{
    public void go(){
        System.out.println(&quot;go&quot;);
}</code></pre>
<pre><code class="java">public class Person{
    public void run(){
        System.out.println(&quot;run&quot;);
    }
}</code></pre>
<pre><code class="java">public class Appliction{
    public static void main(String[] args){
        //类型之间的转化：父类  子类
        //高         低
        Person student = new Student();
        //student 将这个对象转换为Student类型，我们就可以使用Student类型的方法了
        Student student = (Student) obj;
        student go();
        //((student) obj).go();


        //子类转换为父类，可能会丢失自己本来的一些方法。
        Student student = new Student();
        student.go();
        Person person = student;

    }
}</code></pre>
<ul>
<li>父类引用指向子类的对象</li>
<li>把子类转换为父类，向上转型</li>
<li>把父类转换为子类，向下转型：强制转换</li>
<li>方便方法的调用，减少重复的代码</li>
</ul>
<h3 id="static关键字详解"><a href="#static关键字详解" class="headerlink" title="static关键字详解"></a>static关键字详解</h3><pre><code class="java">public class Student{
    private static int age ;  //静态的变量 
    private double score;  //非静态的变量

    public static void main(String[] args){
        Student s1 = new Student();

        System.out.println(Student.age);  //可以通过类直接调用
        System.out.println(s1.age);
        System.out.println(s1.score);
    }

}</code></pre>
<pre><code class="java">public class Student {
    private static int age;
    private double score;

    public void run(){

    }

    public static void go(){

    }

    public static void main(String[] args){
       new Student().run();  //非静态需new
        student.go();        //静态直接调用
    }
}</code></pre>
<p>静态代码块</p>
<pre><code class="java">public class Person{
    //代码块  (匿名代码块)
}
    static {
        //静态代码块
        //类加载时执行，只执行一次
    }</code></pre>
<pre><code class="java">public class Person {
    {
        System.out.println(&quot;匿名代码块&quot;);
    }
    static {
        System.out.println(&quot;静态代码块&quot;);   //只执行一次
    }
    public Person(){
        System.out.println(&quot;构造方法&quot;);
    }
    public static void main(String[] args){
        Person person = new Person();
    }
}

//运行结果：静态代码块    匿名代码块      构造方法</code></pre>
<pre><code class="java">//静态导入包
//可直接调用
import static java.lang.Math.random;
import static java.lang.Math.PI;

public class Test{
    public static void main(String[] args){
        System.out.println(random());
        System.out.println(PI);
    }

}</code></pre>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果是修饰类，那么该类就是抽象类。</li>
<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类</li>
<li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</li>
<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li>
<li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</li>
</ul>
<pre><code class="java">//abstract 抽象类：类 extends：单继承~（接口可以多继承）

public abstract class Action{
    //约束~有人帮我们实现
    //abstract，抽象方法，只有方法名字，没有方法的实现。
    public abstract void doSomeThing();

}</code></pre>
<pre><code class="java">//抽象类的所有方法，继承了它的子类，都必须要实现他的方法
public class A extends Action {
    @override
    public void doSomething(){

    }
}</code></pre>
<p><strong>抽象类特点</strong></p>
<ul>
<li>不能new这个抽象类，只能考子类去实现：起一个约束作用。</li>
<li>抽象类中可以写普通的方法。</li>
<li>抽象方法必须在抽象类中。</li>
</ul>
<p>抽象的抽象：约束~</p>
<p>抽象类存在的意义：可以将重复的共有方法提取出来，提高开发效率。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范，自己无法写方法，专业的约束！约束和实现分离：面向接口编程。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中如果你是汽车，则必须能跑。</li>
<li>接口的本质是契约，就像我们人间的法律一样，制定好后大家遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针对具备了抽象能力的语言，就是因为设计模式所研究的，实际上就是如何合理的去抽象。</li>
</ul>
<p><strong>声明类的关键字是class，声明接口的关键字是interface</strong></p>
<pre><code class="java">public interface TimeService{
    void timer();
}</code></pre>
<pre><code class="java">//接口的定义 interface关键字    接口都需要实现类。
public interface UserService{
    //接口中的所有定义其实都是抽象的 public abstact
    void add(String name);
    void delete(String name);
    void update(String name);
    void query(String name);

}</code></pre>
<pre><code class="java">//类可以实现接口  implements 接口
//实现了接口的类，就需要重写接口中的方法。
public class UserServiceImpl implements UserService,TimeService{
    //利用接口实现多继承
    @override
    public void add(String name){

    }
     @override
    public void delete(String name){

    }
     @override
    public void update(String name){

    }
     @override
    public void query(String name){

    }
}</code></pre>
<p><strong>接口的作用：</strong></p>
<ul>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li>接口默认方法    public abstact</li>
<li>常量   public  static  final</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>implents可以实现多个接口</li>
<li>必须要重写接口中的方法</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<pre><code class="java">public class Application {
    public static void main(String[] args){

    }
}</code></pre>
<pre><code class="java">public class Outer{

    private int id;
    public void out;
        System.out.println(&quot;这是外部类的方法&quot;);

}
    class Inner{
        public void in(){
            System.out.println(&quot;这是内部类的方法&quot;);
        }

        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }</code></pre>
<pre><code class="java">public class Appliction{
    public static voud mai(String[] args){
        //new 
        Outer outer = new Outer();
        //通过外部类来实例化内部类
        outer.new Inner inner = outer.new Inner();
        inner.in();
    }
}</code></pre>
<pre><code class="java">puublic class Outer{
    //局部内部类
    publlic void method(){
        class Inner{
            public void in(){

            }
        }
    }

}
//一个java类中可以有多个class类，但是只能有一个public class
class A {
    public static void main(String[] args){

    }

}</code></pre>
<pre><code class="java">//匿名内部类
public class Test{
    public static void main(String[] args){
      //没有名字初始化类，不用将实例保存到变量中。
        new Apple().eat();
        UserService userService = new UserService(){
            @override
            public void hello(){

            }
        }
    }

}
class Apple{
    public void eat(){
        System.out.println(&quot;1&quot;);
    }
}
interface UserService{
    void hello();
}</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/Mr-lee-MQ.hithub.io/2020/05/30/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Maven项目管理工具"><a href="#Maven项目管理工具" class="headerlink" title="Maven项目管理工具"></a>Maven项目管理工具<a id="more"></a></h1><h2 id="为什么使用Maven？"><a href="#为什么使用Maven？" class="headerlink" title="为什么使用Maven？"></a>为什么使用Maven？</h2><ul>
<li><p>jar包管理</p>
<ul>
<li>从Maven中央仓库获取标准的规范的jar包以及相关依赖的jar包，避免自己下载到错误的jar包。</li>
<li>本地仓库统一管理jar包，使得jar包与项目分离，减轻项目体积。</li>
</ul>
</li>
<li><p>Maven是跨平台的可以在window、linux上使用。</p>
</li>
<li><p>清晰的项目结构</p>
</li>
<li><p>多工程开发，将模块拆分成若干个工程，利于团队协作开发。</p>
</li>
<li><p>一键构建项目：使用命令行可以对项目进行一键构建，操作系统中无需安装eclipse和tomcat。</p>
<h2 id="Maven入门"><a href="#Maven入门" class="headerlink" title="Maven入门"></a>Maven入门</h2></li>
<li><p>下载，安装，配置环境变量Maven；</p>
<ul>
<li><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a>     下载后解压，放到工作目录下。<ul>
<li>bin：配置文件，脚本</li>
<li>boot：类加载器的框架</li>
<li>conf：配置文件     sttings.xml主要用到的配置文件（全局配置）</li>
<li>lib：库文件</li>
</ul>
</li>
<li><img src="http://s1.wailian.download/2020/06/10/image-20200530172929530.png" alt="image-20200530172929530.png"></li>
</ul>
</li>
<li><p>变量值Maven安装路径到bin目录之前</p>
</li>
</ul>
<h2 id="Maven的优点"><a href="#Maven的优点" class="headerlink" title="Maven的优点"></a>Maven的优点</h2><ul>
<li><p>jar包管理</p>
<ul>
<li><p>从Maven中央仓库获取标准的规范的jar包以及相关依赖的jar包，避免自己下载到错误的jar包。</p>
</li>
<li><p>本地仓库统一管理jar包，使得jar包与项目分离，减轻项目体积。</p>
</li>
<li><p>Maven项目通过坐标的方式从本地仓库获取jar包</p>
<ul>
<li><p>坐标：由公司/组织名（groupld）+ 项目名/子项目名（artifactld）+版本号（version）组成。</p>
</li>
<li><p>本地仓库：存放了很多Jar包，供Maven项目使用。</p>
</li>
<li><p>Maven通过建立本地仓库索引，可以快速的找到符合要求的jar包，从而解决效率问题。</p>
</li>
<li><p>多个Maven项目都可以从本地仓库获取jar包</p>
</li>
<li><p>设置本地仓库：Maven根目录—–conf—-settings.xml，将localRepository标签中的路径替换成自己本地仓库的路径····</p>
<pre><code>localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Maven三中仓库概念"><a href="#Maven三中仓库概念" class="headerlink" title="Maven三中仓库概念"></a>Maven三中仓库概念</h2><p>本地仓库，远程仓库，中央仓库</p>
<p><a href="https://www.wailian.work/image/AjEarS" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200530175433411.png" alt="image-20200530175433411.png"></a></p>
<ul>
<li>中央仓库（MVN）<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></li>
</ul>
<p>优先级：本地—–远程—–中央                本地仓库没有也没有远程仓库，则直接去中央仓库找。</p>
<h2 id="设置阿里云Maven仓库镜像"><a href="#设置阿里云Maven仓库镜像" class="headerlink" title="设置阿里云Maven仓库镜像"></a>设置阿里云Maven仓库镜像</h2><ul>
<li>在settings.xml文件中的mirrors下添加mirror标签</li>
</ul>
<pre><code>&lt;mirror&gt;

&lt;id&gt;alimaven&lt;/id&gt;

&lt;name&gt;aliyun maven&lt;/name&gt;

&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;

&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;

&lt;/mirror&gt;</code></pre><ul>
<li>maven是由纯java开发，是跨平台的可以在window，linux，mac上使用</li>
<li>清晰的项目结构</li>
<li>使用Maven将大型项目按照模块拆分成若干工程，不同的团队维护各自的工程，可大大的提升开发效率。<ul>
<li>大型商城项目按业务分成商品管理，用户管理，订单管理等模块</li>
<li>中小型项目按照传统项目分为Web，Service，Dao层，依照员工的业务能力分配工作</li>
</ul>
</li>
</ul>
<h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><ul>
<li><p>mvn       命令（在工程目录下）</p>
</li>
<li><p>clean            清理</p>
</li>
<li><p>compile          编译，只编译main文件，不编译test中的代码（记得常clean）</p>
</li>
<li><p>test-compile    编译test目录中的代码 </p>
</li>
<li><p>package     打包           打包完的名字是由pom.xml中的(artifactId——version—-packaging)决定的</p>
<ul>
<li>Java项目—–打成jar包          </li>
<li>web项目—–打成war包</li>
</ul>
</li>
<li><p>install：    发布项目到本地仓库，用在打jar包上，打成jar包可以被其他项目使用</p>
</li>
<li><p>tomcat：run：    一键构建项目</p>
</li>
</ul>
<h2 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h2><ul>
<li>Clean       生命周期：clean</li>
<li>Default      生命周期：compile，test-compile，test，package，install</li>
<li>Silt              生命周期：site命令，生成项目描述文档静态页</li>
<li>不同的生命周期可以一起执行，例如先clean再compile</li>
</ul>
<h2 id="Maven命令的执行顺序"><a href="#Maven命令的执行顺序" class="headerlink" title="Maven命令的执行顺序"></a>Maven命令的执行顺序</h2><ul>
<li>在相同生命周期中的命令才会受执行顺序的影响</li>
<li>Default生命周期中的命令执行顺序：<ul>
<li>compile&lt;—test-compile&lt;—test&lt;—package&lt;—install</li>
</ul>
</li>
</ul>
<h2 id="Maven入门程序"><a href="#Maven入门程序" class="headerlink" title="Maven入门程序"></a>Maven入门程序</h2><ul>
<li><p>创建Maven项目</p>
</li>
<li><p><a href="https://www.wailian.work/image/AjEdI8" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200531132200007.png" alt="image-20200531132200007.png"></a></p>
</li>
<li><p><a href="https://www.wailian.work/image/AjE28B" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200531132333105.png" alt="image-20200531132333105.png"></a></p>
</li>
<li><p><a href="https://www.wailian.work/image/AjE9a0" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200531132454709.png" alt="image-20200531132454709.png"></a></p>
</li>
<li><p><a href="https://www.wailian.work/image/AjEW5l" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200531132531764.png" alt="image-20200531132531764.png"></a></p>
</li>
<li><p><a href="https://www.wailian.work/image/AjEN5b" target="_blank" rel="noopener"><img src="http://s1.wailian.download/2020/06/10/image-20200531115832479.png" alt="image-20200531115832479.png"></a></p>
</li>
<li><p><img src="http://s1.wailian.download/2020/06/10/sp200610_113715.png" alt="sp200610_113715.png"></p>
</li>
</ul>
<ul>
<li><p>在src—&gt;main–&gt;webapp下创建WEB-INF目录，并在目录下创建web.xml</p>
</li>
<li><p>修改Maven默认编译级别</p>
<ul>
<li>全局编译级别–&gt;修改settings.xml</li>
<li>项目级别修改–&gt;项目对应的pox.xml</li>
</ul>
</li>
<li><p>在Java Resourcese -&gt; src/main/java下写代码，创建包和Servlet；</p>
</li>
<li><p>添加servlet-api</p>
</li>
<li><p>在servlet-api中添加scope标签，值为：proviede；</p>
<ul>
<li>如果不加此标签有很大几率报错，因为tomcat中也有servlet-api的包导致冲突；</li>
</ul>
</li>
<li><p>运行：发生错误，原因是maven默认使用tomcat6.xx，不支持@WebServle注解；</p>
<ul>
<li>解决方案1：需要去web.xml中配置Servlet;</li>
<li>解决方案2：配置高版本tomcat插件；</li>
</ul>
</li>
<li><p>最后测试，启动服务，在地址栏输入请求，显示结果；</p>
</li>
<li><p>报错可以更新Maven</p>
</li>
</ul>
<h2 id="IDEA-Maven设置"><a href="#IDEA-Maven设置" class="headerlink" title="IDEA Maven设置"></a>IDEA Maven设置</h2><ul>
<li><p>下载与配置Maven</p>
</li>
<li><p>建立Maven本地仓库</p>
</li>
<li><p>IDEA设置：</p>
<p>File-&gt;Settings-&gt;Build, Execute, Deployment-&gt;Build Tools-&gt;Maven<br>修改 Maven home directory: d:/software/apache-maven-3.5.0<br>修改 User settings file: D:\software\apache-maven-3.5.0\conf\settings.xml<br>Local repository 会被自动识别为 d:\maven\repository</p>
</li>
<li><p>新建项目</p>
<ul>
<li>左边选择Maven</li>
<li>勾选Create from archetype</li>
<li>选择org.apache.maven.archetypes:maven-archetype-quickstart</li>
<li>Maven项目创建后，IDEA还会做一些初始化的工作，那么需要点击右下角的 Import Changes</li>
</ul>
</li>
<li><p>Idea Maven增加Jar</p>
<ul>
<li>修改pom.xml</li>
<li><img src="http://s1.wailian.download/2020/06/10/5761.png" alt="5761.png"></li>
<li>在修改了pom.xml之后，IDEA上会弹出这么一个 Maven projects need to be imported，点击Import Changes</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/Mr-lee-MQ.hithub.io/2020/11/01/MySQL/</url>
    <content><![CDATA[<h1 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1.初识MySQL"></a>1.初识MySQL<a id="more"></a></h1><p>JavaEE：企业及开发  Web</p>
<p>前端（页面：展示，数据！）</p>
<p>后台（连接点：连接数据库JDBC，连接前端（控制，控制视图跳转，给前端传递数据））</p>
<p>数据库：（存数据，Txt，Excel，word）</p>
<h2 id="1-1、为什么学习数据库"><a href="#1-1、为什么学习数据库" class="headerlink" title="1.1、为什么学习数据库"></a>1.1、为什么学习数据库</h2><p>1.岗位需求</p>
<p>2.现在的世界，大数据时代</p>
<p>3.被迫需求：存数据  去IOE</p>
<p>==4.数据库是所有软件体系中最核心的存在==      DBA</p>
<h2 id="1-2、什么是数据库"><a href="#1-2、什么是数据库" class="headerlink" title="1.2、什么是数据库"></a>1.2、什么是数据库</h2><p>数据库（DB，DataBase）</p>
<p>概念：数据仓库，软件，安装在操作系统（Window，linux，mac…）之上，SQL（数据库的语句）可以存储大量数据。500万</p>
<p>作用：存储数据，管理数据</p>
<h2 id="1-3、数据库分类"><a href="#1-3、数据库分类" class="headerlink" title="1.3、数据库分类"></a>1.3、数据库分类</h2><p><strong>关系型数据：</strong>（SQL）</p>
<ul>
<li>MySQL，Oracle，Sql Server，DB2，SQLlite</li>
<li>通过表和表之间，行和列之间的关系进行数据的存储，学员表，考勤表。</li>
</ul>
<p><strong>非关系型数据库：</strong>（NoSQL）</p>
<ul>
<li>Redis，MongDB</li>
<li>非关系型数据库，对象存储，通过对象的自身的属性来决定。</li>
</ul>
<p>==DBMS（数据库管理系统）==</p>
<ul>
<li>数据库的管理软件，科学有效的管理我们的数据。维护和获取数据。</li>
<li>MySQL本质是数据库管理系统。</li>
</ul>
<h2 id="1-4、MySql"><a href="#1-4、MySql" class="headerlink" title="1.4、MySql"></a>1.4、MySql</h2><p>MySQL是一个<strong>关系型数据库管理系统</strong></p>
<h2 id="1-5、安装MySql"><a href="#1-5、安装MySql" class="headerlink" title="1.5、安装MySql"></a>1.5、安装MySql</h2><ul>
<li>尽量不要使用exe,注册表。</li>
<li>尽可能使用压缩包包装。</li>
<li>解压，把压缩包解压到自己的环境目录下。</li>
<li>配置环境变量</li>
<li>新建mysql配置文件ini</li>
</ul>
<pre><code class="java">[mysql]
#目录一定换成自己的
basedir = 目录
datadir = 目录
port = 3306
skip-grant-tables</code></pre>
<ul>
<li>启动管理员下的CMD，并将路径切换至mysql下的bin目录，然后输入mysql-install（安装mysql）</li>
<li>再输入 nyaqld – initialize - insecure – user-mysql初始化数据文件。</li>
<li>然后再次启动mysql 然后用命令 mysql-u root -p 进入mysql管理界面（密码可为空）</li>
<li>启动mysql，进去修改密码。</li>
<li>修改my-ini文件删除最后一行skip-grant-tables</li>
<li>重启mysql即可正常使用</li>
</ul>
<h3 id="1-6-连接数据库"><a href="#1-6-连接数据库" class="headerlink" title="1.6 连接数据库"></a>1.6 连接数据库</h3><p><strong>命令行连接</strong></p>
<pre><code class="sql">mysql -uroot -p123456 --连接数据库

update mysql.user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; and Host = &#39;localhost&#39;;--修改密码权限
flush privileges;--刷新权限
-------------------------------------------------------------
--所有的语句用;结尾
show databases; --查看所有的数据库

mysql &gt; use school --切换数据库 use 数据库名

show tables; --查看数据库中所有的表
describe student; --显示数据库中所有的表的信息

create database westos;--创建一个数据库

exit;--退出连接

--单行注释（SQL的本来的注释）
</code></pre>
<p><strong>数据库语言</strong></p>
<p>DDL   定义</p>
<p>DML   操作</p>
<p>DQL   查询</p>
<p>DCL   控制</p>
<h2 id="2、操作数据库"><a href="#2、操作数据库" class="headerlink" title="2、操作数据库"></a>2、操作数据库</h2><p>操作数据库&gt;操作数据库中的表&gt;操作数据库中的表的数据</p>
<p>==SQL关键字不区分大小写==</p>
<h3 id="2-1、-操作数据库"><a href="#2-1、-操作数据库" class="headerlink" title="2.1、 操作数据库"></a>2.1、 操作数据库</h3><p>1.创建数据库</p>
<pre><code class="sql">CREATE DATABASE [IF NOT EXISTS] westos;</code></pre>
<p>2.删除数据库</p>
<pre><code class="sql">DROP DATABASE IF EXISTS westos;</code></pre>
<p>3.使用数据库</p>
<pre><code class="sql">--tab键的上面，如果你的表名或者字段名是一个特殊字符，就需要带这个
USE `westos`</code></pre>
<p>4.查看数据库</p>
<pre><code class="sql">SHOW DATABASES --查看所有的数据库</code></pre>
<p>对比：SQLyog的可视化操作。</p>
<p>学习思路：</p>
<ul>
<li>对照SQLyog可视化历史记录查看sql</li>
<li>固定的语法或关键字必须要记住</li>
</ul>
<h3 id="2-2、-数据库的数据类型"><a href="#2-2、-数据库的数据类型" class="headerlink" title="2.2、 数据库的数据类型"></a>2.2、 数据库的数据类型</h3><blockquote>
<p>数值</p>
</blockquote>
<ul>
<li>tinyint                 十分小的数据        1个字节</li>
<li>smallint             较小的数据             2个字节</li>
<li>mediumint       中等大小的数据     3个字节</li>
<li><strong>int                      标准的整数               4个字节</strong></li>
<li>bigint                  较大的数据               8个字节</li>
<li>float                    浮点数                      4个字节</li>
<li>double               浮点数                       8个字节 </li>
<li>decimal            字符串形式的浮点数                       </li>
</ul>
<blockquote>
<p>字符串</p>
</blockquote>
<ul>
<li><p>char                   字符串固定大小的       0~255       </p>
</li>
<li><p><strong>varchar           可变字符串                   0~25535         常用的变量    String</strong>     </p>
</li>
<li><p>tinytext              微型文本                      2^8 - 1</p>
</li>
<li><p><strong>text                  文本串                         2^16 - 1               保存大文本</strong></p>
</li>
</ul>
<blockquote>
<p>时间日期</p>
</blockquote>
<p>java.util.Date</p>
<ul>
<li><p>date     YYYY - MM - DD      日期格式</p>
</li>
<li><p>time     HH :  mm : ss         时间格式</p>
</li>
<li><p><strong>datetime     YYYY - MM - DD  HH : mm : ss    最常用的时间格式</strong>   </p>
</li>
<li><p>*<em>timestrmp       时间戳        1970.1.1到现在的毫秒数 *</em></p>
</li>
<li><p>year     年份表示</p>
</li>
</ul>
<blockquote>
<p>null</p>
</blockquote>
<ul>
<li>没有值，未知</li>
<li>==注意，不要使用NULL进行运算，结果为NULL==</li>
</ul>
<h3 id="2-3、数据库的字段属性（重点）"><a href="#2-3、数据库的字段属性（重点）" class="headerlink" title="2.3、数据库的字段属性（重点）"></a>2.3、数据库的字段属性（重点）</h3><p>Unsigned：</p>
<ul>
<li>无符号的整数</li>
<li>声明了该列不能声明为负数</li>
</ul>
<p>zerofill:</p>
<ul>
<li>0填充的</li>
<li>不足的位数，使用0来填充，int(3)</li>
</ul>
<p>自增:</p>
<ul>
<li>通常理解为自增，自动在上一条记录的基础上 + 1</li>
<li>通常用来设计唯一的主键~index，必须是整数类型</li>
<li>可以自定义设计主键自增的起始值和步长</li>
</ul>
<p>非空 NULL  NOT NULL</p>
<ul>
<li>假设设置为 not null，如果不给他赋值，就会报错。</li>
<li>NULL，如果不填写值，默认就是null</li>
</ul>
<p>默认:</p>
<ul>
<li>设置默认的值</li>
<li>sex，默认值为男。 </li>
</ul>
<pre><code>//每一个表必须存在这5个字段，表示一个记录存在的意义
id        主键
`version`        乐观锁
is_delete        伪删除
get_create        创建时间
get update        修改时间</code></pre><h3 id="2-4、创建数据库表"><a href="#2-4、创建数据库表" class="headerlink" title="2.4、创建数据库表"></a>2.4、创建数据库表</h3><pre><code class="sql">--目标：创建一个school数据库
--创建学生表（列，字段）  使用SQL创建
--学号int 登录密码varchar(20) 姓名，性别varchar(2),出生日期(datatime),家庭住址，email

--注意点，使用英文(),表的名称 和 字段 尽量使用``括起来
--AUTO INCREMENT 自增
CREATE TABLE IF NOT EXISTS `student`(
    `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,
    `name` VARCHAR(30) not NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,
    PRIMARY KEY(&#39;id&#39;)
)ENGINE = INNODB DEFAULT CHARSET=utf8</code></pre>
<p>格式：</p>
<pre><code class="sql">CREATE TABLE [IF NOT EXISTS] `表名`(
`字段名` 列类型 [属性] [索引] [注释],
`字段名` 列类型 [属性] [索引] [注释],
`字段名` 列类型 [属性] [索引] [注释],
    ....
`字段名` 列类型 [属性] [索引] [注释],    
)[表类型][字符集设置][注释]</code></pre>
<p><strong>常用命令</strong></p>
<pre><code class="sql">SHOW CREATE DATABASE scfool        --查看创建数据库的语句
SHOW CREATE TABLE student         --查看student数据表的定义语句
DESC student                     --显示表的结构</code></pre>
<h3 id="2-5、数据表的类型"><a href="#2-5、数据表的类型" class="headerlink" title="2.5、数据表的类型"></a>2.5、数据表的类型</h3><pre><code class="sql">--关于数据库引擎
/*
INNODBS  默认使用
MYISAM    早些年使用
*/</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>MYISAM</th>
<th>INNODB</th>
</tr>
</thead>
<tbody><tr>
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据行锁定</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>外键约束</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表空间大小</td>
<td>较小</td>
<td>较大</td>
</tr>
</tbody></table>
<p>常规的使用操作：</p>
<ul>
<li>MYIASM      节约空间，速度较快</li>
<li>INNNODB    安全性高，事务的处理，多表多用户操作</li>
</ul>
<blockquote>
<p>在物理空间存在的位置</p>
</blockquote>
<p>所有的数据库文件都存在data目录下</p>
<p>本质还是文件的存储</p>
<p>MySQL引擎在物理文件上的区别</p>
<ul>
<li>innoDB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件</li>
<li>MYISAM对应文件<ul>
<li>*.frm     表结构的定义文件</li>
<li>*.MYD    数据文件(data)</li>
<li>*.MYI      索引文件(index)</li>
</ul>
</li>
</ul>
<blockquote>
<p>设置数据库的字符集编码</p>
</blockquote>
<pre><code class="sql">CHARSET=utf8</code></pre>
<p>不设置的话，会是mysql默认的字符集编码（不支持中文）</p>
<p>MySQL的默认编码是Latin1，不支持中文</p>
<p>在my.ini中配置默认的编码</p>
<pre><code class="sql">character-set-server=utf8</code></pre>
<h3 id="2-6、修改和删除表"><a href="#2-6、修改和删除表" class="headerlink" title="2.6、修改和删除表"></a>2.6、修改和删除表</h3><blockquote>
<p>修改</p>
</blockquote>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/Mr-lee-MQ.hithub.io/2021/02/19/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合<a id="more"></a></h1><h2 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h2><h3 id="1-1、环境："><a href="#1-1、环境：" class="headerlink" title="1.1、环境："></a>1.1、环境：</h3><ul>
<li>IDEA</li>
<li>MySQL5.5</li>
<li>Tomcat 8</li>
<li>Maven 3.6</li>
</ul>
<h3 id="1-2、要求："><a href="#1-2、要求：" class="headerlink" title="1.2、要求："></a>1.2、要求：</h3><ul>
<li>需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；</li>
</ul>
<h3 id="1-3、数据库环境"><a href="#1-3、数据库环境" class="headerlink" title="1.3、数据库环境"></a>1.3、数据库环境</h3><pre><code class="sql">CREATE DATABASE `ssmbuild`;
USE `ssmbuild`;
DROP TABLE IF EXISTS `books`;
CREATE TABLE `books` (
`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,
`bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,
`bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,
`detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,
KEY `bookID` (`bookID`)
) ENGINE=INNODB DEFAULT CHARSET=utf8
INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES
(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),
(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),
(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);</code></pre>
<h2 id="2、基本环境搭建"><a href="#2、基本环境搭建" class="headerlink" title="2、基本环境搭建"></a>2、基本环境搭建</h2><ul>
<li>新建一Maven项目!，project目录上右键 -&gt; Add Frameworks Support -&gt; Web Application</li>
</ul>
<h4 id="2-1、导入相关的pom依赖！-当前项目使用"><a href="#2-1、导入相关的pom依赖！-当前项目使用" class="headerlink" title="2.1、导入相关的pom依赖！(当前项目使用)"></a>2.1、导入相关的pom依赖！(<strong>当前项目使用</strong>)</h4><pre><code class="xml">    &lt;dependencies&gt;
        &lt;!--Junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Servlet - JSP --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;RELEASE&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h4 id="2-2、导入相关的pom约束其二（黑马总结的比较规范）"><a href="#2-2、导入相关的pom约束其二（黑马总结的比较规范）" class="headerlink" title="2.2、导入相关的pom约束其二（黑马总结的比较规范）:"></a>2.2、导入相关的pom约束其二（<strong>黑马总结的比较规范</strong>）:</h4><pre><code class="xml">    &lt;properties&gt;
        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
        &lt;oracle.version&gt;11.2.0.1.0&lt;/oracle.version&gt;
        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;
        &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;        &lt;!-- spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.6.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;        &lt;!-- log start --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;${log4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;        &lt;!-- log end --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;c3p0&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.1.2&lt;/version&gt;
            &lt;type&gt;jar&lt;/type&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;5.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.oracle&lt;/groupId&gt;
            &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;
            &lt;version&gt;${oracle.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
            &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;source&gt;1.8&lt;/source&gt;
                        &lt;target&gt;1.8&lt;/target&gt;
                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                        &lt;showWarnings&gt;true&lt;/showWarnings&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
</code></pre>
<h4 id="2-3、Maven静态资源过滤设置：pom-xml中添加"><a href="#2-3、Maven静态资源过滤设置：pom-xml中添加" class="headerlink" title="2.3、Maven静态资源过滤设置：pom.xml中添加"></a>2.3、Maven静态资源过滤设置：pom.xml中添加</h4><pre><code class="xml">&lt;build&gt;
   &lt;resources&gt;
       &lt;resource&gt;
           &lt;directory&gt;src/main/java&lt;/directory&gt;
           &lt;includes&gt;
               &lt;include&gt;**/*.properties&lt;/include&gt;
               &lt;include&gt;**/*.xml&lt;/include&gt;
           &lt;/includes&gt;
           &lt;filtering&gt;false&lt;/filtering&gt;
       &lt;/resource&gt;
       &lt;resource&gt;
           &lt;directory&gt;src/main/resources&lt;/directory&gt;
           &lt;includes&gt;
               &lt;include&gt;**/*.properties&lt;/include&gt;
               &lt;include&gt;**/*.xml&lt;/include&gt;
           &lt;/includes&gt;
           &lt;filtering&gt;false&lt;/filtering&gt;
       &lt;/resource&gt;
   &lt;/resources&gt;
&lt;/build&gt;</code></pre>
<p><strong>注意事项</strong>：如果maven项目不是使用骨架创建，需要额外导入依赖的jar包，否则会报找不到class文件异常</p>
<p><strong>导入方式</strong>：file-&gt;project structure-&gt;artifacts-&gt;output layout-&gt;WEB-INF下创建lib并点击add copy of（一个+号按钮）导入所有jar包</p>
<h4 id="2-5、建立基本结构和配置框架！"><a href="#2-5、建立基本结构和配置框架！" class="headerlink" title="2.5、建立基本结构和配置框架！"></a>2.5、建立基本结构和配置框架！</h4><ul>
<li>com.kuang.pojo</li>
<li>com.kuang.mapper</li>
<li>com.kuang.service</li>
<li>com.kuang.controller</li>
</ul>
<h5 id="2-5-1、mybatis-config-xml"><a href="#2-5-1、mybatis-config-xml" class="headerlink" title="2.5.1、mybatis-config.xml"></a>2.5.1、mybatis-config.xml</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE configuration
               PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
               &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;</code></pre>
<h5 id="2-5-2、applicationContext-xml"><a href="#2-5-2、applicationContext-xml" class="headerlink" title="2.5.2、applicationContext.xml"></a>2.5.2、applicationContext.xml</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;</code></pre>
<h5 id="2-5-3、log4j-properties"><a href="#2-5-3、log4j-properties" class="headerlink" title="2.5.3、log4j.properties"></a>2.5.3、log4j.properties</h5><pre><code class="properties"># Set root category priority to INFO and its only appender to CONSOLE.
#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
log4j.rootCategory=debug, CONSOLE, LOGFILE
# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE
# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
# LOGFILE is set to be a File appender using a PatternLayout.
# log4j.appender.LOGFILE=org.apache.log4j.FileAppender
# log4j.appender.LOGFILE.File=d:\axis.log
# log4j.appender.LOGFILE.Append=true
# log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
# log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</code></pre>
<h2 id="3、Mybatis层编写"><a href="#3、Mybatis层编写" class="headerlink" title="3、Mybatis层编写"></a>3、Mybatis层编写</h2><h3 id="3-1、数据库配置文件-database-properties"><a href="#3-1、数据库配置文件-database-properties" class="headerlink" title="3.1、数据库配置文件 database.properties"></a>3.1、数据库配置文件 database.properties</h3><pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root</code></pre>
<h3 id="3-2、IDEA关联数据库"><a href="#3-2、IDEA关联数据库" class="headerlink" title="3.2、IDEA关联数据库"></a>3.2、IDEA关联数据库</h3><h3 id="3-3、编写MyBatis的核心配置文件"><a href="#3-3、编写MyBatis的核心配置文件" class="headerlink" title="3.3、编写MyBatis的核心配置文件"></a>3.3、编写MyBatis的核心配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
    &lt;/settings&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;mappers&gt;
        &lt;package name=&quot;com.kuang.mapper&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<h3 id="3-4、编写数据库对应的实体类-com-kuang-pojo-Books"><a href="#3-4、编写数据库对应的实体类-com-kuang-pojo-Books" class="headerlink" title="3.4、编写数据库对应的实体类 com.kuang.pojo.Books"></a>3.4、编写数据库对应的实体类 com.kuang.pojo.Books</h3><p>使用lombok插件！</p>
<pre><code class="java">package com.kuang.pojo;
import lombok.Data;
@Data
public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;
}</code></pre>
<h3 id="3-5、编写Dao层的-Mapper接口！"><a href="#3-5、编写Dao层的-Mapper接口！" class="headerlink" title="3.5、编写Dao层的 Mapper接口！"></a>3.5、编写Dao层的 Mapper接口！</h3><pre><code class="java">package com.kuang.mapper;
import com.kuang.pojo.Books;
import java.util.List;
public interface BookMapper {
    //增加一个Book
    int addBook(Books book);
    //根据id删除一个Book
    int deleteBookById(int id);
    //更新Book
    int updateBook(Books books);
    //根据id查询,返回一个Book
    Books queryBookById(int id);
    //查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();
}</code></pre>
<h3 id="3-6、编写接口对应的-BookMapper-xml-文件。需要导入MyBatis的包"><a href="#3-6、编写接口对应的-BookMapper-xml-文件。需要导入MyBatis的包" class="headerlink" title="3.6、编写接口对应的 BookMapper.xml 文件。需要导入MyBatis的包"></a>3.6、编写接口对应的 BookMapper.xml 文件。需要导入MyBatis的包</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.BookMapper&quot;&gt;
   &lt;!--增加一个Book--&gt;
   &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;
      insert into ssmbuild.books(bookName,bookCounts,detail)
      values (#{bookName}, #{bookCounts}, #{detail})
   &lt;/insert&gt;
   &lt;!--根据id删除一个Book--&gt;
   &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;
      delete from ssmbuild.books where bookID=#{bookID}
   &lt;/delete&gt;
   &lt;!--更新Book--&gt;
   &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt;
      update ssmbuild.books
      set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail}
      where bookID = #{bookID}
   &lt;/update&gt;
   &lt;!--根据id查询,返回一个Book--&gt;
   &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;
      select * from ssmbuild.books
      where bookID = #{bookID}
   &lt;/select&gt;
   &lt;!--查询全部Book--&gt;
   &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt;
      SELECT * from ssmbuild.books
   &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h3 id="3-7、编写Service层的接口和实现类"><a href="#3-7、编写Service层的接口和实现类" class="headerlink" title="3.7、编写Service层的接口和实现类"></a>3.7、编写Service层的接口和实现类</h3><p>接口：</p>
<pre><code class="java">package com.kuang.service;
import com.kuang.pojo.Books;
import java.util.List;
public interface BookService {
    //增加一个Book
    int addBook(Books book);
    //根据id删除一个Book
    int deleteBookById(int id);
    //更新Book
    int updateBook(Books books);
    //根据id查询,返回一个Book
    Books queryBookById(int id);
    //查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();
}</code></pre>
<p>实现类：</p>
<pre><code class="java">package com.kuang.service.impl;
import com.kuang.mapper.BookMapper;
import com.kuang.pojo.Books;
import com.kuang.service.BookService;
import java.util.List;
public class BookServiceImpl implements BookService {
    //调用dao层的操作，后面用自动注入
    private BookMapper bookMapper;
    public int addBook(Books book) {
        return bookMapper.addBook(book);
    }
    public int deleteBookById(int id) {
        return bookMapper.deleteBookById(id);
    }
    public int updateBook(Books books) {
        return bookMapper.updateBook(books);
    }
    public Books queryBookById(int id) {
        return bookMapper.queryBookById(id);
    }
    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }
}</code></pre>
<h5 id="OK，到此，底层需求操作编写完毕！"><a href="#OK，到此，底层需求操作编写完毕！" class="headerlink" title="OK，到此，底层需求操作编写完毕！"></a>OK，到此，底层需求操作编写完毕！</h5><h2 id="4、Spring层"><a href="#4、Spring层" class="headerlink" title="4、Spring层"></a>4、Spring层</h2><h3 id="4-1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；"><a href="#4-1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；" class="headerlink" title="4.1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；"></a>4.1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；</h3><h3 id="4-2、编写Spring整合Mybatis的相关的配置文件-spring-dao-xml"><a href="#4-2、编写Spring整合Mybatis的相关的配置文件-spring-dao-xml" class="headerlink" title="4.2、编写Spring整合Mybatis的相关的配置文件: spring-dao.xml"></a>4.2、编写Spring整合Mybatis的相关的配置文件: spring-dao.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
   &lt;!-- 配置整合mybatis --&gt;
   &lt;!-- 1.关联数据库文件 --&gt;
   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
   &lt;!-- 2.数据库连接池 --&gt;
   &lt;!--数据库连接池
       dbcp 半自动化操作 不能自动连接
       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）
   --&gt;
   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
       &lt;!-- 配置连接池属性 --&gt;
       &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;
       &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;
       &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;
       &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
       &lt;!-- c3p0连接池的私有属性 --&gt;
       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
       &lt;!-- 关闭连接后不自动commit --&gt;
       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
       &lt;!-- 获取连接超时时间 --&gt;
       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
       &lt;!-- 当获取连接失败重试次数 --&gt;
       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
   &lt;/bean&gt;
   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;
   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
       &lt;!-- 注入数据库连接池 --&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;
       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
   &lt;/bean&gt;
   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;
   &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;
   &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
       &lt;!-- 注入sqlSessionFactory --&gt;
       &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
       &lt;!-- 给出需要扫描mapper接口包 --&gt;
       &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.mapper&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<h3 id="4-3、Spring整合service层"><a href="#4-3、Spring整合service层" class="headerlink" title="4.3、Spring整合service层"></a>4.3、Spring整合service层</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 扫描service相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.service.impl&quot; /&gt;
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;
    &lt;!--结合aop实现事务织入--&gt;
    &lt;!--配置事务的通知类--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;!--给哪些方法配置事务--&gt;
        &lt;!--新东西：配置事务的传播特性 propagation--&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;
            &lt;!-- *号包含上面4个方法：
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; --&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;!--配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txpointcut&quot; expression=&quot;execution(* com.kuang.service.impl.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txpointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;</code></pre>
<h3 id="4-4、Spring和mybatis的自动注入和依赖都加上"><a href="#4-4、Spring和mybatis的自动注入和依赖都加上" class="headerlink" title="4.4、Spring和mybatis的自动注入和依赖都加上"></a>4.4、Spring和mybatis的自动注入和依赖都加上</h3><h2 id="5、SpringMVC层"><a href="#5、SpringMVC层" class="headerlink" title="5、SpringMVC层"></a>5、SpringMVC层</h2><h3 id="5-1、web-xml"><a href="#5-1、web-xml" class="headerlink" title="5.1、web.xml"></a>5.1、web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;!--DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;!--encodingFilter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;!--Session过期时间--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;</code></pre>
<h3 id="5-2、spring-mvc-xml"><a href="#5-2、spring-mvc-xml" class="headerlink" title="5.2、spring-mvc.xml"></a>5.2、spring-mvc.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/mvc
   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 配置SpringMVC --&gt;
    &lt;!-- 1.开启SpringMVC注解驱动 --&gt;
    &lt;mvc:annotation-driven /&gt;
    &lt;!-- 2.静态资源默认servlet配置--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 4.扫描web相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;
&lt;/beans&gt;</code></pre>
<h3 id="5-3、Spring配置整合文件，applicationContext-xml"><a href="#5-3、Spring配置整合文件，applicationContext-xml" class="headerlink" title="5.3、Spring配置整合文件，applicationContext.xml"></a>5.3、Spring配置整合文件，applicationContext.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;import resource=&quot;spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;</code></pre>
<h2 id="6、配置文件，暂时结束！Controller-和-视图层编写"><a href="#6、配置文件，暂时结束！Controller-和-视图层编写" class="headerlink" title="6、配置文件，暂时结束！Controller 和 视图层编写"></a>6、配置文件，暂时结束！Controller 和 视图层编写</h2><h3 id="6-1、BookController-类编写-，-方法一：查询全部书籍"><a href="#6-1、BookController-类编写-，-方法一：查询全部书籍" class="headerlink" title="6.1、BookController 类编写 ， 方法一：查询全部书籍"></a>6.1、BookController 类编写 ， 方法一：查询全部书籍</h3><pre><code class="java">package com.kuang.controller;
import com.kuang.pojo.Books;
import com.kuang.service.BookService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import java.util.List;
@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController {
    @Autowired
    private BookService bookService;
    @RequestMapping(&quot;/allBook&quot;)
    public String list(Model model) {
        List&lt;Books&gt; list = bookService.queryAllBook();
        model.addAttribute(&quot;list&quot;, list);
        return &quot;allBook&quot;;
    }
}</code></pre>
<h3 id="6-2、编写首页-index-jsp"><a href="#6-2、编写首页-index-jsp" class="headerlink" title="6.2、编写首页 index.jsp"></a>6.2、编写首页 index.jsp</h3><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;首页&lt;/title&gt;
   &lt;style type=&quot;text/css&quot;&gt;
       a {
           text-decoration: none;
           color: black;
           font-size: 18px;
      }
       h3 {
           width: 180px;
           height: 38px;
           margin: 100px auto;
           text-align: center;
           line-height: 38px;
           background: deepskyblue;
           border-radius: 4px;
      }
   &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;
   &lt;a href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;
&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="6-3、书籍列表页面-allbook-jsp"><a href="#6-3、书籍列表页面-allbook-jsp" class="headerlink" title="6.3、书籍列表页面 allbook.jsp"></a>6.3、书籍列表页面 allbook.jsp</h3><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;书籍列表&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;row&quot;&gt;
       &lt;div class=&quot;col-md-4 column&quot;&gt;
           &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增&lt;/a&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;table class=&quot;table table-hover table-striped&quot;&gt;
               &lt;thead&gt;
               &lt;tr&gt;
                   &lt;th&gt;书籍编号&lt;/th&gt;
                   &lt;th&gt;书籍名字&lt;/th&gt;
                   &lt;th&gt;书籍数量&lt;/th&gt;
                   &lt;th&gt;书籍详情&lt;/th&gt;
                   &lt;th&gt;操作&lt;/th&gt;
               &lt;/tr&gt;
               &lt;/thead&gt;
               &lt;tbody&gt;
               &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get(&#39;list&#39;)}&quot;&gt;
                   &lt;tr&gt;
                       &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                       &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                       &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                       &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                       &lt;td&gt;
                           &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.getBookID()}&quot;&gt;更改&lt;/a&gt; |
                           &lt;a href=&quot;${pageContext.request.contextPath}/book/del/${book.getBookID()}&quot;&gt;删除&lt;/a&gt;
                       &lt;/td&gt;
                   &lt;/tr&gt;
               &lt;/c:forEach&gt;
               &lt;/tbody&gt;
           &lt;/table&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="6-4、BookController-类编写-，-方法二：添加书籍"><a href="#6-4、BookController-类编写-，-方法二：添加书籍" class="headerlink" title="6.4、BookController 类编写 ， 方法二：添加书籍"></a>6.4、BookController 类编写 ， 方法二：添加书籍</h3><pre><code class="java">@RequestMapping(&quot;/toAddBook&quot;)
public String toAddPaper() {
   return &quot;addBook&quot;;
}
@RequestMapping(&quot;/addBook&quot;)
public String addPaper(Books books) {
   System.out.println(books);
   bookService.addBook(books);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<h3 id="6-5、添加书籍页面：addBook-jsp"><a href="#6-5、添加书籍页面：addBook-jsp" class="headerlink" title="6.5、添加书籍页面：addBook.jsp"></a>6.5、添加书籍页面：addBook.jsp</h3><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;新增书籍&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;新增书籍&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;form action=&quot;${pageContext.request.contextPath}/book/addBook&quot; method=&quot;post&quot;&gt;
      书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
      书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
      书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
       &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
   &lt;/form&gt;
&lt;/div&gt;</code></pre>
<h3 id="6-6、BookController-类编写-，-方法三：修改书籍"><a href="#6-6、BookController-类编写-，-方法三：修改书籍" class="headerlink" title="6.6、BookController 类编写 ， 方法三：修改书籍"></a>6.6、BookController 类编写 ， 方法三：修改书籍</h3><pre><code class="java">@RequestMapping(&quot;/toUpdateBook&quot;)
public String toUpdateBook(Model model, int id) {
   Books books = bookService.queryBookById(id);
   System.out.println(books);
   model.addAttribute(&quot;book&quot;,books );
   return &quot;updateBook&quot;;
}
@RequestMapping(&quot;/updateBook&quot;)
public String updateBook(Model model, Books book) {
   System.out.println(book);
   bookService.updateBook(book);
   Books books = bookService.queryBookById(book.getBookID());
   model.addAttribute(&quot;books&quot;, books);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<h3 id="6-7、修改书籍页面-updateBook-jsp"><a href="#6-7、修改书籍页面-updateBook-jsp" class="headerlink" title="6.7、修改书籍页面 updateBook.jsp"></a>6.7、修改书籍页面 updateBook.jsp</h3><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;修改信息&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;修改信息&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;form action=&quot;${pageContext.request.contextPath}/book/updateBook&quot; method=&quot;post&quot;&gt;
       &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;${book.getBookID()}&quot;/&gt;
      书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;${book.getBookName()}&quot;/&gt;
      书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;${book.getBookCounts()}&quot;/&gt;
      书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;${book.getDetail() }&quot;/&gt;
       &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
   &lt;/form&gt;
&lt;/div&gt;</code></pre>
<h3 id="6-8、BookController-类编写-，-方法四：删除书籍"><a href="#6-8、BookController-类编写-，-方法四：删除书籍" class="headerlink" title="6.8、BookController 类编写 ， 方法四：删除书籍"></a>6.8、BookController 类编写 ， 方法四：删除书籍</h3><pre><code class="java">@RequestMapping(&quot;/del/{bookId}&quot;)
public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) {
   bookService.deleteBookById(id);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<p> 配置Tomcat，进行运行！</p>
]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/Mr-lee-MQ.hithub.io/2021/02/08/Mybatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis<a id="more"></a></h1><p><img src="https://mybatis.org/images/mybatis-logo.png" alt="MyBatis logo"></p>
<ul>
<li>MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</li>
<li>MyBatis 本是<a href="https://baike.baidu.com/item/apache/6265" target="_blank" rel="noopener">apache</a>的一个开源项目<a href="https://baike.baidu.com/item/iBatis" target="_blank" rel="noopener">iBatis</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到Github。</li>
</ul>
<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1-如何获取Mybatis"><a href="#1-1-如何获取Mybatis" class="headerlink" title="1.1 如何获取Mybatis"></a>1.1 如何获取Mybatis</h3><ul>
<li><p>中文文档： <a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
</li>
<li><p>Github： <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></p>
</li>
<li><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;</code></pre>
</li>
</ul>
<h3 id="1-2-持久化-和-持久层"><a href="#1-2-持久化-和-持久层" class="headerlink" title="1.2 持久化 和 持久层"></a>1.2 持久化 和 持久层</h3><p>数据持久化：</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>内存： 断电即失</li>
</ul>
<p>为什么需要持久化？</p>
<ul>
<li>有一些对象，不能丢掉</li>
<li>内存太贵</li>
</ul>
<p>Dao层，Service层，Controller层，，，</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界线十分明显</li>
</ul>
<h3 id="1-3-为什么使用Mybatis"><a href="#1-3-为什么使用Mybatis" class="headerlink" title="1.3 为什么使用Mybatis"></a>1.3 为什么使用Mybatis</h3><ul>
<li>帮助程序猿将数据存入到数据库中。</li>
<li>方便</li>
<li>传统的JDBC代码太复杂了。简化。框架。自动化。</li>
<li>不用Mybatis也可以。更容易上手。 <strong>技术没有高低之分</strong></li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。</li>
<li>解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
<h2 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h2><h3 id="2-1-编写mybatis的配置文件"><a href="#2-1-编写mybatis的配置文件" class="headerlink" title="2.1 编写mybatis的配置文件"></a>2.1 编写mybatis的配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSl=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--&gt;
    &lt;mappers&gt;
        &lt;!--resourc 路径一定要用/// 不能用...--&gt;
        &lt;mapper resource=&quot;com/susu/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<h4 id="不使用-XML-构建-SqlSessionFactory-不建议使用"><a href="#不使用-XML-构建-SqlSessionFactory-不建议使用" class="headerlink" title="不使用 XML 构建 SqlSessionFactory(不建议使用)"></a>不使用 XML 构建 SqlSessionFactory(不建议使用)</h4><pre><code class="java">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</code></pre>
<h3 id="2-2-编写mybatis工具类"><a href="#2-2-编写mybatis工具类" class="headerlink" title="2.2 编写mybatis工具类"></a>2.2 编写mybatis工具类</h3><pre><code class="java">public class MybatisUtils {
    private static  SqlSessionFactory sqlSessionFactory;
    static{
        String resource = &quot;mybatis-config.xml&quot;;
        try {
            //使用mybatis第一步，获取sqlsessionFactory对象
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession(){
        return sqlSessionFactory.openSession();
    }
}
</code></pre>
<h3 id="2-3-Dao接口"><a href="#2-3-Dao接口" class="headerlink" title="2.3 Dao接口"></a>2.3 Dao接口</h3><pre><code class="java">public interface UserDao {
    List&lt;User&gt; getUserList();
}</code></pre>
<h3 id="2-4-接口实现类由原来的UserDaoImpl转变为Mapper配置文件"><a href="#2-4-接口实现类由原来的UserDaoImpl转变为Mapper配置文件" class="headerlink" title="2.4 接口实现类由原来的UserDaoImpl转变为Mapper配置文件"></a>2.4 接口实现类由原来的UserDaoImpl转变为Mapper配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;
&lt;mapper namespace=&quot;com.susu.dao.UserDao&quot;&gt;
    &lt;!-- id对应方法名， resultType=绑定返回类型 --&gt;
    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.susu.pojo.User&quot;&gt;
        select * from mybatis.muser
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><pre><code class="java">public class UserDaoTest {
    @Test
    public void test() {
        //第一步：获取sqlsession对象
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        //执行sql
        UserDao userDao = sqlSession.getMapper(UserDao.class);
        List&lt;User&gt; userList = userDao.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }
        //方式二  已经过时
        List&lt;User&gt; list = sqlSession.selectList(&quot;com.susu.dao.UserDao.getUserList&quot;);
        sqlSession.close();
    }
}
</code></pre>
<p>遇到的问题，资源无法导入（maven由于他的约定大于配置，可能遇到写的配置文件无法导出或生效的问题），解决方案：</p>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;</code></pre>
<h3 id="2-6-对命名空间的一点补充"><a href="#2-6-对命名空间的一点补充" class="headerlink" title="2.6 对命名空间的一点补充"></a>2.6 <strong>对命名空间的一点补充</strong></h3><p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ul>
<li>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</li>
<li>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</li>
</ul>
<h2 id="3、作用域（Scope）和生命周期"><a href="#3、作用域（Scope）和生命周期" class="headerlink" title="3、作用域（Scope）和生命周期"></a>3、作用域（Scope）和生命周期</h2><p><img src="https://img-blog.csdnimg.cn/20201105214905865.png" alt="在这里插入图片描述"></p>
<p>不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><blockquote>
<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
</blockquote>
<ul>
<li>一旦创建了 SqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><blockquote>
<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
</blockquote>
<ul>
<li>可以想象为：数据库连接池</li>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或者重新创建另一个实例</strong></li>
<li>因此 SqlSessionFactory 的最佳作用域是应用作用域</li>
<li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式</li>
</ul>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><blockquote>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
</blockquote>
<ul>
<li>连接到连接池的一个请求！</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li>
<li>用完之后需要赶紧关闭，否则资源被占用！</li>
</ul>
<pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {
  // 你的应用逻辑代码
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201105215925916.png" alt="在这里插入图片描述"></p>
<p>这里面的每一个Mapper，就代表一个具体的业务</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  // 你的应用逻辑代码
}</code></pre>
<h2 id="4、CRUD"><a href="#4、CRUD" class="headerlink" title="4、CRUD"></a>4、CRUD</h2><h3 id="1-namespace"><a href="#1-namespace" class="headerlink" title="1. namespace"></a>1. namespace</h3><p>namespace中的包名要和Dao/Mapper接口的包名一致！</p>
<h3 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h3><p>选择，查询语句</p>
<ul>
<li>id： 对应的namespace中的方法名；</li>
<li>resultType： sql语句执行的返回值！</li>
<li>parameterType： sql语句的返回值类型！</li>
</ul>
<ol>
<li><p>编写接口</p>
<pre><code class="java">//根据ID查用户
User getUserById(int id);</code></pre>
</li>
<li><p>编写对应的Mapper中的sql语句</p>
<pre><code class="xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.susu.pojo.User&quot;&gt;
    select * from muser where id = #{id}
&lt;/select&gt;</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void  getUserById(){
    SqlSession sqlSession = MybatisUtils.getSqlSession();

    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    User user = mapper.getUserById(1);
    System.out.println(user);

    sqlSession.close();
}</code></pre>
</li>
</ol>
<h3 id="3-Insert"><a href="#3-Insert" class="headerlink" title="3. Insert"></a>3. Insert</h3><pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.susu.pojo.User&quot; &gt;
    insert into muser(id, name, pwd) values (#{id},#{name},#{pwd});
&lt;/insert&gt;</code></pre>
<h3 id="4-Update"><a href="#4-Update" class="headerlink" title="4. Update"></a>4. Update</h3><pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.susu.pojo.User&quot;&gt;
    update muser set name = #{name},pwd=#{pwd} where id=#{id};
&lt;/update&gt;</code></pre>
<h3 id="5-Delete"><a href="#5-Delete" class="headerlink" title="5. Delete"></a>5. Delete</h3><pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from muser where id=#{id};
&lt;/delete&gt;</code></pre>
<p>注意：</p>
<p>增删改需要提交事务</p>
<ul>
<li><p>手动提交</p>
<pre><code class="java">sqlSession.commit();</code></pre>
</li>
<li><p>设置自动提交</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201108155726930.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="6-思考：模糊查询怎么写"><a href="#6-思考：模糊查询怎么写" class="headerlink" title="6. 思考：模糊查询怎么写"></a>6. 思考：模糊查询怎么写</h3><ol>
<li><p>Java代码执行的时候，传递通配符%%</p>
<pre><code class="java">List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;);</code></pre>
</li>
<li><p>在sql拼接中使用通配符</p>
<pre><code class="java">select * from muser where name like &quot;%&quot;#{value}&quot;%&quot;;</code></pre>
</li>
</ol>
<h2 id="5、配置详解"><a href="#5、配置详解" class="headerlink" title="5、配置详解"></a>5、配置详解</h2><h3 id="1-核心配置（configuration）"><a href="#1-核心配置（configuration）" class="headerlink" title="1. 核心配置（configuration）"></a>1. 核心配置（configuration）</h3><ul>
<li><p>mybatis-config.xml</p>
</li>
<li><p>Mybatis的配置文件包含了会深深影响Mybatis行为的设置和属性信息</p>
<pre><code class="xml">properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）</code></pre>
</li>
</ul>
<h3 id="2-环境配置（environments）"><a href="#2-环境配置（environments）" class="headerlink" title="2. 环境配置（environments）"></a>2. 环境配置（environments）</h3><p>mybatis可以配置多个环境</p>
<ul>
<li><strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></li>
</ul>
<p>Mybatis默认的事务管理器就是JDBC， 连接池：POOLED</p>
<h3 id="3-属性（Properties）"><a href="#3-属性（Properties）" class="headerlink" title="3. 属性（Properties）"></a>3. 属性（Properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】</p>
<p><img src="https://img-blog.csdnimg.cn/20201105204653974.png" alt="在这里插入图片描述"></p>
<p>编写一个配置文件</p>
<p>db.properties</p>
<pre><code class="java">driver = com.mysql.jdbc.Driver
url = jdbc:mysql://localhost:3306/mybatis?useSSl=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8
username = root
password = root</code></pre>
<p>在核心配置文件中引入</p>
<pre><code class="xml">&lt;properties resource=&quot;db.properties&quot;&gt;
    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;
&lt;/properties&gt;</code></pre>
<ul>
<li>可以直接引入外部文件</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一个字段，优先实用外部配置文件的！</li>
</ul>
<h3 id="4-类型别名（typeAliases）"><a href="#4-类型别名（typeAliases）" class="headerlink" title="4. 类型别名（typeAliases）"></a>4. 类型别名（typeAliases）</h3><ul>
<li><p>类型别名是为Java类型设置一个短的名字</p>
</li>
<li><p>存在的意义仅在于用来减少类完全限定名的冗余</p>
<pre><code class="xml">&lt;!--可以给实体类起别名--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.susu.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
</li>
</ul>
<p>也可以指定一个报名，Mybatis会在包名下搜索需要的Java Bean，比如：</p>
<p>扫描实体类的包，他的默认别名就位这个类的 类名，首字母小写</p>
<pre><code class="xml">&lt;typeAliases&gt;
  &lt;package name=&quot;com.susu.pojo&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
<p>在实体类表较少的时候使用第一种</p>
<p>如果实体类十分多，建议使用第二种</p>
<p>第一种可以DIY别名，第二种则 不行， 如果要改 需要用注解</p>
<ul>
<li><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class Author {
    ...
}</code></pre>
</li>
</ul>
<h3 id="5-设置（settings）"><a href="#5-设置（settings）" class="headerlink" title="5. 设置（settings）"></a>5. 设置（settings）</h3><p>这是Mybatis中极为重要的调整设置，他们会改变Mybatis的运行时行为</p>
<p><img src="https://img-blog.csdnimg.cn/20201105212101118.png" alt="在这里插入图片描述"></p>
<h3 id="6-其他配置"><a href="#6-其他配置" class="headerlink" title="6. 其他配置"></a>6. 其他配置</h3><ul>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h3 id="7-映射器（mappers）"><a href="#7-映射器（mappers）" class="headerlink" title="7. 映射器（mappers）"></a>7. 映射器（mappers）</h3><p>注册绑定Mapper文件</p>
<p>方式一: 【推荐使用】</p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;com/susu/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<p>方式二： 使用class文件绑定注册</p>
<pre><code class="xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;com.susu.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<p>注意点：</p>
<ul>
<li>接口和他的Mapper配置文件必须同名！</li>
<li>接口和他的Mapper配置文件必须在同一个包下！</li>
</ul>
<p>方式三：使用扫描包进行注册绑定</p>
<pre><code class="xml">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;com.susu.dao&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<h2 id="6、解决属性名和字段名不一致的问题"><a href="#6、解决属性名和字段名不一致的问题" class="headerlink" title="6、解决属性名和字段名不一致的问题"></a>6、解决属性名和字段名不一致的问题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>数据库中的字段</p>
<p><img src="https://img-blog.csdnimg.cn/2020110522014864.png" alt="在这里插入图片描述"></p>
<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>
<p><img src="https://img-blog.csdnimg.cn/20201105222845660.png" alt="在这里插入图片描述"></p>
<pre><code class="sql">select * from muser
select id,name,pwd from muser where id = #{id}</code></pre>
<p>解决方法：</p>
<ul>
<li><p>起别名</p>
<pre><code class="xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.susu.pojo.User&quot;&gt;
    select id,name,pwd as password from muser where id = #{id}
&lt;/select&gt;</code></pre>
</li>
</ul>
<h3 id="2-resultMap"><a href="#2-resultMap" class="headerlink" title="2. resultMap"></a>2. resultMap</h3><pre><code class="xml">    &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt;
        select * from muser where id = #{id}
    &lt;/select&gt;
&lt;!--    结果集映射--&gt;
    &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
&lt;!--        colum数据库中的字段，property实体类中的属性--&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
    &lt;/resultMap&gt;</code></pre>
<ul>
<li>resultMap 元素是 MyBatis 中最重要最强大的元素。</li>
<li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li>
</ul>
<h2 id="7、日志"><a href="#7、日志" class="headerlink" title="7、日志"></a>7、日志</h2><h3 id="1-日志工厂"><a href="#1-日志工厂" class="headerlink" title="1. 日志工厂"></a>1. 日志工厂</h3><p>如果一个数据库操作出现了异常，我们需要排错，日志就是最好的助手！</p>
<p><img src="https://img-blog.csdnimg.cn/20201105212101118.png" alt="在这里插入图片描述"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J 【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING 【掌握】</li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis中具体使用哪个日志实现，在设置中设定！</p>
<p><strong>STDOUT_LOGGING标准日志输出</strong></p>
<p>在Mybatis核心配置文件中，配置我们的日志</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201107085843721.png" alt="在这里插入图片描述"></p>
<h3 id="2-Log4j"><a href="#2-Log4j" class="headerlink" title="2. Log4j"></a>2. Log4j</h3><p>什么是Log4j？</p>
<ul>
<li>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/控制台/2438626" target="_blank" rel="noopener">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI" target="_blank" rel="noopener">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li>
<li>通过一个<a href="https://baike.baidu.com/item/配置文件/286550" target="_blank" rel="noopener">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li>
</ul>
<ol>
<li><p>先导入Log4j的包</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</li>
<li><p>Log4j.properties</p>
<pre><code class="xml">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file
#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=【%c】-%m%n
#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=【%p】【%d{yy-MM-dd}】【%c】%m%n
#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG</code></pre>
</li>
<li><p>配置Log4j为日志的实现</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;</code></pre>
</li>
<li><p>Log4j的使用！直接测试运行</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201107145021204.png" alt="在这里插入图片描述"></p>
<p><strong>简单实用</strong></p>
<ol>
<li><p>在要使用Log4j的类中，导入包import org.apache.log4j.Logger;</p>
</li>
<li><p>日志对象，参数给当前类的class</p>
<pre><code class="java">static Logger logger = Logger.getLogger(UserMapperTest.class);</code></pre>
</li>
<li><p>日志级别</p>
<pre><code class="java">logger.info(&quot;info:进入了testLog4j&quot;);
logger.debug(&quot;debug:进入了testLog4j&quot;);
logger.error(&quot;error:进入了testLog4j&quot;);</code></pre>
</li>
</ol>
<h2 id="8、分页"><a href="#8、分页" class="headerlink" title="8、分页"></a>8、分页</h2><p>为甚么使用分页？</p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h3 id="1-使用Limit分页"><a href="#1-使用Limit分页" class="headerlink" title="1. 使用Limit分页"></a>1. 使用Limit分页</h3><pre><code class="sql">语法： 
select * from user limit startIndex,pageSize
select * from user limit 0,2;</code></pre>
<p>使用Mybatis实现分页</p>
<ol>
<li><p>接口</p>
<pre><code class="java">List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);</code></pre>
</li>
<li><p>Mapper.xml</p>
<pre><code class="xml">&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from muser limit #{startIndex},#{pageSize};
&lt;/select&gt;</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void getUserByLimit(){
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
    map.put(&quot;startIndex&quot;,1);
    map.put(&quot;pageSize&quot;,2);
    List&lt;User&gt; userByLimit = mapper.getUserByLimit(map);
    for(User user:userByLimit){
        System.out.println(user);
    }
    sqlSession.close();
}</code></pre>
</li>
</ol>
<h3 id="2-RowBounds分页"><a href="#2-RowBounds分页" class="headerlink" title="2. RowBounds分页"></a>2. RowBounds分页</h3><p>不适用SQL实现分页</p>
<ol>
<li><p>接口</p>
<pre><code class="java">List&lt;User&gt; getUserByRowBounds();</code></pre>
</li>
<li><p>Mapper.xml</p>
<pre><code class="xml">&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from muser
&lt;/select&gt;</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void getUserByRowsBounds(){
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    RowBounds rowBounds = new RowBounds(1, 2);
    List&lt;User&gt; userList = sqlSession.selectList(&quot;com.susu.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);
    for (User user : userList) {
        System.out.println(user);
    }
    sqlSession.close();
}</code></pre>
</li>
</ol>
<h3 id="3-插件实现"><a href="#3-插件实现" class="headerlink" title="3. 插件实现"></a>3. 插件实现</h3><p><img src="https://img-blog.csdnimg.cn/20201107155011558.png" alt="在这里插入图片描述"></p>
<p>了解即可</p>
<h2 id="9、使用注解开发"><a href="#9、使用注解开发" class="headerlink" title="9、使用注解开发"></a>9、使用注解开发</h2><h3 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1. 面向接口编程"></a>1. 面向接口编程</h3><ul>
<li>大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口槟城</li>
<li><strong>根本原因：解耦；可拓展；提高复用；分层开发中，上层不用具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好</strong></li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<p><strong>关于接口的理解</strong></p>
<ul>
<li>接口从更深层次的理解，应是定义(规范，约束）与实现（名实分离的原则）的分离。</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解。</li>
<li>接口应有两类:<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class);</li>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface) ;</li>
</ul>
</li>
<li>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</li>
</ul>
<p><strong>三个面向区别</strong></p>
<ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法．</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程)为单位，考虑它的实现．</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象(过程)不是一个问题.更多的体现就是对系统整体的架构</li>
</ul>
<h3 id="2-使用注解开发"><a href="#2-使用注解开发" class="headerlink" title="2. 使用注解开发"></a>2. 使用注解开发</h3><ol>
<li><p>注解在接口上实现</p>
<pre><code class="java">@Select(&quot;select * from muser&quot;)
List&lt;User&gt; getUsers();</code></pre>
</li>
<li><p>需要在核心配置文件中绑定接口</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.susu.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
</li>
<li><p>测试</p>
</li>
</ol>
<p>本质： 反射机制实现</p>
<p>底层： 动态代理！</p>
<p><img src="https://img-blog.csdnimg.cn/20201107172653420.png" alt="在这里插入图片描述"></p>
<p><strong>Mybatis详细的执行流程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201121115835179.png" alt="在这里插入图片描述"></p>
<h3 id="3-CURD"><a href="#3-CURD" class="headerlink" title="3. CURD"></a>3. CURD</h3><ol>
<li><p>我们可以在工具类创建的时候实现事务自动提交</p>
<pre><code class="java">public static SqlSession getSqlSession(){
    return sqlSessionFactory.openSession(true);
}</code></pre>
</li>
<li><p>编写接口，增加注解</p>
<pre><code class="java">public interface UserMapper {
    @Select(&quot;select * from muser&quot;)
    List&lt;User&gt; getUsers();
    //方法存在多个参数，所有的参数前面必须加上@param(&quot;id&quot;)
    @Select(&quot;select * from muser where id = #{id}&quot;)
    User getUserById(@Param(&quot;id&quot;) int id);
    @Insert(&quot;insert into muser(id,name,pwd) values(#{id},#{name},#{paswword})&quot;)
    int addUser(User user);
    @Update(&quot;update muser set name=#{name},pwd=#{password} where id=#{id}&quot;)
    int updateUser(User user);
    @Delete(&quot;delete from muser where id=#{id}&quot;)
    int deleteUser(@Param(&quot;id&quot;) int id);
}</code></pre>
</li>
<li><p>配置接口</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.susu.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<p>【注意：我们必须要将接口注册绑定到核心配置文件中！】</p>
</li>
<li><p>测试</p>
</li>
</ol>
<p><strong>关于<a href="https://github.com/param" target="_blank" rel="noopener">@param</a>() 注解</strong></p>
<ul>
<li>基本类型的参数或者string类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议加上！</li>
<li>在sql中引用的就是这里的<a href="https://github.com/param" target="_blank" rel="noopener">@param</a>() 中的属性名！</li>
</ul>
<p><strong>#{} 和 ${} 的区别</strong></p>
<ul>
<li><h1 id="是预编译处理，mybatis在处理-时，会将sql中的-替换为-号，调用PreparedStatement的set方法来赋值；"><a href="#是预编译处理，mybatis在处理-时，会将sql中的-替换为-号，调用PreparedStatement的set方法来赋值；" class="headerlink" title="{}是预编译处理，mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；"></a>{}是预编译处理，mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</h1></li>
<li><p>$ {}是字符串替换，mybatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。</p>
</li>
<li><p>使用 #{} 可以有效的防止SQL注入，提高系统安全性。</p>
</li>
</ul>
<h2 id="10、Lombok"><a href="#10、Lombok" class="headerlink" title="10、Lombok"></a>10、Lombok</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(<a href="https://github.com/Data" target="_blank" rel="noopener">@Data</a>)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p>
<pre><code class="java">常用注解：
@Setter ：注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。
@Getter ：使用方法同上，区别在于生成的是getter方法。
@ToString ：注解在类，添加toString方法。
@EqualsAndHashCode： 注解在类，生成hashCode和equals方法。
@NoArgsConstructor： 注解在类，生成无参的构造方法。
@RequiredArgsConstructor： 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。
@AllArgsConstructor： 注解在类，生成包含类中所有字段的构造方法。
@Data： 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。
@Slf4j： 注解在类，生成log变量，严格意义来说是常量。</code></pre>
<p>优点:</p>
<ol>
<li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</li>
<li>让代码变得简洁，不用过多的去关注相应的方法</li>
<li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</li>
</ol>
<p>缺点:</p>
<ol>
<li>不支持多种参数构造器的重载</li>
<li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度</li>
</ol>
<blockquote>
<p>知乎上有位大神发表过对Lombok的一些看法:</p>
<p>这是一种低级趣味的插件，不建议使用。Java发展到今天，各种插件层出不穷，如何甄别各种插件的优劣？能从架构上优化你的设计的，能提高应用程序性能的，实现高度封装可扩展的。像1ombok这种，像这种插件，已经不仅仅是插件了，改变了你如何编写源码事实上，少去了的代码，你写上去又如何？如果Java家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代.</p>
</blockquote>
<h3 id="2-使用步骤："><a href="#2-使用步骤：" class="headerlink" title="2. 使用步骤："></a>2. 使用步骤：</h3><ol>
<li>在idea中下载插件</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201107205012805.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>导入依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.16&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>在实体类中加注解即可</p>
<pre><code class="java">@Data
@AllArgsConstructor  //生成有参构造
@NoArgsConstructor //生成无参构造
public class User {
    private int id;
    private String name;
    private String password;
}</code></pre>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201107210641240.png" alt="在这里插入图片描述"></p>
<h2 id="11、多对一处理"><a href="#11、多对一处理" class="headerlink" title="11、多对一处理"></a>11、多对一处理</h2><p><img src="https://img-blog.csdnimg.cn/2020112111591778.png" alt="在这里插入图片描述"></p>
<ul>
<li>多个学生，对应一个老师</li>
<li>对于学生这边而言， <strong>关联</strong> .. 多个学生，关联一个老师 【多对一】</li>
<li>对于老师而言， <strong>集合</strong> ， 一个老师，有很多学生 【一对多】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201121115948965.png" alt="在这里插入图片描述"></p>
<p>sql</p>
<pre><code class="sql">CREATE TABLE `teacher` (
  `id` INT(10) NOT NULL,
  `name` VARCHAR(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8
INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;); 
CREATE TABLE `student` (
  `id` INT(10) NOT NULL,
  `name` VARCHAR(30) DEFAULT NULL,
  `tid` INT(10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fktid` (`tid`),
  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
</code></pre>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><ol>
<li>导入lombok</li>
<li>新建实体类Teacher，student</li>
<li>建立Mapper接口</li>
<li>建立Mapper.xml文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心所欲】</li>
<li>测试查询是否能够成功</li>
</ol>
<h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><pre><code class="xml">&lt;!--
    思路：
        1. 查询所有的学生信息
        2. 根据查询出的学生信息的tid，寻找对应的老师    子查询
--&gt;
&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
&lt;/select&gt;
&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;!--复杂的属性，需要单独处理，  对象：association  集合： collection--&gt;
    &lt;association column=&quot;tid&quot; property=&quot;teacher&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;com.susu.pojo.Teacher&quot;&gt;
    select * from teacher where id = #{id}
&lt;/select&gt;</code></pre>
<h3 id="按照结果嵌套查询"><a href="#按照结果嵌套查询" class="headerlink" title="按照结果嵌套查询"></a>按照结果嵌套查询</h3><pre><code class="xml">&lt;!----&gt;
&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;
    select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id
&lt;/select&gt;
&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
    &lt;result column=&quot;sid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;
    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;</code></pre>
<p>Mysql多对一查询：</p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<h2 id="12-、一对多处理"><a href="#12-、一对多处理" class="headerlink" title="12 、一对多处理"></a>12 、一对多处理</h2><p>比如： 一个老师拥有多个学生</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code class="java">@Data
public class Teacher {
    private int id;
    private String name;
    private List&lt;Student&gt; students;
}</code></pre>
<h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><pre><code class="xml">&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
    select t.id tid, t.name tname, s.id sid, s.name sname
    from student s, teacher t
    where s.tid = t.id and t.id=#{ttid}
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
    &lt;result column=&quot;tid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt;
    &lt;!--复杂的属性，需要单独处理，  对象：association  集合： collection
        javaType=&quot;&quot; 指定属性的类型
        集合中的泛型信息，我们使用ofType获取
    --&gt;
    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;result property=&quot;tid&quot;  column=&quot;ttid&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><pre><code class="xml">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;Teacherstudent2&quot;&gt;
    select * from mybatis.teacher where id = #{ttid}
&lt;/select&gt;
&lt;resultMap id=&quot;Teacherstudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getstudentByTeacherId&quot; column=&quot;id&quot;&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getstudentByTeacherId&quot; resultType=&quot;student&quot;&gt;
    select * from mybatis.student where tid = #{ttid}
&lt;/select&gt;</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>关联 - association 【多对一】</li>
<li>集合 - collection 【一对多】</li>
<li>javaType &amp; ofType<ol>
<li>javaType 用来指定实体类中属性的类型</li>
<li>ofType 用来指定映射到List或集合中的pojo类型，泛型中的约束类型</li>
</ol>
</li>
</ol>
<p>注意点：</p>
<ul>
<li>保证Sql的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一中，属性名和字段的问题！</li>
<li>如果问题不好排查错误，可以使用日志，建议使用 Log4j</li>
</ul>
<h2 id="13、-动态SQL"><a href="#13、-动态SQL" class="headerlink" title="13、 动态SQL"></a>13、 动态SQL</h2><p>什么是动态SQL：动态SQL就是很不同的条件生成不同的SQL语句</p>
<pre><code class="java">如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。
if
choose (when, otherwise)
trim (where, set)
foreach</code></pre>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><pre><code class="sql">CREATE TABLE b1og(
&#39;id&#39; varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
&#39;title&#39; varchar(100) NOT NULL COMMENT &#39;博客标题&#39;, 
&#39;author&#39; varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
&#39;create_time&#39; datetime NOT NULL COMMENT &#39;创建时间&#39;,
&#39;views&#39; int(30) NOT NULL COMMENT &#39;浏览量&#39;
)ENGINE=InnoDB DEFAULT CHARSET=utf8</code></pre>
<p>创建一个基础工程</p>
<ol>
<li><p>导包</p>
</li>
<li><p>编写配置文件</p>
</li>
<li><p>编写实体类</p>
<pre><code class="java">@Data
public class Blog {
    private String id;
    private String title;
    private String author;
    private Date createTime;   //属性名和字段名不一致
    private int views;
}</code></pre>
</li>
<li><p>编写实体类对应Mapper接口和Mapper.xml文件</p>
</li>
</ol>
<h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><pre><code class="xml">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;com.susu.pojo.Blog&quot;&gt;
    select * from blog where 1=1
    &lt;if test=&quot;title != null&quot;&gt;
        and title = #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null&quot;&gt;
        and author #{author}
    &lt;/if&gt;
&lt;/select&gt;</code></pre>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><pre><code class="xml">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;com.susu.pojo.Blog&quot;&gt;
    select * from blog
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;title != null&quot;&gt;
                and titile = #{title}
            &lt;/when&gt;
            &lt;when test=&quot;author != null&quot;&gt;
                and author = #{author}
            &lt;/when&gt;
            &lt;otherwise&gt;
                and views = #{views}
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
<p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
<p>如果 <em>where</em> 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p>
<pre><code class="xml">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;
  ...
&lt;/trim&gt;</code></pre>
<p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p>
<h3 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim (where, set)"></a>trim (where, set)</h3><pre><code class="xml">select * from blog
&lt;where&gt;
    &lt;if test=&quot;title != null&quot;&gt;
        and title = #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null&quot;&gt;
        and author #{author}
    &lt;/if&gt;
&lt;/where&gt;</code></pre>
<pre><code class="xml">&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;
    update mybatis.blog
    &lt;set&gt;
        &lt;if test=&quot;title != null&quot;&gt;
            title = #{title},
        &lt;/if&gt;
        &lt;if test=&quot;author != null&quot;&gt;
            author = #{author}
        &lt;/if&gt;
    &lt;/set&gt;
    where id = #{id}
&lt;/update&gt;</code></pre>
<p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>
<p>来看看与 <em>set</em> 元素等价的自定义 <em>trim</em> 元素吧：</p>
<pre><code class="xml">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;
  ...
&lt;/trim&gt;</code></pre>
<p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p>
<p><strong>所谓动态sql，本质还是sql语句，只是可以在SQL层面，去执行一个逻辑代码</strong></p>
<h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>有的时候，我们可能会将一些功能的部分抽取出来，方便复用！</p>
<ol>
<li><p>使用sql标签抽取公共的部分</p>
<pre><code class="xml">&lt;sql id=&quot;if-title-author&quot;&gt;
    &lt;if test=&quot;title != null&quot;&gt;
        and title = #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null&quot;&gt;
        and author #{author}
    &lt;/if&gt;
&lt;/sql&gt;</code></pre>
</li>
<li><p>在需要使用的地方使用include标签引用即可</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;com.susu.pojo.Blog&quot;&gt;
    select * from blog
    &lt;where&gt;
       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>最好基于单表来定义SQL片段！</li>
<li>不要存在where标签</li>
</ul>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。</p>
<p><img src="https://img-blog.csdnimg.cn/20201108200024299.png" alt="在这里插入图片描述"></p>
<pre><code class="xml">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;com.susu.pojo.Blog&quot;&gt;
    select * from blog
    &lt;where&gt;
        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
            id = #{id}
        &lt;/foreach&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
<p><strong>动态sql就是在拼接sql 语句，我们只要保证sql的正确性，按照SQL的格式，去排列组合就可以了</strong></p>
<p>建议：</p>
<ul>
<li>先在Mysql中写出完整的SQL，再对应的去修改成为我们的动态sql</li>
</ul>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p>
<pre><code class="xml">@Update({&quot;&lt;script&gt;&quot;,
    &quot;update Author&quot;,
    &quot;  &lt;set&gt;&quot;,
    &quot;    &lt;if test=&#39;username != null&#39;&gt;username=#{username},&lt;/if&gt;&quot;,
    &quot;    &lt;if test=&#39;password != null&#39;&gt;password=#{password},&lt;/if&gt;&quot;,
    &quot;    &lt;if test=&#39;email != null&#39;&gt;email=#{email},&lt;/if&gt;&quot;,
    &quot;    &lt;if test=&#39;bio != null&#39;&gt;bio=#{bio}&lt;/if&gt;&quot;,
    &quot;  &lt;/set&gt;&quot;,
    &quot;where id=#{id}&quot;,
    &quot;&lt;/script&gt;&quot;})
void updateAuthorValues(Author author);</code></pre>
<h3 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h3><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p>
<pre><code class="xml">&lt;insert id=&quot;insert&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    &lt;if test=&quot;_databaseId == &#39;oracle&#39;&quot;&gt;
      select seq_users.nextval from dual
    &lt;/if&gt;
    &lt;if test=&quot;_databaseId == &#39;db2&#39;&quot;&gt;
      select nextval for seq_users from sysibm.sysdummy1&quot;
    &lt;/if&gt;
  &lt;/selectKey&gt;
  insert into users values (#{id}, #{name})
&lt;/insert&gt;</code></pre>
<h2 id="14、-缓存"><a href="#14、-缓存" class="headerlink" title="14、 缓存"></a>14、 缓存</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><ol>
<li>什么是缓存[ Cache ] ?<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
</li>
<li>为什么使用缓存 ?<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
</li>
<li>什么样的数据能使用缓存 ?<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
</li>
</ol>
<h3 id="2-Mybatis缓存"><a href="#2-Mybatis缓存" class="headerlink" title="2. Mybatis缓存"></a>2. Mybatis缓存</h3><ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：</p>
<p>一级缓存</p>
</li>
</ul>
<p>  和</p>
<p>  二级缓存</p>
<ul>
<li>默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称为本地缓存)。</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
<h3 id="3-一级缓存"><a href="#3-一级缓存" class="headerlink" title="3. 一级缓存"></a>3. 一级缓存</h3><ul>
<li>一级缓存也叫本地缓存： SqlSession<ul>
<li>与数据库同一次绘画期间查询到的数据会放在本地缓存中</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库</li>
</ul>
</li>
</ul>
<p>测试步骤：</p>
<ol>
<li><p>开始日志</p>
</li>
<li><p>测试在一个session中查询两次相同记录</p>
</li>
<li><p>查看日志输出</p>
<p><img src="https://img-blog.csdnimg.cn/20201108210140810.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>缓存失效的情况：</p>
<ol>
<li><p>查询不同的东西</p>
</li>
<li><p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存！</p>
<p><img src="https://img-blog.csdnimg.cn/20201108210746147.png" alt="在这里插入图片描述"></p>
</li>
<li><p>查询不同的Mapper.xml</p>
</li>
<li><p>手动清理缓存！</p>
<p><img src="https://img-blog.csdnimg.cn/20201108210920651.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>小结：一级缓存默认是开启的，只在一次sqlsession中有效，也就是拿到连接到关闭连接这个区间段！</p>
<p>一级缓存相当于一个Map</p>
<h3 id="4-二级缓存"><a href="#4-二级缓存" class="headerlink" title="4. 二级缓存"></a>4. 二级缓存</h3><ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存;</li>
<li>工作机制<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中;</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了; 但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中;</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容;</li>
<li>不同的mapper查出的数据会放在自己对应的缓存(map）中;</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>开始全局缓存</p>
<pre><code class="xml">&lt;!--显式的开启缓存--&gt;
&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></pre>
</li>
<li><p>在要使用二级缓存的Mapper中开启</p>
<pre><code class="xml">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;
&lt;cache/&gt;</code></pre>
<pre><code class="xml">也可以定义一些参数
 ```xml
&lt;cache
   eviction=&quot;FIFO&quot;
   flushInterval=&quot;60000&quot;
   size=&quot;512&quot;
   readOnly=&quot;true&quot;/&gt;</code></pre>
</li>
<li><p>测试</p>
<ol>
<li><p>问题：我们需要将实体类序列化，否则就会报错！</p>
<p><img src="https://img-blog.csdnimg.cn/2020110908494028.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>需要在实体类中：</p>
<pre><code class="java">@Data
public class User implements Serializable {
    private int id;
    private String name;
    private String pwd;
}</code></pre>
</li>
</ol>
</li>
</ol>
<p>小结：</p>
<ul>
<li>只要开起了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中</li>
<li>只有当回话提交，或者关闭的时候，才会提交到二级缓存中</li>
</ul>
<h3 id="5-缓存原理"><a href="#5-缓存原理" class="headerlink" title="5. 缓存原理"></a>5. 缓存原理</h3><p><img src="https://img-blog.csdnimg.cn/20201108221845889.png" alt="在这里插入图片描述"></p>
<h3 id="6-自定义缓存-ehcache"><a href="#6-自定义缓存-ehcache" class="headerlink" title="6. 自定义缓存- ehcache"></a>6. 自定义缓存- ehcache</h3><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。</p>
<p>要在程序中使用ehcache，先导包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.2.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>在Mapper中指定使用我们的ehcache缓存实现</p>
<pre><code class="xml">&lt;!--在当前Mapper.xm1中使用二级缓存--&gt;
&lt;cache type=&quot;org.mybatis.caches.ehcache.Ehcachecache&quot;/&gt;</code></pre>
<p>ehcache.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
         updateCheck=&quot;false&quot;&gt;
    &lt;!--
        diskstore:为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下:
            user.home- 用户主目录
            user.dir -用户当前工作目录
            java.io.tmpdir - 默认临时文件路径
    --&gt;
    &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
    &lt;defaultCache
            eternal=&quot;false&quot;
            maxElementsInMemory=&quot;10000&quot;
            overflowToDisk=&quot;false&quot;
            diskPersistent=&quot;false&quot;
            timeToIdleSeconds=&quot;1800&quot;
            timeToLiveSeconds=&quot;259200&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
    &lt;cache
            name=&quot;cloud_user&quot;
            eternal=&quot;false&quot;
            maxElementsInMemory=&quot;5000&quot;
            overflowToDisk=&quot;false&quot;
            diskPersistent=&quot;false&quot;
            timeToIdleSeconds=&quot;1800&quot;
            timeToLiveSeconds=&quot;1800&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
&lt;/ehcache&gt;
&lt;!--
    defau1tcache:默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
        name :缓存名称。
        maxE7ements InMemory:缓存最大数目
        maxE7ementsonDisk:硬盘最大缓存个数。
        eternal :对象是否永久有效，一但设置了，timeout将不起作用。
        overflowToDisk:是否保存到磁盘，当系统当机时
        timeToIpleseconds:设置对象在失效前的允许闲置时间（单位:秒)。仅当eterna7=false对象不是永久有效时使用，可选属性，默认值是o，也就是可闲置时间无穷大。
        timeToLiveseconds :设置对象在失效前允许存活时间（单位:秒)。最大时间介于创建时间和失效时间之间。仅当eterna1=fa1se对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
        diskPersistent:是否缓存虚拟机重启期数据 whether the disk store persists betweenstarts of the virtual Machine. The default value is false.
        diskSpoo7BuffersizeMB:这个参数设置Diskstore（磁盘缓存）的缓存区大小。默认是30MB。每个cache都应该有自己的一个缓冲区。
        diskExpiryThreadInterva7seconds:磁盘失效线程运行时间间隔，默认是120秒。
           memorystoreEvictionPo1icy:当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用)。你可以设置为FIFo（先进先出）或是LFU（较少使用)。
        clearonFlush:内存数量最大时是否清除。
        memorystoreEvictionPolicy:可选策略有: LRU(最近最少使用，默认策略）、FIFo（先进先出)、LFU(最少访问次数）。
        FTFo，first: in first out，这个是大家最熟的，先进先出。
        LFU，Less Frequently used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
        LRU，Least Recent1y used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
--&gt;</code></pre>
<h2 id="15、SQL-语句构建器"><a href="#15、SQL-语句构建器" class="headerlink" title="15、SQL 语句构建器"></a>15、SQL 语句构建器</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a><strong>问题：</strong></h3><p>Java 程序员面对的最痛苦的事情之一就是在 Java 代码中嵌入 SQL 语句。这通常是因为需要动态生成 SQL 语句，不然我们可以将它们放到外部文件或者存储过程中。如你所见，MyBatis 在 XML 映射中具备强大的 SQL 动态生成能力。但有时，我们还是需要在 Java 代码里构建 SQL 语句。此时，MyBatis 有另外一个特性可以帮到你，让你从处理典型问题中解放出来，比如加号、引号、换行、格式化问题、嵌入条件的逗号管理及 AND 连接。确实，在 Java 代码中动态生成 SQL 代码真的就是一场噩梦。例如：</p>
<p><img src="https://img-blog.csdnimg.cn/20201109091515173.png" alt="在这里插入图片描述"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>MyBatis 3 提供了方便的工具类来帮助解决此问题。借助 SQL 类，我们只需要简单地创建一个实例，并调用它的方法即可生成 SQL 语句。让我们来用 SQL 类重写上面的例子：</p>
<pre><code class="java">private String selectPersonSql() {
  return new SQL() { {
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
    SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
    FROM(&quot;PERSON P&quot;);
    FROM(&quot;ACCOUNT A&quot;);
    INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
    INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
    WHERE(&quot;P.ID = A.ID&quot;);
    WHERE(&quot;P.FIRST_NAME like ?&quot;);
    OR();
    WHERE(&quot;P.LAST_NAME like ?&quot;);
    GROUP_BY(&quot;P.ID&quot;);
    HAVING(&quot;P.LAST_NAME like ?&quot;);
    OR();
    HAVING(&quot;P.FIRST_NAME like ?&quot;);
    ORDER_BY(&quot;P.ID&quot;);
    ORDER_BY(&quot;P.FULL_NAME&quot;);
  } }.toString();
}</code></pre>
<p>你会发现，你不用担心可能会重复出现的 “AND” 关键字，或者要做出用 “WHERE” 拼接还是 “AND” 拼接还是不用拼接的选择。SQL 类已经为你处理了哪里应该插入 “WHERE”、哪里应该使用 “AND” 的问题，并帮你完成所有的字符串拼接工作。</p>
<h3 id="SQL-类"><a href="#SQL-类" class="headerlink" title="SQL 类"></a>SQL 类</h3><p>这里有一些示例：</p>
<pre><code class="java">// 匿名内部类风格
public String deletePersonSql() {
  return new SQL() { {
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  } }.toString();
}
// Builder / Fluent 风格
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;)
    .VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;)
    .toString();
  return sql;
}
// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() { {
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);
    FROM(&quot;PERSON P&quot;);
    if (id != null) {
      WHERE(&quot;P.ID like #{id}&quot;);
    }
    if (firstName != null) {
      WHERE(&quot;P.FIRST_NAME like #{firstName}&quot;);
    }
    if (lastName != null) {
      WHERE(&quot;P.LAST_NAME like #{lastName}&quot;);
    }
    ORDER_BY(&quot;P.LAST_NAME&quot;);
  } }.toString();
}
public String deletePersonSql() {
  return new SQL() { {
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  } }.toString();
}
public String insertPersonSql() {
  return new SQL() { {
    INSERT_INTO(&quot;PERSON&quot;);
    VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;);
    VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;);
  } }.toString();
}
public String updatePersonSql() {
  return new SQL() { {
    UPDATE(&quot;PERSON&quot;);
    SET(&quot;FIRST_NAME = #{firstName}&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  } }.toString();
}</code></pre>
<p>注意，SQL 类将原样插入 <code>LIMIT</code>、<code>OFFSET</code>、<code>OFFSET n ROWS</code> 以及 <code>FETCH FIRST n ROWS ONLY</code> 子句。换句话说，类库不会为不支持这些子句的数据库执行任何转换。 因此，用户应该要了解目标数据库是否支持这些子句。如果目标数据库不支持这些子句，产生的 SQL 可能会引起运行错误。</p>
<h2 id="16、遇到的问题"><a href="#16、遇到的问题" class="headerlink" title="16、遇到的问题"></a>16、遇到的问题</h2><p><img src="https://img-blog.csdnimg.cn/2020111409083967.png" alt="在这里插入图片描述"></p>
<p>解决方法：</p>
<p>中文意思就是统一资源标识符没有注册，解决方法就是将这个标识符手动添加到IDEA中，首先复制报红色的那串代码（只要红色的部分），然后按照步骤添加就行。</p>
<ul>
<li>file —&gt; settings- -&gt; languages &amp; frameworks —&gt;Schemas and DTDs,</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201114091127577.png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/Mr-lee-MQ.hithub.io/2020/08/04/Vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue "></a>Vue <a id="more"></a></h1><p>网络通信：axios</p>
<p>页面跳转：vue-router</p>
<p>状态管理：vuex</p>
<p>Vue-UI：ICE</p>
<p>M: 模型  V：视图   C：控制器</p>
<h2 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h2><ul>
<li>JQuery：简化了DOM操作，缺点是DOM操作太频繁，影响前端性能。</li>
<li>Angular：将后台的MVC模式搬到前端并增加了模块化开发的理念。</li>
<li>React：提出了虚拟DOM，在内存中模拟DOM操作，有效提高了前端的渲染效率，缺点是使用复杂，需要学习JSX语言</li>
<li>Vue：渐进式JavaScript框架，渐进式即逐步实现新特性的意思。如实现模块化开发，路由，状态管理等新特性。其特点是综合了Angular（模块化）和React（虚拟DOM）的优点</li>
<li>Axios：前端通讯框架，Vue不具备通信能力，也可以用JQuery提供的AJAX通信功能</li>
</ul>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><ul>
<li>Ant-Design :阿里巴巴出品，基于React的UI框架</li>
<li>ElementUI，iview,ice:饿了么出品，用于Vue的UI框架</li>
<li>Bootstrap:Twitter推出的一个用于前端开发的开源工具包</li>
<li>AmazeUI：一款HTML5跨屏前端框架</li>
</ul>
<h2 id="JavaSxript构建工具"><a href="#JavaSxript构建工具" class="headerlink" title="JavaSxript构建工具"></a>JavaSxript构建工具</h2><ul>
<li>Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li>
<li>WebPack：模块化打包器，主要作用是打包，压缩，合并及按序加载</li>
</ul>
<h2 id="框架和项目管理工具"><a href="#框架和项目管理工具" class="headerlink" title="框架和项目管理工具"></a>框架和项目管理工具</h2><ul>
<li><p>Express：NodeJS框架</p>
</li>
<li><p>Koa：Express简化版</p>
</li>
<li><p>NPM:项目综合管理工具，类似于Maven</p>
</li>
<li><p>YARN：NPM的替代方案，类似于Maven和Gradle的关系</p>
</li>
</ul>
<h2 id="Vue入门"><a href="#Vue入门" class="headerlink" title="Vue入门"></a>Vue入门</h2><p>模板</p>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;

&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<ul>
<li>v-bind     绑定元素</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;span v-bind:title=&quot;message&quot;&gt;
        鼠标悬停几秒
    &lt;/span&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data: {
            message:&quot;Hello,Vue!&quot;
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<ul>
<li>v-if </li>
<li>v-else</li>
</ul>
<pre><code class="html">&lt;/head&gt;
&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;h1 v-if=&quot;type===&#39;A&#39;&quot;&gt;A&lt;/h1&gt;
    &lt;h1 v-else-if=&quot;type===&#39;B&#39;&quot;&gt;B&lt;/h1&gt;
    &lt;h1 v-else-if=&quot;type===&#39;C&#39;&quot;&gt;C&lt;/h1&gt;
    &lt;h1 v-else&gt;No&lt;/h1&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data:{
            type:&#39;A&#39;
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<ul>
<li>v-for</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
  &lt;li v-for=&quot;item in items&quot;&gt; 
    {{item.message}}



    //{{ parentMessage }} - {{ index }} index可输出数组下标
      &lt;/li&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data: {
            items:[
                {message:&#39;狂神说Java&#39;},
                {message:&#39;狂神前端&#39;}
            ]

        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>方法必须定义在Vue的method对象中methods:{        }</li>
<li>通过v-on绑定事件</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;sayhai&quot;&gt;click Me&lt;/button&gt;

&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,

        data: {
            message:&quot;狂神说Java&quot;

        },
    methods:{    //方法必须定义在Vue的method对象中
            sayhai:function () {
                alert(this.message)

            }

    }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>Vue.js是一个MVVM框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。</p>
<ul>
<li><p>使用v-model实现双向绑定，v-model会忽略所有表单元素的value,checked,selected特性的初始值，而只将Vue实例的数据作为来源，应该通过JavaScript在组件的data选项中声明初始值。</p>
</li>
<li><p>输入文本</p>
</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    输入的文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;{{message}}
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data: {
            message:&quot;&quot;
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<ul>
<li>单选框</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;qinjiang&quot;&gt;男
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;qinjiang&quot;&gt;女

    &lt;p&gt;
        选中了谁:{{qinjiang}}
    &lt;/p&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data: {
            qinjiang: &#39;&#39;
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<ul>
<li>下拉框</li>
</ul>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    下拉框：
    &lt;select v-model=&quot;selected&quot;&gt;
        &lt;option value=&quot;&quot;disabled&gt;--请选择--&lt;/option&gt;
        &lt;option&gt;A&lt;/option&gt;
        &lt;option&gt;B&lt;/option&gt;
        &lt;option&gt;C&lt;/option&gt;
    &lt;/select&gt;
    &lt;span&gt;value:{{selected}}&lt;/span&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        //Model: 数据
        data: {
            selected: &#39;&#39;
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<h2 id="Vue的组件"><a href="#Vue的组件" class="headerlink" title="Vue的组件"></a>Vue的组件</h2><pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;
     &lt;!--组件：传递给组件中的值：props--&gt;
    //从数组(items)中遍历出的值(item)绑定到qin上
    //由props接收qin的值
    //由props送到模板(template)中
    &lt;qinjiang v-for=&quot;item in items&quot; v-bind: qin=&quot;item&quot;&gt;&lt;/qinjiang&gt;
&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;

    //定义一个Vue组件component
    Vue.component(&quot;qinjiang&quot;,{
        props:[&#39;qin&#39;],
        template: &#39;&lt;li&gt;{{qin}}&#39;&lt;/li&gt;

    });
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            items:[&quot;Java&quot;,&quot;Linux&quot;,&quot;前端&quot;]
        }

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<h2 id="Vue-Axios异步通信"><a href="#Vue-Axios异步通信" class="headerlink" title="Vue:Axios异步通信"></a>Vue:Axios异步通信</h2><p>Axios是一个开源的可以用在浏览器端和Node.js的异步通信框架，它的主要作用就是实现AJAX异步通信。</p>
<p>主要功能特点：</p>
<ul>
<li>从浏览器中创建XMLHttpRequests</li>
<li>从node.js创建http请求</li>
<li>支持Promise  API (JS中链式方程)</li>
<li>Nnew拦截请求和响应</li>
<li>转化请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防御XSRF（跨站请求伪造）</li>
</ul>
<p>模板</p>
<pre><code class="html">&lt;body&gt;
&lt;!--view层   模板--&gt;
&lt;div id=&quot;app&quot;&gt;

&lt;/div&gt;
&lt;!--导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,

    });

&lt;/script&gt;

&lt;/body&gt;</code></pre>
<p>Vue实例由一个完整的生命周期</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/Mr-lee-MQ.hithub.io/2021/02/19/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring "></a>Spring <a id="more"></a></h1><h2 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h2><h2 id="1-2、优点"><a href="#1-2、优点" class="headerlink" title="1.2、优点"></a>1.2、优点</h2><p> Spring是一个开源的免费的框架(容器)！</p>
<h1 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2.IOC理论推导"></a>2.IOC理论推导</h1><p> 1.UserDao接口</p>
<p> 2.UserDaoImpl实现类</p>
<p> 3.UserService业务接口</p>
<p> 4.UserServiceImpl业务实现类</p>
<p> 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据需求去修改原代码！如果程序代码量十分大，修改的代价是十分昂贵的！</p>
<p><img src="http://cdn.gvssimux.com/image-20200613095224654.png" alt="image-20200613095224654"></p>
<p> 我们使用一个Set接口实现，发生革命性变化</p>
<pre><code class="java">private UserDao userDao;
//利用一个Set进行动态实现值的注入
public void setUserDao(UserDao userDao) {
    this.userDao = use</code></pre>
<ul>
<li><p>之前，程序是主动创建对象！控制权在程序员手上！</p>
</li>
<li><p>使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！</p>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以专注在业务的实现上！这是IOC的原型！</p>
</li>
</ul>
<p><img src="http://cdn.gvssimux.com/image-20200613093110666.png" alt="3498"></p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h1 id="3、配置元数据"><a href="#3、配置元数据" class="headerlink" title="3、配置元数据"></a>3、配置元数据</h1><h2 id="1、applicationContext-xml"><a href="#1、applicationContext-xml" class="headerlink" title="1、applicationContext.xml"></a>1、applicationContext.xml</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;
    &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;</code></pre>
<h2 id="2、实例化容器"><a href="#2、实例化容器" class="headerlink" title="2、实例化容器"></a>2、实例化容器</h2><pre><code class="java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</code></pre>
<h1 id="4、IOC创建对象的方式"><a href="#4、IOC创建对象的方式" class="headerlink" title="4、IOC创建对象的方式"></a>4、IOC创建对象的方式</h1><ol>
<li><p>使用无参构造创建对象（默认）</p>
</li>
<li><p>使用有参构造创建对象</p>
<ol>
<li><p>下标赋值</p>
<pre><code class="xml"> &lt;!--下标赋值--&gt;
     &lt;bean id=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot;&gt;
      &lt;constructor-arg index=&quot;0&quot; value=&quot;秦疆&quot;/&gt;
     &lt;/bean&gt;</code></pre>
<pre><code></code></pre></li>
<li><p>Constructor argument name</p>
</li>
</ol>
<p>​```xml</p>
<pre><code>&lt;!--Constructor argument name--&gt;</code></pre> <bean id="user" class="com.shanzj.pojo.User">
        <constructor-arg name="name" value="秦疆">
    </constructor-arg></bean>
```
```

<ol start="3">
<li><p>Constructor argument type matching</p>
<pre><code class="xml"> &lt;!--Constructor argument type matching--&gt;
 &lt;bean id=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot;&gt;
  &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;秦疆&quot;/&gt;
 &lt;/bean&gt;</code></pre>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了~</p>
</li>
</ol>
</li>
</ol>
<h1 id="5、spring配置"><a href="#5、spring配置" class="headerlink" title="5、spring配置"></a>5、spring配置</h1><h2 id="5-1、别名"><a href="#5-1、别名" class="headerlink" title="5.1、别名"></a>5.1、别名</h2><pre><code class="xml">&lt;!-- 别名，如果添加了别名，我们也可以使用别名获取到这个对象 --&gt;
&lt;alias name=&quot;user&quot; alias=&quot;wwwww&quot;/&gt;</code></pre>
<h2 id="5-2、Bean的配置"><a href="#5-2、Bean的配置" class="headerlink" title="5.2、Bean的配置"></a>5.2、Bean的配置</h2><pre><code class="xml">&lt;!--
id:bean 的唯一标识符，也就是相对于我们学的对象名
class：bean 对象所对应的全限定名：包名+类名
name：也是别名,而且name可以同时取多个别名(user2 u2 u3 u4 这里可以用很多东西去分割)
--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot; name=&quot;user2,u2 u3;u4&quot;&gt;
      &lt;constructor-arg name=&quot;name&quot; value=&quot;单子健爱生活2&quot; /&gt;
&lt;/bean&gt;</code></pre>
<h2 id="5-3、import"><a href="#5-3、import" class="headerlink" title="5.3、import"></a>5.3、import</h2><p>import 一般用于团队开发使用，他可以将多个配置文件，导入合并为一个</p>
<p>假如，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的配置文件</p>
<ul>
<li><p>张三</p>
</li>
<li><p>李四</p>
</li>
<li><p>王五</p>
</li>
<li><p>applicationContext</p>
<p>使用的时候，直接使用总的配置就可以了</p>
</li>
</ul>
<h1 id="6、依赖注入"><a href="#6、依赖注入" class="headerlink" title="6、依赖注入"></a>6、依赖注入</h1><h2 id="6-1、构造器注入"><a href="#6-1、构造器注入" class="headerlink" title="6.1、构造器注入"></a>6.1、构造器注入</h2><p>前面4、IOC创建对象的方式讲述过了</p>
<h2 id="6-2、通过set方式注入【重点】"><a href="#6-2、通过set方式注入【重点】" class="headerlink" title="6.2、通过set方式注入【重点】"></a>6.2、通过set方式注入【重点】</h2><ul>
<li><p>依赖注入：set注入！</p>
<ul>
<li>依赖：bean对象的创建依赖容器</li>
</ul>
</li>
<li><p>注入：bean对象中的所有属性，由容器来注入！</p>
</li>
</ul>
<p><strong>环境搭建</strong></p>
<ul>
<li><p>复杂类型</p>
<pre><code class="java">  public class Address {
      private  String address;
      public String getAddress() {
          return address;
      }
      public void setAddress(String address) {
          this.address = address;
      }
  }</code></pre>
</li>
<li><p>真实测试对象</p>
<pre><code class="java">  public class Student {
      private String name;
      private Address address;
      private String[] books;
      private List&lt;String&gt; hobbies;
      private Map&lt;String, String&gt; card;
      private Set&lt;String&gt; games;
      private Properties info;
      private String wife;
  }</code></pre>
</li>
<li><p>beans.xml</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8”?&gt;

 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class test {
@Test
    public void test01(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        Student studnet = (Student) context.getBean(&quot;student&quot;);
        System.out.println(studnet.getName());        
    }  
}</code></pre>
</li>
<li><p>完善注入信息</p>
<pre><code class="xml">&lt;bean id=&quot;address&quot; class=&quot;com.shanzj.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;hf&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;student&quot; class=&quot;com.shanzj.pojo.Student&quot;&gt;
        &lt;!-- 普通注入  --&gt;
        &lt;property name=&quot;name&quot; value=&quot;单子健&quot;/&gt;
        &lt;!-- Bean注入 --&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--数组--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!-- List --&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;跑步&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!-- Map --&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;62132&quot;/&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;345234&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--Set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;CSGO&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!-- property --&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
                &lt;prop key=&quot;年龄&quot;&gt;18&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;!-- NULL --&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre>
</li>
</ul>
<h2 id="6-3、拓展方式注入"><a href="#6-3、拓展方式注入" class="headerlink" title="6.3、拓展方式注入"></a>6.3、拓展方式注入</h2><h3 id="6-3-1、官方文档"><a href="#6-3-1、官方文档" class="headerlink" title="6.3.1、官方文档"></a>6.3.1、官方文档</h3><p>我们使用p:命名空间(Set)和c:(构造)命名空间去注入</p>
<p>地址：<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-c-namespace" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-c-namespace</a></p>
<p><img src="http://cdn.gvssimux.com/image-20200615192059589.png" alt="image-20200615192059589"></p>
<p>p-namespace</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;someone@somewhere.com&quot;/&gt;
&lt;/beans&gt;</code></pre>
<p>c-namespace</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;
    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;
    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;
        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;
        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;
&lt;/beans&gt;</code></pre>
<h3 id="6-3-2、个人演示"><a href="#6-3-2、个人演示" class="headerlink" title="6.3.2、个人演示"></a>6.3.2、个人演示</h3><p>userbeans.xml</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean name=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot; p:age=&quot;18&quot; p:name=&quot;shanzj&quot;/&gt;
    &lt;bean name=&quot;user2&quot; class=&quot;com.shanzj.pojo.User&quot; c:age=&quot;19&quot; c:name=&quot;shanzj2&quot;/&gt;
&lt;/beans&gt;</code></pre>
<p>Usertest.java</p>
<pre><code class="java">public class UserTest {
    @Test
    public void test(){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
        User user = context.getBean(&quot;user&quot;, User.class);
        User user2 = context.getBean(&quot;user2&quot;, User.class);
        System.out.println(user);
        System.out.println(user2);
    }
}</code></pre>
<h3 id="6-3-3、注意"><a href="#6-3-3、注意" class="headerlink" title="6.3.3、注意"></a>6.3.3、注意</h3><p>p或c命名空间需要导入xml约束</p>
<pre><code class="xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></pre>
<h2 id="6-4、bean的作用域"><a href="#6-4、bean的作用域" class="headerlink" title="6.4、bean的作用域"></a>6.4、bean的作用域</h2><table>
<thead>
<tr>
<th align="left">Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td>
<td>(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td>
<td>Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td>
<td>Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td>
<td>Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td>
<td>Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td>
<td>Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<ol>
<li><p>singleton</p>
<pre><code class="xml"> &lt;bean name=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot; p:age=&quot;18&quot; p:name=&quot;shanzj&quot; scope=&quot;singleton&quot;/&gt;</code></pre>
<p><strong>默认是单例模式</strong></p>
<p><img src="http://cdn.gvssimux.com/image-20200615193846405.png" alt="image-20200615193846405"></p>
</li>
<li><p>The Prototype Scope</p>
<p>原型模式：每次从容器中get的时候，都会产生一个新对象！</p>
<pre><code class="xml"> &lt;bean name=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot; p:age=&quot;18&quot; p:name=&quot;shanzj&quot; scope=&quot;prototype&quot;/&gt;</code></pre>
<p><img src="http://cdn.gvssimux.com/image-20200622200532161.png" alt="image-20200622200532161"></p>
</li>
<li><p>其余的Request、Session、Application、websocket 只能在web开发中使用到</p>
</li>
</ol>
<h1 id="7、Bean的自动装配"><a href="#7、Bean的自动装配" class="headerlink" title="7、Bean的自动装配"></a>7、Bean的自动装配</h1><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下中自动寻找，并自动给bean装配属性！</li>
</ul>
<p>在Spring中有三种装配的方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配Bean【重要】</li>
</ol>
<h2 id="7-1、测试"><a href="#7-1、测试" class="headerlink" title="7.1、测试"></a>7.1、测试</h2><p>环境搭建：一个人有两个宠物</p>
<p>dog</p>
<pre><code class="java">public class Dog {
    public void shout(){
        System.out.println(&quot;汪&quot;);
    }
}</code></pre>
<p>cat</p>
<pre><code class="java">public class Cat {
    public void shout(){
        System.out.println(&quot;喵&quot;);
    }
}</code></pre>
<p>People</p>
<pre><code class="java">public class People {
    private Cat cat;
    private Dog dog;
    private String name;
    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;cat=&quot; + cat +
                &quot;, dog=&quot; + dog +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
    public Cat getCat() {
        return cat;
    }
    public void setCat(Cat cat) {
        this.cat = cat;
    }
    public Dog getDog() {
        return dog;
    }
    public void setDog(Dog dog) {
        this.dog = dog;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
<h2 id="7-2、ByName自动装配"><a href="#7-2、ByName自动装配" class="headerlink" title="7.2、ByName自动装配"></a>7.2、ByName自动装配</h2><pre><code class="xml">     &lt;bean id=&quot;cat&quot; class=&quot;com.shanzj.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.shanzj.pojo.Dog&quot;/&gt;
&lt;!--
    byName:会自动在容器上下文查找，和自己对象set方法后面的值对应的bean的id！际setBeanId(...)..
--&gt;
    &lt;bean name=&quot;people&quot; class=&quot;com.shanzj.pojo.People&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;shanzj&quot;/&gt;
    &lt;/bean&gt;</code></pre>
<p>ps：在这里要充分理解其中的含义，比如说将cat的bean-id改为cat1或Cat时会报“空指针异常”。</p>
<h2 id="7-3、ByType自动装配"><a href="#7-3、ByType自动装配" class="headerlink" title="7.3、ByType自动装配"></a>7.3、ByType自动装配</h2><pre><code class="xml">    &lt;bean id=&quot;cat&quot; class=&quot;com.shanzj.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.shanzj.pojo.Dog&quot;/&gt;
&lt;!--
    byType:会自动在容器上下文查找，和自己对象中所包含的属性类型相同的 bean的id！
--&gt;
    &lt;bean name=&quot;people&quot; class=&quot;com.shanzj.pojo.People&quot; autowire=&quot;byType&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;shanzj&quot;/&gt;
    &lt;/bean&gt;</code></pre>
<p>ps：在这里也可以将bean-id删去，因为时根据类型查找的嘛，但如果这有两个cat或者两个dog就会报错。</p>
<p><strong>byName和byType都需要set方法</strong></p>
<p> ==byName：set方法名 和 bean的id名 (容器里可以有多个dog，但要注意Dao.java中的set方法名字)==</p>
<p> ==byType：bean对应的类 和 要自动装配的bean对应的类的属性（容器里不能有多个dog）==</p>
<h2 id="7-4、使用注解实现自动装配"><a href="#7-4、使用注解实现自动装配" class="headerlink" title="7.4、使用注解实现自动装配"></a>7.4、使用注解实现自动装配</h2><p>jdk看1.5支持的注解，Spring2.5就支持了</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.”（基于注释的配置的引入提出了这样一个问题:这种方法是否比XML“更好”。简短的回答是“视情况而定”。）</p>
<p>要使用注解须知：</p>
<ol>
<li><p>导入约束 context约束( xmlns:context=”<a href="http://www.springframework.org/schema/context“" target="_blank" rel="noopener">http://www.springframework.org/schema/context“</a>)</p>
</li>
<li><p><strong>配置注解的支持</strong></p>
<pre><code class="xml"> &lt;context:annotation-config/&gt;</code></pre>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
         https://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
     &lt;context:annotation-config/&gt;
 &lt;/beans&gt;</code></pre>
</li>
<li><p>自动装配</p>
<ul>
<li><p><a href="https://github.com/Autowired" target="_blank" rel="noopener">@Autowired</a></p>
<p>直接在属性上添加使用，也可以在set方法上添加使用</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
  public class People {
 private Cat cat;
      @Autowired            //加在属性上
 private Dog dog;
      private String name;
      @Override
      public String toString() {
     return &quot;People{&quot; +
                  &quot;cat=&quot; + cat +
                  &quot;, dog=&quot; + dog +
                  &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                  &#39;}&#39;;
      }
      public Cat getCat() {
          return cat;
      }
      @Autowired                //加在set方法上使用！
      public void setCat(Cat cat) {
          this.cat = cat;
      }
      public Dog getDog() {
          return dog;
      }
      public void setDog(Dog dog) {
          this.dog = dog;
      }
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
  }</code></pre>
<p>同时Autowired 也可不必写set方法，前提是自动装配的对象在IOC容器（或者叫Spring容器，bean容器 但IOC容器是正规叫法）中我，其符合byType，也就是说beans.xml中的BeanId可以不和要配置的属性名一致，比如</p>
<pre><code class="xml">  &lt;bean id=&quot;dog111瓦s大213大&quot; class=&quot;com.shanzj.pojo.Dog&quot;/&gt;</code></pre>
<p>注意：大部分是说先按byType，然后有相同时再byName</p>
</li>
</ul>
</li>
</ol>
<pre><code class="java">@Nullable  
    //测试
    //如果显示定义了Autowired的required的属性为false，说明这个对象为null，否则不能为空
    @Autowired(required = false)
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
@Qualifier
    //如果@Autowired自动装配的环境比较复杂，自动装配无法通过@Autowired完成时，需要配合@Qualifer去添加限定符，指定一个bean对象注入
    public class People {
        @Autowired
        private Cat cat;
        @Qualifier(&quot;dog11&quot;)   // &lt;------
        @Autowired
        private Dog dog;
        private String name;
        @Override
        public String toString() {
            return &quot;People{&quot; +
                    &quot;cat=&quot; + cat +
                    &quot;, dog=&quot; + dog +
                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &#39;}&#39;;
        }
        public Cat getCat() {
            return cat;
        }
        public Dog getDog() {
            return dog;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }

//@Resource（在JDK11中被移出了）集成了@Autowired@Qualifier，但在大部分开发中不怎么使用，因为效率比前者要低点
    public class People {
        @Resource
        private Cat cat;
        @Resource(name = &quot;dog11&quot;)
        private Dog dog;
        private String name;
        @Override
        public String toString() {
            return &quot;People{&quot; +
                    &quot;cat=&quot; + cat +
                    &quot;, dog=&quot; + dog +
                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &#39;}&#39;;
        }
        public Cat getCat() {
            return cat;
        }
        public Dog getDog() {
            return dog;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
</code></pre>
<pre><code class="xml">&lt;beans&gt;
    &lt;bean id=&quot;cat&quot; class=&quot;com.shanzj.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog1112&quot; class=&quot;com.shanzj.pojo.Dog&quot;/&gt;
    &lt;bean id=&quot;dog11&quot; class=&quot;com.shanzj.pojo.Dog&quot;/&gt;
    &lt;bean name=&quot;people&quot; class=&quot;com.shanzj.pojo.People&quot;/&gt;
&lt;/beans&gt;</code></pre>
<p>4.总结</p>
<p><strong><a href="https://github.com/Resource" target="_blank" rel="noopener">@Resource</a>和<a href="https://github.com/Autowired" target="_blank" rel="noopener">@Autowired</a>的区别</strong></p>
<ul>
<li><p>都是用来自动装配的，都可以放在属性的字段上</p>
</li>
<li><p>实现方式：先按byType，然后有相同时再byName(不太确定）</p>
</li>
<li><p>如果命名不一致同时出现多个同类型时，可以分别用<a href="https://github.com/Resource" target="_blank" rel="noopener">@Resource</a>(name = “dog11”)和</p>
<p><a href="https://github.com/Qualifier" target="_blank" rel="noopener">@Qualifier</a>(“dog11”) <a href="https://github.com/Autowired" target="_blank" rel="noopener">@Autowired</a>来指定</p>
</li>
<li><p>执行顺序不同<a href="https://github.com/Autowired" target="_blank" rel="noopener">@Autowired</a>———byType，byName <a href="https://github.com/Resource" target="_blank" rel="noopener">@Resource</a>——-byName，byType</p>
</li>
</ul>
<h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><p>在Spring4之后，要使用注解开发，必须保证AOP的包导入了</p>
<p><img src="http://cdn.gvssimux.com/image-20200708120022792.png" alt="image-20200708120022792"></p>
<p>使用注解需要导入context约束，增加注解的支持</p>
<ol>
<li><p>bean</p>
<pre><code class="xml"> @Component  //等价于&lt;bean id=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot;/&gt;</code></pre>
</li>
<li><p>属性如何注入</p>
<pre><code class="java"> @Component  
//等价于&lt;bean id=&quot;user&quot; class=&quot;com.shanzj.pojo.User&quot;/&gt;
 public class User {
     @Value(&quot;shanzj&quot;)    
     //相当于&lt;property name=&quot;name&quot; value=&quot;shanzj&quot;/&gt;
     public String name;
 }</code></pre>
</li>
<li><p>衍生的注解</p>
<p><a href="https://github.com/Component" target="_blank" rel="noopener">@Component</a> 有一些衍生注解，我们在web开发中，会按照mvc三层架构分层</p>
<ul>
<li><p>dao 【<a href="https://github.com/Repository" target="_blank" rel="noopener">@Repository</a>】</p>
</li>
<li><p>service 【<a href="https://github.com/Service" target="_blank" rel="noopener">@Service</a>】</p>
</li>
<li><p>controller 【<a href="https://github.com/Controller" target="_blank" rel="noopener">@Controller</a>】</p>
<p>这四个注解的功能都是一样的，都是代表将某给类注册的IOC容器中，然后装配bean</p>
</li>
</ul>
</li>
<li><p>自动装配</p>
<p><a href="https://github.com/Autowired" target="_blank" rel="noopener">@Autowired</a></p>
<p><a href="https://github.com/Nullable" target="_blank" rel="noopener">@Nullable</a></p>
<p><a href="https://github.com/Resource" target="_blank" rel="noopener">@Resource</a> 见7.4</p>
</li>
<li><p>作用域</p>
<p>单例模式 <a href="https://github.com/Scope" target="_blank" rel="noopener">@Scope</a>(“singleton”)</p>
<p>原型模式 <a href="https://github.com/Scope" target="_blank" rel="noopener">@Scope</a>(“Prototype”) 见6.4bean的作用域</p>
</li>
<li><p>小结</p>
<p>xml与注解对比：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单</li>
<li>注解：不是自己的类使用不了，维护现对复杂</li>
</ul>
</li>
<li><p>xml与注解的最佳实践：</p>
<ul>
<li><p>xml用来管理bean</p>
</li>
<li><p>而注解来注入属性</p>
</li>
<li><p>在使用过程中要注意，必须让注解生效的话，就需要开启注解的支持和扫包</p>
</li>
</ul>
</li>
</ol>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.shanzj&quot;/&gt;    &lt;context:annotation-config/&gt;</code></pre>
<h1 id="9、使用Java的方式去配置Spring"><a href="#9、使用Java的方式去配置Spring" class="headerlink" title="9、使用Java的方式去配置Spring"></a>9、使用Java的方式去配置Spring</h1><p>现在我们完全不用Spring 的xml去配置，全都交于java来做</p>
<p>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能</p>
<p><img src="http://cdn.gvssimux.com/image-20200708222515713.png" alt="image-20200708222515713"></p>
<p><strong>User.java 实体类</strong></p>
<pre><code class="java">//这里这个注解的意思，就是说明这个类被Spring接管了，也就是注册到了容器中
@Component
public class User {
    @Value(&quot;单子健&quot;)       //属性注入值
    private  String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
<p><strong>ShanzjConfig.java 配置文件(配置类)</strong></p>
<pre><code class="java">@Configuration                      
//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个Component, @Configuration代表一个配置类，就和我们之前看的beans.xml一样
@ComponentScan(&quot;com.shanzj.pojo&quot;)   
//如果不扫包的话，在test中，使用不了类名去获取对象User user = (User) context.getBean(&quot;user&quot;);
@Import(ShanzjConfig2.class)
//导入多个配置文件
public class ShanzjConfig {
    //注册一个bean，就相当于我们之前写的bean标签，
    // bean-id==方法名即为getUser
    // bean-class==方法的返回值return new User()
    @Bean
    public User getUser(){
        return new User();  //就是返回要注入到bean的对象
    }
}</code></pre>
<p><strong>Test.java 测试类</strong></p>
<p>注意：</p>
<ul>
<li>这里的IOC容器中有2个user 一个通过getUser去取一个通过user去取</li>
<li>ShanzjConfig.class也可替换为”com.shanzj.config”</li>
</ul>
<pre><code class="java">@Test
public void test01(){
    ApplicationContext context = new AnnotationConfigApplicationContext(ShanzjConfig.class);
    User getUser = (User) context.getBean(&quot;getUser&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    System.out.println(getUser);
    System.out.println(user);
}</code></pre>
<p><strong>这种纯java的配置方式，在SpringBoot中随处可见</strong></p>
<h1 id="10、代理模式"><a href="#10、代理模式" class="headerlink" title="10、代理模式"></a>10、代理模式</h1><p>为什么要学习代理模式？因为这就是SpringAOP的底层。SpringAOP和SpringMVC面试必问</p>
<p>代理模式的分类：</p>
<ul>
<li><p>静态代理</p>
</li>
<li><p>动态代理</p>
<p><img src="http://cdn.gvssimux.com/image-20200716175153840.png" alt="image-20200716175153840"></p>
</li>
</ul>
<h2 id="10-1、静态代理"><a href="#10-1、静态代理" class="headerlink" title="10.1、静态代理"></a>10.1、静态代理</h2><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<p>代理模式的好处</p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li>
<li>公共业务也就交给了代理角色，实现了业务的分工</li>
<li>公共业务发生拓展的时候，方便集中管理</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，开发效率就变低了</li>
</ul>
<p>案例：</p>
<p>1.接口</p>
<pre><code class="java">//租房
public interface Rent {
    public void rent();
}</code></pre>
<p>2.真实角色</p>
<pre><code class="java">//房东
public class HouseMaster implements Rent{
    public void rent() {
        System.out.println(&quot;房东要出租房子&quot;);
    }
}</code></pre>
<p>3.代理角色</p>
<pre><code class="java">public class Proxy implements Rent{
    private HouseMaster houseMaster;
    public Proxy(HouseMaster houseMaster) {
        this.houseMaster = houseMaster;
    }
    public Proxy() {
    }
    public void rent() {
        seeHouse();
        houseMaster.rent();
        hetong();
        fare();
    }
    //看房
    public void seeHouse(){
        System.out.println(&quot;中介带你看房子&quot;);
    }
    //签合同
    public void hetong(){
        System.out.println(&quot;签合同&quot;);
    }
    //收中介费
    public void fare(){
        System.out.println(&quot;收中介费&quot;);
    }
}</code></pre>
<p>4.客户端访问代理角色</p>
<pre><code class="java">public class Client {
    public static void main(String[] args) {
        HouseMaster houseMaster = new HouseMaster();
        //代理，中介帮房东租房子，但是代理角色(中介)会有一些附属操作
        Proxy proxy = new Proxy(houseMaster);
        //你不用面对房东，直接找中介租房即可
        proxy.rent();
    }
}</code></pre>
<h2 id="10-2、静态代理2"><a href="#10-2、静态代理2" class="headerlink" title="10.2、静态代理2"></a>10.2、静态代理2</h2><p>AOP</p>
<p><img src="http://cdn.gvssimux.com/image-20200716223456090.png" alt="image-20200716223456090"></p>
<h2 id="10-3、动态代理"><a href="#10-3、动态代理" class="headerlink" title="10.3、动态代理"></a>10.3、动态代理</h2><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的</li>
<li>动态代理分为两大类：1.基于接口的动态代理 2.基于类的动态代理<ul>
<li>基于接口——JDK的动态代理【使用这个】</li>
<li>基于类：cglib</li>
<li>java字节码实现：javalist</li>
</ul>
</li>
</ul>
<p>需要了解两个类，Proxy，InvocationHandler</p>
<p>动态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li>
<li>公共业务也就交给了代理角色，实现了业务的分工</li>
<li>公共业务发生拓展的时候，方便集中管理</li>
<li>一个动态代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要实现了同一个接口即可</li>
</ul>
<p>案例</p>
<p>1.接口</p>
<pre><code class="java">public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void query();
}</code></pre>
<p>2.真实角色</p>
<pre><code class="java">//真实对象
public class UserServiceImpl implements UserService{
    public void add() {
        System.out.println(&quot;增加了一个用户&quot;);
    }
    public void delete() {
        System.out.println(&quot;删除了一个用户&quot;);
    }
    public void update() {
        System.out.println(&quot;修改了一个用户&quot;);
    }
    public void query() {
        System.out.println(&quot;查询了一个用户&quot;);
    }
}</code></pre>
<p>3.代理角色</p>
<pre><code class="java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
//等会用这个类去自动生成代理类
public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Object target;   //可替换
    public void setTarget(Object target) {
        this.target = target;
    }
    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }
    //处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质就是使用反射机制
        Object result = method.invoke(target, args);
        log(method.getName()); //反射得到方法名
        return null;
    }
    public void  log(String msg){
        System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);
    }
}</code></pre>
<p>4.客户端访问</p>
<pre><code class="java">public class Client {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        //代理
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //设置代理的对象，即userService
        pih.setTarget(userService);
        //动态的生成代理对象
        UserService proxy = (UserService) pih.getProxy();
        proxy.query();
    }
}</code></pre>
<h1 id="11、AOP"><a href="#11、AOP" class="headerlink" title="11、AOP"></a>11、AOP</h1><h2 id="11-1、什么是AOP"><a href="#11-1、什么是AOP" class="headerlink" title="11.1、什么是AOP"></a>11.1、什么是AOP</h2><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现 程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的 一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使 得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="http://cdn.gvssimux.com/image-20200718095159793.png" alt="image-20200718095159793"></p>
<h2 id="11-2AOP在SPring中的作用"><a href="#11-2AOP在SPring中的作用" class="headerlink" title="11.2AOP在SPring中的作用"></a>11.2AOP在SPring中的作用</h2><p><strong>声明式事务；允许用户自定义切面</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要 关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="http://cdn.gvssimux.com/image-20200718095355844.png" alt="image-20200718095355844"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h2 id="11-3使用Spring实现AOP"><a href="#11-3使用Spring实现AOP" class="headerlink" title="11.3使用Spring实现AOP"></a>11.3使用Spring实现AOP</h2><p>首先需要导包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h3 id="方法一：通过Spring-API实现【主要是SpringAPI接口实现】"><a href="#方法一：通过Spring-API实现【主要是SpringAPI接口实现】" class="headerlink" title="方法一：通过Spring API实现【主要是SpringAPI接口实现】"></a>方法一：通过Spring API实现【主要是SpringAPI接口实现】</h3><p>业务接口</p>
<pre><code class="java">public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void query();
}</code></pre>
<p>业务接口的实现类</p>
<pre><code class="java">//真实对象
public class UserServiceImpl implements UserService{
    public void add() {
        System.out.println(&quot;增加了一个用户&quot;);
    }
    public void delete() {
        System.out.println(&quot;删除了一个用户&quot;);
    }
    public void update() {
        System.out.println(&quot;修改了一个用户&quot;);
    }
    public void query() {
        System.out.println(&quot;查询了一个用户&quot;);
    }
}</code></pre>
<p>业务增强类，这里举一个前置增强一个后置增强为例子</p>
<pre><code class="java">import org.springframework.aop.MethodBeforeAdvice;
import java.lang.reflect.Method;
public class Log implements MethodBeforeAdvice {
    //method : 要执行的目标对象的方法  
    // objects : 被调用的方法的参数(arg)    
    // o : 目标对象(object)
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
    }
}</code></pre>
<pre><code class="java">import org.springframework.aop.AfterReturningAdvice;
import java.lang.reflect.Method;
public class AfterLog implements AfterReturningAdvice {
    // o 返回值    returnValue
    // method被调用的方法    
    // args 被调用的方法的对象的参数    
    // o1 被调用的目标对象   targer
    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable {
        System.out.println(&quot;执行了&quot; + o1.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法,&quot;+&quot;返回值：&quot;+o);
    }
}</code></pre>
<p>然后在Spring中注册，并实现AOP切入，注意导入约束</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!--注册bean--&gt;
        &lt;bean id=&quot;UserService&quot; class=&quot;com.shanzj.service.UserServiceImpl&quot;/&gt;
        &lt;bean id=&quot;log&quot; class=&quot;com.shanzj.log.Log&quot;/&gt;
        &lt;bean id=&quot;afterLog&quot; class=&quot;com.shanzj.log.AfterLog&quot;/&gt;
        &lt;!--aop的配置--&gt;
        &lt;aop:config&gt;
            &lt;!--切入点  expression:表达式匹配要执行的方法--&gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;/&gt;
            &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
            &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;</code></pre>
<p>测试</p>
<pre><code class="java">public class Test {
    @org.junit.Test
    public void test01(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) context.getBean(&quot;UserService&quot;);
        userService.query();
    }
}</code></pre>
<h3 id="方式二：自定义类来实现AOP【主要是切面定义】"><a href="#方式二：自定义类来实现AOP【主要是切面定义】" class="headerlink" title="方式二：自定义类来实现AOP【主要是切面定义】"></a>方式二：自定义类来实现AOP【主要是切面定义】</h3><p>将业务增强类替换为</p>
<pre><code class="java">public class DiyPointCut {
    public void before(){
        System.out.println(&quot;方法执行前&quot;);
    }
    public void after(){
        System.out.println(&quot;方法执行后&quot;);
    }
}</code></pre>
<p>applicationContext</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!--注册bean--&gt;
        &lt;bean id=&quot;UserService&quot; class=&quot;com.shanzj.service.UserServiceImpl&quot;/&gt;
        &lt;bean id=&quot;log&quot; class=&quot;com.shanzj.log.Log&quot;/&gt;
        &lt;bean id=&quot;afterLog&quot; class=&quot;com.shanzj.log.AfterLog&quot;/&gt;
        &lt;!--aop的配置--&gt;
        &lt;!--&lt;aop:config&gt;
            &amp;lt;!&amp;ndash;切入点  expression:表达式匹配要执行的方法&amp;ndash;&amp;gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;/&gt;
            &amp;lt;!&amp;ndash;执行环绕; advice-ref执行方法 . pointcut-ref切入点&amp;ndash;&amp;gt;
            &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:config&gt;--&gt;
        &lt;!--方式二：--&gt;
        &lt;bean id=&quot;diy&quot; class=&quot;com.shanzj.diy.DiyPointCut&quot;/&gt;
        &lt;aop:config&gt;
            &lt;!--自定义切面，ref要引用的类--&gt;
            &lt;aop:aspect ref=&quot;diy&quot;&gt;
                &lt;!--切入点(切面)--&gt;
                &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;/&gt;
                &lt;!--通知--&gt;
                &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
                &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;</code></pre>
<p>其他的不用动，但这里就不能用反射了。</p>
<h3 id="方法三：使用注解实现"><a href="#方法三：使用注解实现" class="headerlink" title="方法三：使用注解实现"></a>方法三：使用注解实现</h3><p>业务增强类</p>
<pre><code class="java">@Aspect
public class AnnotionPointCut {
    @Before(&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;)
    public void before(){
        System.out.println(&quot;方法执行之前===&quot;);
    }
    @After(&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;)
    public void after(){
        System.out.println(&quot;方法执行后==&quot;);
    }
    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理的切入点
    @Around(&quot;execution(* com.shanzj.service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;环绕前&quot;);
        //执行方法
        System.out.println(joinPoint.getSignature());
        Object proceed = joinPoint.proceed();
        System.out.println(&quot;环绕后&quot;);
    }
}</code></pre>
<p>applicationContext.xml</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!--注册bean--&gt;
        &lt;bean id=&quot;UserService&quot; class=&quot;com.shanzj.service.UserServiceImpl&quot;/&gt;
        &lt;bean id=&quot;log&quot; class=&quot;com.shanzj.log.Log&quot;/&gt;
        &lt;bean id=&quot;afterLog&quot; class=&quot;com.shanzj.log.AfterLog&quot;/&gt;
        &lt;!--方法三--&gt;
        &lt;bean id=&quot;annotionPointCut&quot; class=&quot;com.shanzj.diy.AnnotionPointCut&quot;/&gt;
        &lt;!--开启注解支持      JDK(默认proxy-target-class=&quot;false&quot;) cglib(proxy-target-class=&quot;true&quot;)--&gt;
        &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="12、整合Mybatis"><a href="#12、整合Mybatis" class="headerlink" title="12、整合Mybatis"></a>12、整合Mybatis</h1><p>步骤:</p>
<ol>
<li>导入相关jar包<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql数据库</li>
<li>Spring相关的</li>
<li>AOP织入</li>
<li>mybatis-spring【新】</li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h2 id="12-1、回忆mybatis"><a href="#12-1、回忆mybatis" class="headerlink" title="12.1、回忆mybatis"></a>12.1、回忆mybatis</h2><ol>
<li><p>编写实体类</p>
<pre><code class="java"> import lombok.Data;
 @Data
 public class User {
     private int id;
     private String name;
     private String pwd;
 }</code></pre>
</li>
<li><p>编写核心配置文件</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
 &lt;!DOCTYPE configuration
         PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
         &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
 &lt;configuration&gt;
     &lt;typeAliases&gt;
         &lt;package name=&quot;com.shanzj.pojo&quot;/&gt;
     &lt;/typeAliases&gt;
     &lt;environments default=&quot;development&quot;&gt;
         &lt;environment id=&quot;development&quot;&gt;
             &lt;transactionManager type=&quot;JDBC&quot;/&gt;
             &lt;dataSource type=&quot;POOLED&quot;&gt;
                 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                 &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                 &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
             &lt;/dataSource&gt;
         &lt;/environment&gt;
     &lt;/environments&gt;
     &lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--&gt;
     &lt;mappers&gt;
         &lt;mapper resource=&quot;com/shanzj/dao/UserMapper.xml&quot;/&gt;
     &lt;/mappers&gt;
 &lt;/configuration&gt;</code></pre>
</li>
<li><p>编写接口</p>
<pre><code class="java"> import com.shanzj.pojo.User;
 import java.util.List;
 public interface UserMapper {
     public List&lt;User&gt; selectUser();
 }</code></pre>
</li>
<li><p>编写Mapper.xml</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
 &lt;!DOCTYPE mapper
         PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
         &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 &lt;mapper namespace=&quot;com.shanzj.mapper.UserMapper&quot;&gt;
     &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt;
        select * from user;
    &lt;/select&gt;
 &lt;/mapper&gt;</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java"> @org.junit.Test
 public void test02() throws IOException {
     String resource = &quot;mybatis-config.xml&quot;;
     InputStream inputStream = Resources.getResourceAsStream(resource);
     SqlSession sqlSession = new SqlSessionFactoryBuilder().build(inputStream).openSession();
     UserMapper mapper = sqlSession.getMapper(UserMapper.class);
     List&lt;User&gt; users = mapper.selectUser();
     for (User user : users) {
         System.out.println(user);
     }
 }</code></pre>
</li>
</ol>
<h2 id="12-2、Mybatis-Spring-多了一个接口实现类"><a href="#12-2、Mybatis-Spring-多了一个接口实现类" class="headerlink" title="12.2、Mybatis-Spring(多了一个接口实现类)"></a>12.2、Mybatis-Spring(多了一个接口实现类)</h2><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!--DataSource:使用Spring的数据源替换mybatis的配置  c3p0 dbcp  druid 在这使用Spring的JDBC！--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
        &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/shanzj/mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<ol>
<li><p>编写数据源配置</p>
<pre><code class="xml">&lt;!--DataSource:使用Spring的数据源替换mybatis的配置  c3p0 dbcp  druid 在这使用Spring的JDBC！--&gt;
 &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
     &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
     &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
     &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
     &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
 &lt;/bean&gt;</code></pre>
</li>
<li><p>sqlSessionFactory</p>
<pre><code class="xml"> &lt;!--sqlSessionFactory--&gt;
 &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
     &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
     &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/shanzj/mapper/*.xml&quot;/&gt;
 &lt;/bean&gt;</code></pre>
</li>
<li><p>sqlSession</p>
<pre><code class="xml"> &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
     &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
 &lt;/bean&gt;</code></pre>
</li>
<li><p>将userMapper的接口实现类注入到Spring中去</p>
<pre><code class="xml">&lt;beans&gt; 
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop
    https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
 &lt;import resource=&quot;spring-dao.xml&quot;/&gt;
 &lt;!----&gt;
 &lt;bean id=&quot;userMapperImpl&quot; class=&quot;com.shanzj.mapper.UserMapperImpl&quot;&gt;
     &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
 &lt;/bean&gt;
 &lt;!--方法二，在这里就不用在spring-dao.xml中去写SqlSessionTemplate即sqlSession就省略了--&gt;
 &lt;bean id=&quot;userMapperImpl2&quot; class=&quot;com.shanzj.mapper.UserMapperImpl2&quot;&gt;
     &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">public class Test {
     @org.junit.Test
        public void test01() throws IOException {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapper userMapperImpl = context.getBean(&quot;userMapperImpl&quot;, UserMapper.class);
        List&lt;User&gt; users = userMapperImpl.selectUser();
        for (User user : users) {
            System.out.println(user);
        }
    }
}</code></pre>
</li>
</ol>
<h1 id="13、声明式事务"><a href="#13、声明式事务" class="headerlink" title="13、声明式事务"></a>13、声明式事务</h1><h2 id="13-1、回顾事务"><a href="#13-1、回顾事务" class="headerlink" title="13.1、回顾事务"></a>13.1、回顾事务</h2><ul>
<li>把一组业务当成一个业务来做，要么都成功，要么都失败。</li>
<li>事务在项目开发中，十分重要，涉及到数据的一致性问题，不得马虎！</li>
<li>确保完整性和一致性；</li>
</ul>
<p>事务的ACID原则</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离型<ul>
<li>多个业务操作一个资源的时候，不会影响数据的正确性，防止数据损坏</li>
</ul>
</li>
<li>持久性<ul>
<li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到了存储器中</li>
</ul>
</li>
</ul>
<p>13.2、Spring中的事务管理器</p>
<ul>
<li>声明式事务：AOP横切进去的不需要改原有代码</li>
<li>编程时事务：需要改动代码进行事务的管理</li>
</ul>
<p>思考：</p>
<p>为什么要配置事务？</p>
<ul>
<li>如果不配置事务的话，可能存在数据提交不一致的情况下</li>
<li>如果我们不在Spring中去配置申明式事务，我们就需要在代码中手动配置事务</li>
<li>事务在项目的开发中十分重要</li>
</ul>
]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/Mr-lee-MQ.hithub.io/2020/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法<a id="more"></a></h1><h2 id="1、数据结构和算法内容介绍"><a href="#1、数据结构和算法内容介绍" class="headerlink" title="1、数据结构和算法内容介绍"></a>1、数据结构和算法内容介绍</h2><h3 id="1-1、字符串匹配问题"><a href="#1-1、字符串匹配问题" class="headerlink" title="1.1、字符串匹配问题"></a>1.1、字符串匹配问题</h3><ul>
<li><p>有一个字符串 str 1 = “”硅硅谷 尚硅谷你尚硅 尚硅谷 你尚硅谷你尚硅你好”“，和一个子串 str2 = ”尚硅谷 你尚硅你“ </p>
</li>
<li><p>现在要判断str1是否含有str2,如果存在，就返回第一次出现的位置，如果没有，则返回-1</p>
</li>
<li><p>要求用最快的速度来完成匹配</p>
</li>
<li><p>你的思路是什么？</p>
</li>
</ul>
<p><strong>方法1：暴力匹配</strong></p>
<p><strong>方法2：KMP算法（正解）</strong>（部分匹配表）</p>
<h3 id="1-2、汉诺塔游戏"><a href="#1-2、汉诺塔游戏" class="headerlink" title="1.2、汉诺塔游戏"></a>1.2、汉诺塔游戏</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125163727388.png" alt="image-20210125163727388"></p>
<h3 id="1-3、八皇后问题"><a href="#1-3、八皇后问题" class="headerlink" title="1.3、八皇后问题"></a>1.3、八皇后问题</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125164322087.png" alt="image-20210125164322087"></p>
<h3 id="1-4、骑士周游问题"><a href="#1-4、骑士周游问题" class="headerlink" title="1.4、骑士周游问题"></a>1.4、骑士周游问题</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2020/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125165449719.png" alt="image-20210125165449719"></p>
]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/Mr-lee-MQ.hithub.io/2020/10/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程 "></a>网络编程 <a id="more"></a></h1><p>TCP:发送请求通信</p>
<p>UDP:接收通信请求</p>
<p><strong>网络编程的目的</strong>：传播交流信息，数据交换，通信。</p>
<p><strong>想要达到这个效果需要什么：</strong></p>
<ul>
<li>如何准确定位网络上的一台主机  192.168.16.124：端口号，定位到这个计算机上的某个资源</li>
<li>找到了这个主机，如何传输数据</li>
</ul>
<p>javaweb: 网页编程 B/S</p>
<p>网络编程: TCP/IP   C/S</p>
<h2 id="网络通信的要素"><a href="#网络通信的要素" class="headerlink" title="网络通信的要素"></a>网络通信的要素</h2><p>如何实现网络的通信？</p>
<p>通信双方的地址</p>
<ul>
<li>ip</li>
<li>端口号</li>
<li>192.168.16,124:端口号</li>
</ul>
<p>规则：网络通信的协议</p>
<p><a href="https://www.wailian.work/image/Qmvcrc" target="_blank" rel="noopener"><img src="https://p.130014.xyz/2020/12/12/sp201015_081754.png" alt="sp201015_081754.png"></a></p>
<p>小结：</p>
<p>网络编程有两个主要的问题</p>
<ul>
<li>如何准确的定位到网络上的一台或者多台主机</li>
<li>找到主机后如何进行通信</li>
</ul>
<p>网络编程中的要素</p>
<ul>
<li>IP和端口号       IP</li>
<li>网络通信协议      UDP TCP</li>
</ul>
<p>java万物皆对象</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>ip地址：inetAddress</p>
<ul>
<li>唯一定位一台网络上计算机</li>
<li>127.0.2.1：本机locatlhost</li>
<li>ip地址的分类<ul>
<li>ipv4/ipv6<ul>
<li>IPV4:127.0.0.1    4个字节组成。0~255</li>
<li>IPV6:fe80::9458:458a:5a22:4686%16, 128位。8个无符号整数</li>
</ul>
</li>
<li>公网(互联网)—私网(局域网)<ul>
<li>ABCD类地址</li>
<li>192.168.xxx.xx专门给组织内部使用的。</li>
</ul>
</li>
</ul>
</li>
<li>域名:记忆ip问题<ul>
<li>IP:<a href="http://www.vip.com" target="_blank" rel="noopener">www.vip.com</a></li>
</ul>
</li>
</ul>
<pre><code class="java">//测试IP
public class TestInetAddress{
    public static void main(String[] args){
       try{
           //查询本机Ip地址 三种方法
           InetAddress inetAddress1 = InetAddress.getByName(&quot;127.0.0.1&quot;);
           System.out.println(inetAddress1);

           InetAddress inetAddress3 = InetAddress.getByName(&quot;localhost&quot;);
           System.out.println(inetAddress3);

           InetAddress inetAddress4 = InetAddress.getLocalHost();                                           System.out.println(inetAddress4);



       }catch(UnknowHostException e){
           e.printStrackTrace();
       }
    }</code></pre>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口表示计算机上的一个程序的进程。</p>
<ul>
<li><p>不同的进程有不同的端口号。端口号不能重复，用于区分软件</p>
</li>
<li><p>被规定0~65535</p>
</li>
<li><p>TCP，UDP：65535*2  tcp：80，udp:80    单个协议下，端口号不能冲突</p>
</li>
<li><p>端口分类</p>
<ul>
<li><p>公有端口 0~1023</p>
<ul>
<li>HTTP：80</li>
<li>HTTPS：443</li>
<li>FTP:21</li>
<li>Telent: 23</li>
</ul>
</li>
<li><p>程序注册端口：1024~49151,分配用户或者程序</p>
<ul>
<li>Tomcat:8080</li>
<li>MySql:3306</li>
<li>Oracle:1521</li>
</ul>
</li>
<li><p>动态，私有:49152~65535</p>
<pre><code class="bash">netstat -ano # 查看所有的端口
netstat -ano|findstr &quot;5900&quot; # 查看指定的端口
tasklist|findstr &quot;8696&quot;  # 查看指定端口的进程</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code class="java">public class TestInetSocketAddress{
    public static void main(String){
        InetSocketAddress socketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 8080);
        InetSocketAddress socketAddress = new InetSocketAddress(&quot;localhost&quot;,8080);
        System.out.println(&quot;socketAddress&quot;);
        System.out.println(&quot;socketAddress2&quot;);

        System.out.println(socketAddress.getAddress());           System.out.println(socketAddress.getHostName());
        //hosts  地址
        System.out.println(socketAddress.getPort());
        //端口


    }
}</code></pre>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>协议：约定，就好比现在说的是普通话</p>
<p>网络通信协议：速率，传输码率，代码结构，传输控制</p>
<p><strong>TCP/IP协议簇</strong>：实际上是一组协议</p>
<p>重要：</p>
<ul>
<li>TCP：用户传输协议</li>
<li>UDP：用户数据报协议</li>
</ul>
<p>出名的协议：</p>
<ul>
<li>TCP：用户传输协议</li>
<li>IP：网络互连协议</li>
</ul>
<p><strong>TCP UDP对比</strong></p>
<p>TCP：打电话</p>
<ul>
<li><p>连接，稳定</p>
</li>
<li><p>三次握手，四次挥手</p>
</li>
<li><p>客户端，服务端</p>
</li>
<li><p>传输完成，释放连接，效率低</p>
</li>
</ul>
<p>UDP：发短信</p>
<ul>
<li><p>不连接，不稳定</p>
</li>
<li><p>客户端，服务端：没有明确的界限</p>
</li>
<li><p>不管有没有准备好，都可以发给你</p>
</li>
<li><p>导弹</p>
</li>
<li><p>DDOS:洪水攻击！（饱和攻击）</p>
</li>
</ul>
<h3 id="TCP实现聊天"><a href="#TCP实现聊天" class="headerlink" title="TCP实现聊天"></a>TCP实现聊天</h3><p>客户端：</p>
<p>1.连接服务器Socket</p>
<p>2.发送消息</p>
<pre><code class="java">//客户端
public class TcpClientDemo01{
    public static void main(String[] args){

        try{
            //1.要知道服务器的地址
            InetAddress serverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);
            int port  = 9999;
            //2.创建一个socket连接
            Socket socket = new Socket(serverIP,port);
            //3.发送消息 io流
            OutputStream os = socket.getOutputStream();
            os.write(&quot;你好，欢迎学习狂神说Java&quot;.getBytes());

        }catch(Exception e){
            e.printStackTrace();
        }



    }
}</code></pre>
<p>服务端：</p>
<p>1.建立服务的端口Server Socket</p>
<p>2.等待用户的连接  accept</p>
<p>3.接收用户的消息</p>
<pre><code class="java">//服务端
public class TcpServerDemo01{
    public static void main(String[] args){
        try{
            //1.得有一个地址
            ServerSocket serverSocket = new ServerSocket(9999);
            //2.等待客户端连接过来
            Socket socket = serverSocket.accept();
            //3.读取客户端的消息
            IputStream is = socket.getInputStream();

            /*
            byte[] buffer = new byte[1024];
            int len;
            while((len=is.read(buffer))!=-1){
                String msg = new String(buffer,0,len);
                System.out.println(msg);
                */

            //管道流
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int lenl;
            while((len=is.read(buffer))!=-1){
                baos.write(buffer,0,len);
            }

            System.out.println(baos.toString());

            }
        }catch(IOException e){
            e.printStackTrace();
        }finally{
        //关闭资源

    }


    }
}</code></pre>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><pre><code class="java">//客户端
public class TcpClientDemo02{
    public static void main(String[] args){
        //1.创建一个Socket连接
         Socket socket = new Socket(InteAddress.getByName(&quot;127.0.0.1&quot;),9000);
        //2.创建一个输出流
        OutputStream os = socket.getOutputStream();
        //3.读取文件
        FileInputStream fis = new FileInputStream(new File(&quot;qinjiang.jpg&quot;));
        //4.写出文件
        byte[] buffer = new byte[1024];
        int len;
        while((len=fis.read(buffer))!=-1){
            os.write(buffer,0,len);
        }
        //通知服务器，我已经结束了
        socket.shutdownOutput();//我已经传输完毕了

        //确定服务器接收完毕，才能断开连接
        InputStream inputStream = socket.getInputStream();
        //String byte[]
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer2 = new byte[1024];
        int len2;
        while((len2=inputStream.read(buffer2))!=-1){
            baos.write(buffer2,0,len2);
        } 
        System.out.println(baos.toString());

        //5.关闭资源
        baos.close();
        inputStream.close();
        fis.close();
        os.close();
        socket.close();
    }
}</code></pre>
<pre><code class="java">//服务端
public class TcpServerDemo02{
    public static void mian(String[] args) throws Exception {        //1.创建服务
        ServerSocket serverSocket = new ServerSocket(9000);
        //2.监听客户端的连接
        serverSocket.accept();//阻塞式监听，会一直等待客户端连接
        //3.获取输入流
        InOutputStream is = socket.getInputStream();
        //4.文件传输
        FileOutputStream fos = new FileOutputStream(new File(&quot;receive.jpg&quot;));
        byte[] buffer = new byte[1024];
        int len;
        while((len=is.read(buffer))!=-1){
            fos.write(buffer, 0, len);
        }
        //通知客户端我接收完毕了
        OutputStream os = socket.getOutputStream();
        os.write(&quot;我接受完毕了，你可以断开了&quot;,getBytes());

        //5.关闭资源
        fos.close();
        is.close();
        socket.close();
        serverSocket.close();
}</code></pre>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>服务端</p>
<ul>
<li>自定义  S</li>
<li>Tomcat服务器   S</li>
</ul>
<p>客户端</p>
<ul>
<li>自定义    C</li>
<li>浏览器    B</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>发短信：不用连接，需要知道对方的地址</p>
<pre><code class="java">//发送端
//不需要连接服务器
public class UdpClientDemo01{
    public static void main(String[] args){
        //1.建立一个Socket
         DatagramSocket socket = new DatagramSocket();
        //2.建个包
        String msg = &quot;你好啊，服务器&quot;;
        //发送给谁
        InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);
        int port = 9000;
        //数据，数据的起始位置，要发送给谁
        DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);

        //3.发送包
        socket.send(packet);
        //4.关闭流
        socket.close();
    }
}</code></pre>
<pre><code class="java">//接收端
//还是要等待客户端的连接
public class UdpServerdemo01{
    public static void main(String[] args) throw Exception{
        //开放端口
        DatagramSocket socket = new Datagramsocket(9000);
        //连接数据包
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);

        socket.receive(packet);//阻塞接收

        System.out.println(packet.getAddress());
        System.out.println(new String(packet.getData(),0,packet.getLength()));

        //关闭连接
        socket.close();

    }
}</code></pre>
<h3 id="在线咨询"><a href="#在线咨询" class="headerlink" title="在线咨询"></a>在线咨询</h3><pre><code class="java">//发送端
public class UdpSenderDemo01{
    public static void main(String[] args){
      DatagramSocket socket = new DatagramSocket(8888);
      //准备数据：控制台读取 System.in
      BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        while(true){
            String data = reader.readLine();
            byte[] datas = data.getBytes();
            DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));

            socket.send(packet);
            if(data.equals(&quot;bye&quot;)){
                break;
            }
        }

        socket.close();
    }
}</code></pre>
<pre><code class="java">//接收端
public class UdpReceiveDemo01{
    public static void main(String[] args) throws Exception{
        DatagramSocket socket = new DatagramSocket(6666);

        while(true){
            //准备接收包裹
            byte[] container = new byte[1024];
            DatagramPacket packet = new DatagramPacket(container,0,container.length);
            socket.receive(packet);//阻塞式接收包裹

            //断开连接  bye
            byte[] data = packet.getData();
            String receiveData = new String(data,0,data.length);

            System.out.println(receiveData);

            if(receiveData.equals(&quot;bye&quot;)){
                break;
            }
        }

    }
}</code></pre>
<h3 id="Udp多线程在线咨询"><a href="#Udp多线程在线咨询" class="headerlink" title="Udp多线程在线咨询"></a>Udp多线程在线咨询</h3><pre><code class="java">
//发送线程
public class TalkSend implements Runnable{
    DatagramSocket socket = null;
    BufferedReader reader = null;

    private int formPort;
    private String toIP;
    private int toPort;

    public TlakSend(int formPort,String toIP,int toPort){
        this.fromPort = formPort;
        this.toIP = toIP;
        this.toPort = toPort;

        try{
            socket = new DatagramSockt(formPort);
             BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        }catch(Exception e){
            e.printStackTrace();
        }
    }

    @Overrode 
    public void run(){
        while(true){
            try{
                String data = reader.readLine();
                byte[] datas = data.getByte();
                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));

                socket.send(packet);
                if(data.equals(&quot;bye&quot;)){
                    break;
                }
            }catch(Exception e){
                e.printStackTrace();
            }
        }
        socket.close();

    }
}</code></pre>
<pre><code class="java">//接收线程
public class TalkReceive implements Runnable{

    DatagramSocket socket = null;
    private int port;
    private String msgFrom;

    public TalkReceive(int port,String msgFrom){
        this.port = port;
        this.msgFrom = msgFrom;
        try{
            socket = new DatagramSocket(port);
        }catch(SocketException e){
            e.printStackTrace();
        }
    }


    @Override
    public void run(){

        while(true){
            try{
                //准备接收包裹
                byte[] container = new byte[1024];
                DatagramPacket packet = new DatagramPacket(container,0,container.length);
                socket.receive(packet);//阻塞式接收包裹

                //断开连接  bye
                byte[] data = packet.getData();
                String receiveData = new String(Data,0,data.length);

                System.out.println(msgFrom+&quot;:&quot;+receiveData);

                if(receiveData.equalus(&quot;bye&quot;)){
                    break;
                }
            }catch(IoExecption e){
                e.printStackTrace();
            }
        }
        socket.close();
    }
}
</code></pre>
<pre><code class="java">//
public class TalkStudent{
   public static void main(String[] args){
       //开启两个线程
       new Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();
       new Thread(new Receive(8888,&quot;老师&quot;)).start();
   } 
}</code></pre>
<pre><code class="java">public class TalkTeacher{
    public static void main(String[] args){
        new Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();
        new Thread(new TalkReceive(9999,&quot;学生&quot;)).start();
    }
}</code></pre>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>同一定位资源符：定位资源的，定位互联网上的某一个资源</p>
<p>DNS 域名解析   <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>    </p>
<pre><code>协议：//ip地址：端口/项目名/资源</code></pre><pre><code class="java">public class URLDemo01{
    public static void main(String[] args){
        URL url = new URL(&quot;http://localhost:8080/helloworld/index.jsp?username=kuangshen&amp;password=123&quot;);
        System.out.println(url.getProtocol());//协议
        System.out.println(url.getHost());//z主机ip
        System.out.println(url.getPort());//端口
        System.out.println(url.getPath());//文件地址
        System.out.println(url.getFile());//文件全路径
        System.out.println(url.getQuery());//参数

    }
}</code></pre>
<pre><code class="java">public class UrlDemo{
    public static void main(String[] args) throws Exception{
        //1.下载地址
        URL url = new URL(&quot;http://localhost:8080/qinjiang/SecurtyFile.txt&quot;);

        //2.连接到这个资源的HTTP
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();

        InputStream inputStream = urlConnection.getInputStream();

        FileOutputStream fos = new FileOutputStream(&quot;SecurityFile.txt&quot;);

        byte[] buffer = new byte[1024];
        int len;
        while((len=inputStream.read(buffer))!=-1){
            fos.write(buffer,0,len);//写出这个数据
        }
        fos.close();
        inputStream.close();
        urlConnection.disconnect();//断开连接


    }
}</code></pre>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/Mr-lee-MQ.hithub.io/2021/02/19/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC<a id="more"></a></h1><p>SSM：Mybatis+Spring+SpringMVC <strong>MVC三层架构</strong></p>
<h2 id="1、-回顾MVC"><a href="#1、-回顾MVC" class="headerlink" title="1、 回顾MVC"></a>1、 回顾MVC</h2><h3 id="1-1、-什么是MVC"><a href="#1-1、-什么是MVC" class="headerlink" title="1.1、 什么是MVC"></a>1.1、 什么是MVC</h3><ul>
<li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码。</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li>
</ul>
<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201114224419311.png" alt="在这里插入图片描述"></p>
<h3 id="1-2、-Model1时代"><a href="#1-2、-Model1时代" class="headerlink" title="1.2、 Model1时代"></a>1.2、 Model1时代</h3><ul>
<li>在web早期的开发中，通常采用的都是Model1。</li>
<li>Model1中，主要分为两层，视图层和模型层。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/202011142247023.png?" alt="在这里插入图片描述"></p>
<p>Model1优点：架构简单，比较适合小型项目开发；</p>
<p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p>
<h3 id="1-3、Model2时代"><a href="#1-3、Model2时代" class="headerlink" title="1.3、Model2时代"></a>1.3、Model2时代</h3><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020111422480281.png" alt="在这里插入图片描述"></p>
<ol>
<li>用户发请求</li>
<li>Servlet接收请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到JSP，由JSP来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<p><strong>职责分析：</strong></p>
<p><strong>Controller：控制器</strong></p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<p><strong>Model：模型</strong></p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<p><strong>View：视图</strong></p>
<ol>
<li>显示页面</li>
</ol>
<p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p>
<h3 id="1-4、回顾Servlet"><a href="#1-4、回顾Servlet" class="headerlink" title="1.4、回顾Servlet"></a>1.4、回顾Servlet</h3><ol>
<li><p>新建一个Maven工程当做父工程！pom依赖！</p>
<pre><code class="xml">&lt;dependencies&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;junit&lt;/groupId&gt;
       &lt;artifactId&gt;junit&lt;/artifactId&gt;
       &lt;version&gt;4.12&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework&lt;/groupId&gt;
       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
       &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
       &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
       &lt;version&gt;2.5&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
       &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
       &lt;version&gt;2.2&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
       &lt;artifactId&gt;jstl&lt;/artifactId&gt;
       &lt;version&gt;1.2&lt;/version&gt;
   &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</li>
<li><p>建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！</p>
</li>
<li><p>导入servlet 和 jsp 的 jar 依赖</p>
<p> 父项目中已导</p>
</li>
<li><p>编写一个Servlet类，用来处理用户的请求</p>
<pre><code class="java">package com.kuang.servlet;
//实现Servlet接口
public class HelloServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       //取得参数
       String method = req.getParameter(&quot;method&quot;);
       if (method.equals(&quot;add&quot;)){
           req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);
      }
       if (method.equals(&quot;delete&quot;)){
           req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);
      }
       //业务逻辑
       //视图跳转
       req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp);
  }
   @Override
   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       doGet(req,resp);
  }
}
</code></pre>
</li>
<li><p>编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
<li><p>在web.xml中注册Servlet</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
        version=&quot;4.0&quot;&gt;
   &lt;servlet&gt;
       &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
       &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/user&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
</li>
<li><p>配置Tomcat，并启动测试</p>
<ul>
<li>localhost:8080/user?method=add</li>
<li>localhost:8080/user?method=delete</li>
</ul>
</li>
</ol>
<p><strong>MVC框架要做哪些事情</strong></p>
<ol>
<li>将url映射到java类或java类的方法 .</li>
<li>封装用户提交的数据 .</li>
<li>处理请求—调用相关的业务处理—封装响应数据 .</li>
<li>将响应的数据进行渲染 . jsp / html 等表示层数据 .</li>
</ol>
<p><strong>说明：</strong></p>
<p> 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….</p>
<h2 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p><strong>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</strong></p>
<p>查看官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc</a></p>
<p><strong>我们为什么要学习SpringMVC呢?</strong></p>
<p>Spring MVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p>
<p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong></p>
<h3 id="2-2、中心控制器"><a href="#2-2、中心控制器" class="headerlink" title="2.2、中心控制器"></a>2.2、中心控制器</h3><p> Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是请求分发到不同的处理器，从Spring2.5开始，使用Java5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p> SpringMVC 框架像许多其他MVC框架一样，<strong>以请求为驱动，围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个十几的Servlet(它继承自HttpServlet基类)</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201118102909306.png" alt="在这里插入图片描述"></p>
<p>SpringMVC的原理如下图所示：</p>
<p> 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/20201118103650754.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201118112410926.png" alt="在这里插入图片描述"></p>
<h3 id="2-3、SpringMVC执行原理"><a href="#2-3、SpringMVC执行原理" class="headerlink" title="2.3、SpringMVC执行原理"></a>2.3、SpringMVC执行原理</h3><p><img src="https://img-blog.csdnimg.cn/20201118114109225.png" alt="在这里插入图片描述"></p>
<p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello" target="_blank" rel="noopener">http://localhost:8080/SpringMVC/hello</a></p>
</li>
</ol>
<p><strong>如上url拆分成三部分：</strong></p>
<p><a href="http://localhost:8080服务器域名/">http://localhost:8080服务器域名</a></p>
<p>SpringMVC部署在服务器上的web站点</p>
<p>hello表示控制器</p>
<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
<ol>
<li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</li>
<li>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</li>
<li>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</li>
<li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</li>
<li>Handler让具体的Controller执行。</li>
<li>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</li>
<li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</li>
<li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</li>
<li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li>
<li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</li>
<li>最终视图呈现给用户。</li>
</ol>
<p>在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！</p>
<h2 id="3、-HelloSpringMVC"><a href="#3、-HelloSpringMVC" class="headerlink" title="3、 HelloSpringMVC!"></a>3、 HelloSpringMVC!</h2><h3 id="3-1、配置版"><a href="#3-1、配置版" class="headerlink" title="3.1、配置版"></a>3.1、配置版</h3><ol>
<li><p>新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p>
</li>
<li><p>确定导入了SpringMVC 的依赖！</p>
</li>
<li><p>配置web.xml ， 注册DispatcherServlet</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;!--1.注册DispatcherServlet--&gt;
    &lt;!--配置DispatcherServlet: 这个是springmvc的核心；其你去分发器，前端控制器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--DispatcherServlet要绑定spring的配置文件--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--启动级别：1--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!--
      在springmvc中，  /   /*
      /   只匹配所有的请求，不会去匹配jsp页面
      /*  匹配所有的请求，包括jsp页面
      --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
</li>
<li><p>编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml 说明，这里的名称要求是按照官方来的</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--处理映射器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
    &lt;!--处理器适配器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView    模板引擎 thymeleaf  freemarker--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;
         &lt;!--前缀--&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;!--后缀--&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;/hello&quot; class=&quot;com.susu.controller.HelloController&quot;/&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
<pre><code class="java">import org.springframework.web.servlet.mvc.Controller;
//注意：这里我们先导入Controller接口
public class HelloController implements Controller {
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
         //ModelAndView 模型和视图
        ModelAndView modelAndView = new ModelAndView();
        //业务代码
        String result = &quot;HelloSpringMVC&quot;;
        //封装对象，放在ModelAndView中。Model
        modelAndView.addObject(&quot;msg&quot;,result);
        //封装要跳转的视图，放在ModelAndView中
        modelAndView.setViewName(&quot;hello&quot;);
        return modelAndView;
    }
}</code></pre>
</li>
<li><p>将自己的类交给SpringIOC容器，注册bean</p>
<pre><code class="xml">&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt;</code></pre>
</li>
<li><p>写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
<li><p>配置Tomcat 启动测试！</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020111816022886.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p>
<ol>
<li><p>查看控制台输出，看一下是不是缺少了什么jar包。</p>
</li>
<li><p>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</p>
<p><img src="https://img-blog.csdnimg.cn/20201118160417486.png" alt="在这里插入图片描述"></p>
</li>
<li><p>重启Tomcat 即可解决！</p>
</li>
</ol>
<p><strong>小结：</strong>看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。</p>
<p><img src="https://i04piccdn.sogoucdn.com/2cb171fa44ccb501" alt="img"></p>
<h3 id="3-2、注解版"><a href="#3-2、注解版" class="headerlink" title="3.2、注解版"></a>3.2、注解版</h3><ol>
<li><p>新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！</p>
</li>
<li><p>由于Maven可能存在资源过滤的问题，我们将配置完善</p>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt; </code></pre>
</li>
<li><p>配置web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
</li>
<li><p>添加Spring MVC配置文件</p>
</li>
<li><p>在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.susu.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 HTML,JS,CSS,图片,视频.....--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;
    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>创建Controller</p>
<pre><code class="java">@Controller   
//@RequestMapping(&quot;/HelloController&quot;)
public class HelloController {
    // 真实访问地址 : 项目名/HelloController/hello
    @RequestMapping(&quot;/hello&quot;)
    public String hello(Model model){
        //封装数据
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVC&quot;);
        //web-inf/jsp/hello.jsp
        return  &quot;hello&quot;;
    }
}
//@Controller是为了让Spring IOC容器初始化时自动扫描到；
//@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；
//方法中声明Model类型的参数是为了把Action中的数据带到视图中；
//方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</code></pre>
</li>
<li><p>创建视图层<br>在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；<br>可以通过EL表示取出Model中存放的值，或者对象；</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;</code></pre>
<head>
    <title>Title</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
${msg}
</body>

```
</li>
<li><p>配置tomcat运行</p>
</li>
</ol>
<h3 id="3-3、小结"><a href="#3-3、小结" class="headerlink" title="3.3、小结"></a>3.3、小结</h3><p>实现步骤其实非常的简单：</p>
<ol>
<li>新建一个web项目</li>
<li>导入相关jar包</li>
<li>编写web.xml , 注册DispatcherServlet</li>
<li>编写springmvc配置文件</li>
<li>接下来就是去创建对应的控制类 , controller</li>
<li>最后完善前端视图和controller之间的对应</li>
<li>测试运行调试.</li>
</ol>
<p>使用springMVC必须配置的三大件：</p>
<p><strong>处理器映射器、处理器适配器、视图解析器</strong></p>
<p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，从而省去了大段的xml配置</p>
<h2 id="4、-RestFul和控制器"><a href="#4、-RestFul和控制器" class="headerlink" title="4、 RestFul和控制器"></a>4、 RestFul和控制器</h2><h3 id="4-1、控制器Controller"><a href="#4-1、控制器Controller" class="headerlink" title="4.1、控制器Controller"></a>4.1、控制器Controller</h3><ul>
<li>控制器负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</li>
<li>控制器负责解析用户的请求并将其转换为一个模型。</li>
<li>在Spring MVC中一个控制器类可以包含多个方法</li>
<li>在Spring MVC中，对于Controller的配置方式有很多种</li>
</ul>
<h3 id="4-2、实现Controller接口"><a href="#4-2、实现Controller接口" class="headerlink" title="4.2、实现Controller接口"></a>4.2、实现Controller接口</h3><ol>
<li><p>新建一个Moudle，springmvc-04-controller 。</p>
</li>
<li><p>配置web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
</li>
<li><p>配置springmvc-servlet.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
 &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>编写一个Controller类</p>
<pre><code class="java">//定义控制器
//注意点：不要导错包，实现Controller接口，重写方法；
public class ControllerTest1 implements Controller {
   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
       //返回一个模型视图对象
       ModelAndView mv = new ModelAndView();
       mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);
       mv.setViewName(&quot;test&quot;);
       return mv;
  }
}</code></pre>
</li>
<li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p>
<pre><code class="xml">&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt;</code></pre>
</li>
<li><p>编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器</p>
</li>
<li><p>测试</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<ul>
<li>实现接口Controller定义控制器是较老的办法</li>
<li>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</li>
</ul>
<h3 id="4-3、使用注解-Controller"><a href="#4-3、使用注解-Controller" class="headerlink" title="4.3、使用注解@Controller"></a>4.3、使用注解<a href="https://github.com/Controller" target="_blank" rel="noopener">@Controller</a></h3><ul>
<li><p><a href="https://github.com/Controller" target="_blank" rel="noopener">@Controller</a>注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p>
</li>
<li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
<pre><code class="xml">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;</code></pre>
</li>
<li><p>增加一个ControllerTest2类，使用注解实现；</p>
<pre><code class="java">//@Controller注解的类会自动添加到Spring上下文中
@Controller
public class ControllerTest2{
   //映射访问路径
   @RequestMapping(&quot;/t2&quot;)
   public String index(Model model){
       //Spring MVC会自动实例化一个Model对象用于向视图中传值
       model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);
       //返回视图位置
       return &quot;test&quot;;
  }
}
</code></pre>
</li>
<li><p>测试</p>
</li>
</ul>
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p>
<p><strong>注解方式是平时使用的最多的方式！</strong></p>
<h3 id="4-4、RequestMapping"><a href="#4-4、RequestMapping" class="headerlink" title="4.4、RequestMapping"></a>4.4、RequestMapping</h3><p><strong><a href="https://github.com/RequestMapping" target="_blank" rel="noopener">@RequestMapping</a></strong></p>
<ul>
<li><p><a href="https://github.com/RequestMapping" target="_blank" rel="noopener">@RequestMapping</a>注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p>
</li>
<li><p>只注解在方法上面</p>
<pre><code class="java">@Controller
public class TestController {
   @RequestMapping(&quot;/h1&quot;)
   public String test(){
       return &quot;test&quot;;
  }
}</code></pre>
<p>访问路径：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a> / 项目名 / h1</p>
</li>
<li><p>同时注解类与方法</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/admin&quot;)
public class TestController {
   @RequestMapping(&quot;/h1&quot;)
   public String test(){
       return &quot;test&quot;;
  }
}</code></pre>
<p>访问路径：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a> / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径；</p>
</li>
</ul>
<h3 id="4-5、RestFul-风格"><a href="#4-5、RestFul-风格" class="headerlink" title="4.5、RestFul 风格"></a>4.5、RestFul 风格</h3><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>功能</strong></p>
<p>资源：互联网所有的事物都可以被抽象为资源</p>
<p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
<p>分别对应 添加、 删除、修改、查询。</p>
<p><strong>传统方式操作资源</strong> ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a href="http://127.0.0.1/item/queryItem.action?id=1" target="_blank" rel="noopener">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a href="http://127.0.0.1/item/saveItem.action" target="_blank" rel="noopener">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a href="http://127.0.0.1/item/updateItem.action" target="_blank" rel="noopener">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a href="http://127.0.0.1/item/deleteItem.action?id=1" target="_blank" rel="noopener">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<p>写代码</p>
<p>新建一个类 RestFulController</p>
<pre><code class="java">@Controller
public class RestFulController {
    @RequestMapping(&quot;/add/{a}/{b}&quot;)
    public String test1(@PathVariable int a, @PathVariable int b, Model model){
        int res = a+b;
        model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);
        return &quot;test&quot;;
    }
}</code></pre>
<p>思考：使用路径变量的好处？</p>
<ul>
<li>使路径变得更加简洁；</li>
<li>获得参数更加方便，框架会自动进行类型转换。</li>
<li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</li>
</ul>
<p>我们来修改下对应的参数类型，再次测试</p>
<pre><code class="java">//映射访问路径
@RequestMapping(&quot;/commit/{p1}/{p2}&quot;)
public String index(@PathVariable int p1, @PathVariable String p2, Model model){
   String result = p1+p2;
   //Spring MVC会自动实例化一个Model对象用于向视图中传值
   model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
   //返回视图位置
   return &quot;test&quot;;
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201118205533534.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>使用method属性指定请求类型</strong></p>
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p>
<pre><code class="java">@RequestMapping(value = &quot;/add/{a}/{b}&quot;,method = RequestMethod.POST)
public String test1(@PathVariable int a, @PathVariable int b, Model model){
    int res = a+b;
    model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);
    return &quot;test&quot;;
}</code></pre>
<p>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</p>
<p><img src="https://img-blog.csdnimg.cn/20201118205009127.png" alt="在这里插入图片描述"></p>
<p>如果将POST修改为GET则正常了；</p>
<h3 id="4-6、小结："><a href="#4-6、小结：" class="headerlink" title="4.6、小结："></a>4.6、小结：</h3><p>Spring MVC 的 <a href="https://github.com/RequestMapping" target="_blank" rel="noopener">@RequestMapping</a> 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p>
<p>方法级别的注解变体有如下几个：组合注解</p>
<pre><code class="java">@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping</code></pre>
<p><a href="https://github.com/GetMapping" target="_blank" rel="noopener">@GetMapping</a> 是一个组合注解，平时使用的会比较多！</p>
<p>它所扮演的是 <a href="https://github.com/RequestMapping" target="_blank" rel="noopener">@RequestMapping</a>(method =RequestMethod.GET) 的一个快捷方式。</p>
<h3 id="4-7、扩展：小黄鸭调试法"><a href="#4-7、扩展：小黄鸭调试法" class="headerlink" title="4.7、扩展：小黄鸭调试法"></a>4.7、扩展：小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p>
<p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p>
<p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p>
<p><img src="https://img-blog.csdnimg.cn/2020111820522297.png" alt="在这里插入图片描述"></p>
<p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p>
<h2 id="5、-结果跳转方式"><a href="#5、-结果跳转方式" class="headerlink" title="5、 结果跳转方式"></a>5、 结果跳转方式</h2><h3 id="5-1、ModelAndView"><a href="#5-1、ModelAndView" class="headerlink" title="5.1、ModelAndView"></a>5.1、ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p>
<p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
     id=&quot;internalResourceViewResolver&quot;&gt;
   &lt;!-- 前缀 --&gt;
   &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
   &lt;!-- 后缀 --&gt;
   &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p>对应的controller类</p>
<pre><code class="java">public class ControllerTest1 implements Controller {
public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
       //返回一个模型视图对象
       ModelAndView mv = new ModelAndView();
       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
       mv.setViewName(&quot;test&quot;);
       return mv;
  }
}</code></pre>
<h3 id="5-2、ServletAPI"><a href="#5-2、ServletAPI" class="headerlink" title="5.2、ServletAPI"></a>5.2、ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p>
<ol>
<li>通过HttpServletResponse进行输出</li>
<li>通过HttpServletResponse实现重定向</li>
<li>通过HttpServletResponse实现转发</li>
</ol>
<pre><code class="java">@Controller
public class ResultGo {
   @RequestMapping(&quot;/result/t1&quot;)
   public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
       rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
  }
   @RequestMapping(&quot;/result/t2&quot;)
   public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
       rsp.sendRedirect(&quot;/index.jsp&quot;);
  }
   @RequestMapping(&quot;/result/t3&quot;)
   public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception {
       //转发
       req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
       req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
  }
}</code></pre>
<h3 id="5-3、SpringMVC"><a href="#5-3、SpringMVC" class="headerlink" title="5.3、SpringMVC"></a>5.3、SpringMVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p>
<p>测试前，需要将视图解析器注释掉</p>
<pre><code class="java">@Controllerpublic class ResultSpringMVC {   @RequestMapping(&quot;/rsm/t1&quot;)   public String test1(){       //转发       return &quot;/WEB-INF/jsp/test.jsp&quot;;  }   @RequestMapping(&quot;/rsm/t2&quot;)   public String test2(){       //转发二       return &quot;forward:/WEB-INF/jsp/test.jsp&quot;;  }   @RequestMapping(&quot;/rsm/t3&quot;)   public String test3(){       //重定向       return &quot;redirect:/index.jsp&quot;;  }}@Controller
public class ResultSpringMVC {
   @RequestMapping(&quot;/rsm/t1&quot;)
   public String test1(){
       //转发
       return &quot;/WEB-INF/jsp/test.jsp&quot;;
  }
   @RequestMapping(&quot;/rsm/t2&quot;)
   public String test2(){
       //转发二
       return &quot;forward:/WEB-INF/jsp/test.jsp&quot;;
  }
   @RequestMapping(&quot;/rsm/t3&quot;)
   public String test3(){
       //重定向
       return &quot;redirect:/index.jsp&quot;;
  }
}</code></pre>
<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p>
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p>
<p>可以重定向到另外一个请求实现 .</p>
<pre><code class="java">@Controller
public class ResultSpringMVC2 {
   @RequestMapping(&quot;/rsm2/t1&quot;)
   public String test1(){
       //转发
       return &quot;test&quot;;
  }
   @RequestMapping(&quot;/rsm2/t2&quot;)
   public String test2(){
       //重定向
       return &quot;redirect:/index.jsp&quot;;
       //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
  }
}</code></pre>
<h2 id="6、-数据处理"><a href="#6、-数据处理" class="headerlink" title="6、 数据处理"></a>6、 数据处理</h2><h3 id="6-1、处理提交数据"><a href="#6-1、处理提交数据" class="headerlink" title="6.1、处理提交数据"></a>6.1、处理提交数据</h3><ol>
<li><p><strong>提交的域名称和处理方法的参数名一致</strong></p>
<p>提交数据 : <a href="http://localhost:8080/hello?name=kuangshen" target="_blank" rel="noopener">http://localhost:8080/hello?name=kuangshen</a></p>
<p>处理方法 :</p>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name){
   System.out.println(name);
   return &quot;hello&quot;;
}</code></pre>
<p>后台输出 : kuangshen</p>
</li>
<li><p><strong>提交的域名称和处理方法的参数名不一致</strong></p>
<p>提交数据 : <a href="http://localhost:8080/hello?username=kuangshen" target="_blank" rel="noopener">http://localhost:8080/hello?username=kuangshen</a></p>
<p>处理方法 :</p>
<pre><code class="java">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name){
   System.out.println(name);
   return &quot;hello&quot;;
}</code></pre>
<p>后台输出 : kuangshen</p>
</li>
<li><p><strong>提交的是一个对象</strong></p>
<p>要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p>
<p>1、实体类</p>
<pre><code class="java">public class User {
   private int id;
private String name;
   private int age;
//构造
   //get/set
//tostring()
}</code></pre>
</li>
</ol>
<p>2、提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15" target="_blank" rel="noopener">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p>
<p>   3、处理方法 :</p>
<pre><code class="java">   @RequestMapping(&quot;/user&quot;)
   public String user(User user){
      System.out.println(user);
      return &quot;hello&quot;;
   }</code></pre>
<p>   后台输出 : User { id=1, name=’kuangshen’, age=15 }</p>
<p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p>
<h3 id="6-2、数据显示到前端"><a href="#6-2、数据显示到前端" class="headerlink" title="6.2、数据显示到前端"></a>6.2、数据显示到前端</h3><ol>
<li><p><strong>第一种 : 通过ModelAndView</strong></p>
<p>我们前面一直都是如此 . 就不过多解释</p>
<pre><code class="java">public class ControllerTest1 implements Controller {
   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
       //返回一个模型视图对象
       ModelAndView mv = new ModelAndView();
       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
       mv.setViewName(&quot;test&quot;);
       return mv;
  }
}</code></pre>
</li>
<li><p><strong>第二种 : 通过ModelMap</strong></p>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model){
   //封装要显示到视图中的数据
   //相当于req.setAttribute(&quot;name&quot;,name);
   model.addAttribute(&quot;name&quot;,name);
   System.out.println(name);
   return &quot;hello&quot;;
}</code></pre>
</li>
<li><p><strong>第三种 : 通过Model</strong></p>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model){
   //封装要显示到视图中的数据
   //相当于req.setAttribute(&quot;name&quot;,name);
   model.addAttribute(&quot;msg&quot;,name);
   System.out.println(name);
   return &quot;test&quot;;
}</code></pre>
</li>
</ol>
<h3 id="6-3、对比"><a href="#6-3、对比" class="headerlink" title="6.3、对比"></a>6.3、对比</h3><p>就对于新手而言简单来说使用区别就是：</p>
<pre><code>Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；
ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；
ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</code></pre><p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p>
<p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p>
<h3 id="6-4、乱码问题"><a href="#6-4、乱码问题" class="headerlink" title="6.4、乱码问题"></a>6.4、乱码问题</h3><p>测试步骤：</p>
<p>1、我们可以在首页编写一个提交的表单</p>
<pre><code class="jsp">&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt;
 &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
 &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
<p>2、后台编写对应的处理类</p>
<pre><code class="java">@Controller
public class Encoding {
   @RequestMapping(&quot;/e/t&quot;)
   public String test(Model model,String name){
       model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值
       return &quot;test&quot;; //跳转到test页面显示输入的值
  }
}</code></pre>
<p>3、输入中文测试，发现乱码</p>
<p><img src="https://img-blog.csdnimg.cn/20201118221418297.png#pic_center" alt="在这里插入图片描述"></p>
<p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p>
<p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p>
<pre><code class="xml">&lt;!--配置SpringMVC的过滤--&gt;
&lt;filter&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
   &lt;init-param&gt;
       &lt;param-name&gt;encoding&lt;/param-name&gt;
       &lt;param-value&gt;utf-8&lt;/param-value&gt;
   &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
<p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p>
<p>处理方法 :</p>
<p>1、修改tomcat配置文件 ：设置编码！</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
          connectionTimeout=&quot;20000&quot;
          redirectPort=&quot;8443&quot; /&gt;</code></pre>
<p>2、自定义过滤器</p>
<pre><code class="java">/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter {
   @Override
   public void destroy() {
  }
   @Override
   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
       //处理response的字符编码
       HttpServletResponse myResponse=(HttpServletResponse) response;
       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);
       // 转型为与协议相关对象
       HttpServletRequest httpServletRequest = (HttpServletRequest) request;
       // 对request包装增强
       HttpServletRequest myrequest = new MyRequest(httpServletRequest);
       chain.doFilter(myrequest, response);
  }
   @Override
   public void init(FilterConfig filterConfig) throws ServletException {
  }
}
//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper {
   private HttpServletRequest request;
   //是否编码的标记
   private boolean hasEncode;
   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
   public MyRequest(HttpServletRequest request) {
       super(request);// super必须写
       this.request = request;
  }
   // 对需要增强方法 进行覆盖
   @Override
   public Map getParameterMap() {
       // 先获得请求方式
       String method = request.getMethod();
       if (method.equalsIgnoreCase(&quot;post&quot;)) {
           // post请求
           try {
               // 处理post乱码
               request.setCharacterEncoding(&quot;utf-8&quot;);
               return request.getParameterMap();
          } catch (UnsupportedEncodingException e) {
               e.printStackTrace();
          }
      } else if (method.equalsIgnoreCase(&quot;get&quot;)) {
           // get请求
           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
           if (!hasEncode) { // 确保get手动编码逻辑只运行一次
               for (String parameterName : parameterMap.keySet()) {
                   String[] values = parameterMap.get(parameterName);
                   if (values != null) {
                       for (int i = 0; i &lt; values.length; i++) {
                           try {
                               // 处理get乱码
                               values[i] = new String(values[i]
                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                          } catch (UnsupportedEncodingException e) {
                               e.printStackTrace();
                          }
                      }
                  }
              }
               hasEncode = true;
          }
           return parameterMap;
      }
       return super.getParameterMap();
  }
   //取一个值
   @Override
   public String getParameter(String name) {
       Map&lt;String, String[]&gt; parameterMap = getParameterMap();
       String[] values = parameterMap.get(name);
       if (values == null) {
           return null;
      }
       return values[0]; // 取回参数的第一个值
  }
   //取所有值
   @Override
   public String[] getParameterValues(String name) {
       Map&lt;String, String[]&gt; parameterMap = getParameterMap();
       String[] values = parameterMap.get(name);
       return values;
  }
}</code></pre>
<p>3、然后在web.xml中配置这个过滤器即可！</p>
<pre><code class="xml">&lt;filter&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;filter-class&gt;com.susu.filter.GenericEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
<p>这个也是在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p>
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>
<h2 id="7、JSON"><a href="#7、JSON" class="headerlink" title="7、JSON"></a>7、JSON</h2><p>前后端分离时代：后端部署后端，提供接口 前端独立部署，负责渲染后端提供的数据</p>
<h3 id="7-1、什么是JSON？"><a href="#7-1、什么是JSON？" class="headerlink" title="7.1、什么是JSON？"></a>7.1、什么是JSON？</h3><ul>
<li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p>
<pre><code class="json">{&quot;name&quot;: &quot;QinJiang&quot;}
{&quot;age&quot;: &quot;3&quot;}
{&quot;sex&quot;: &quot;男&quot;}</code></pre>
<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<pre><code class="json">var obj = {a: &#39;Hello&#39;, b: &#39;World&#39;}; //这是一个对象，注意键名也是可以使用引号包裹的
var json = &#39;{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}&#39;; //这是一个 JSON 字符串，本质是一个字符串</code></pre>
<p><strong>JSON 和 JavaScript 对象互转</strong></p>
<p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p>
<pre><code class="json">var obj = JSON.parse(&#39;{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}&#39;);
//结果是 {a: &#39;Hello&#39;, b: &#39;World&#39;}</code></pre>
<p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>
<pre><code class="json">var json = JSON.stringify({a: &#39;Hello&#39;, b: &#39;World&#39;});
//结果是 &#39;{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}&#39;</code></pre>
<h3 id="7-2、Controller返回JSON数据"><a href="#7-2、Controller返回JSON数据" class="headerlink" title="7.2、Controller返回JSON数据"></a>7.2、Controller返回JSON数据</h3><h4 id="7-2-1、Jackson"><a href="#7-2-1、Jackson" class="headerlink" title="7.2.1、Jackson"></a>7.2.1、Jackson</h4><p>Jackson应该是目前比较好的json解析工具了</p>
<p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p>
<p>1、我们这里使用Jackson，使用它需要导入它的jar包；</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
   &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
   &lt;version&gt;2.11.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>2、配置web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
        version=&quot;4.0&quot;&gt;
   &lt;!--1.注册servlet--&gt;
   &lt;servlet&gt;
       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
           &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;
   &lt;!--所有请求都会被springmvc拦截 --&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
   &lt;filter&gt;
       &lt;filter-name&gt;encoding&lt;/filter-name&gt;
       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;encoding&lt;/param-name&gt;
           &lt;param-value&gt;utf-8&lt;/param-value&gt;
       &lt;/init-param&gt;
   &lt;/filter&gt;
   &lt;filter-mapping&gt;
       &lt;filter-name&gt;encoding&lt;/filter-name&gt;
       &lt;url-pattern&gt;/&lt;/url-patter/3、n&gt;
   &lt;/filter-mapping&gt;
&lt;/web-app&gt;</code></pre>
<p>3、配置springmvc-servlet.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
   &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;
   &lt;!-- 视图解析器 --&gt;
   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
         id=&quot;internalResourceViewResolver&quot;&gt;
       &lt;!-- 前缀 --&gt;
       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
       &lt;!-- 后缀 --&gt;
       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>4、我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</p>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
   private String name;
   private int age;
   private String sex;
}</code></pre>
<p>5、编写一个Controller；</p>
<pre><code class="java">@Controller
public class UserController {
   @RequestMapping(&quot;/json1&quot;)
   @ResponseBody  //它就不会走视图解析器，会直接返回一个字符串
   public String json1() throws JsonProcessingException {
       //创建一个jackson的对象映射器，用来解析数据
       ObjectMapper mapper = new ObjectMapper();
       //创建一个对象
       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
       //将我们的对象解析成为json格式
       String str = mapper.writeValueAsString(user);
       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
       return str;
  }
}</code></pre>
<p>6、配置Tomcat，测试</p>
<p><img src="https://img-blog.csdnimg.cn/20201119151728637.png#pic_center" alt="在这里插入图片描述"></p>
<p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p>
<p>通过<a href="https://github.com/RequestMaping" target="_blank" rel="noopener">@RequestMaping</a>的produces属性来实现，修改下代码</p>
<pre><code class="java">//produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre>
<p>再次测试， 乱码问题OK！</p>
<p><img src="https://img-blog.csdnimg.cn/20201119151919904.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>乱码统一解决</strong></p>
<p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p>
<p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p>
<pre><code class="xml">&lt;mvc:annotation-driven&gt;
   &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
       &lt;/bean&gt;
       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
           &lt;property name=&quot;objectMapper&quot;&gt;
               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
               &lt;/bean&gt;
           &lt;/property&gt;
       &lt;/bean&gt;
   &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
<p><strong>返回json字符串统一解决</strong></p>
<p>在类上直接使用 <strong><a href="https://github.com/RestController" target="_blank" rel="noopener">@RestController</a></strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加<a href="https://github.com/ResponseBody" target="_blank" rel="noopener">@ResponseBody</a> ！我们在前后端分离开发中，一般都使用 <a href="https://github.com/RestController" target="_blank" rel="noopener">@RestController</a> ，十分便捷！</p>
<pre><code class="java">@RestController
public class UserController {
   //produces:指定响应体返回类型和编码
   @RequestMapping(value = &quot;/json1&quot;)
   //@ResponseBody  不再需要
   public String json1() throws JsonProcessingException {
       //创建一个jackson的对象映射器，用来解析数据
       ObjectMapper mapper = new ObjectMapper();
       //创建一个对象
       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
       //将我们的对象解析成为json格式
       String str = mapper.writeValueAsString(user);
       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
       return str;
  }
}</code></pre>
<p><strong>输出时间对象</strong></p>
<p>增加一个新的方法</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException {
   ObjectMapper mapper = new ObjectMapper();
   //创建时间一个对象，java.util.Date
   Date date = new Date();
   //将我们的对象解析成为json格式
   String str = mapper.writeValueAsString(date);
   return str;
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201119155055371.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li>
<li>Jackson 默认是会把时间转成timestamps（时间戳）形式</li>
</ul>
<p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException {
   ObjectMapper mapper = new ObjectMapper();
   //不使用时间戳的方式
   mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
   //自定义日期格式对象
   SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
   //指定日期格式
   mapper.setDateFormat(sdf);
   Date date = new Date();
   String str = mapper.writeValueAsString(date);
   return str;
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201119155357209.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>抽取工具类</strong></p>
<pre><code class="java">public class JsonUtils {
   public static String getJson(Object object) {
       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
  }
   public static String getJson(Object object,String dateFormat) {
       ObjectMapper mapper = new ObjectMapper();
       //不使用时间差的方式
       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
       //自定义日期格式对象
       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
       //指定日期格式
       mapper.setDateFormat(sdf);
       try {
           return mapper.writeValueAsString(object);
      } catch (JsonProcessingException e) {
           e.printStackTrace();
      }
       return null;
  }
}</code></pre>
<p>使用工具类，代码就更加简洁了！</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException {
   Date date = new Date();
   String json = JsonUtils.getJson(date);
   return json;
}</code></pre>
<p>大功告成！完美！</p>
<h4 id="7-2-2、FastJson"><a href="#7-2-2、FastJson" class="headerlink" title="7.2.2、FastJson"></a>7.2.2、FastJson</h4><p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p>
<p>fastjson 的 pom依赖！</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
   &lt;version&gt;1.2.60&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>fastjson 三个主要的类：</p>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li>
<li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有List接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON代表 JSONObject和JSONArray的转化</strong></p>
<ul>
<li>JSON类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li>
</ul>
<p>代码测试，我们新建一个FastJsonDemo 类</p>
<pre><code class="java">public class FastJsonDemo {
   public static void main(String[] args) {
       //创建一个对象
       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);
       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);
       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);
       List&lt;User&gt; list = new ArrayList&lt;User&gt;();
       list.add(user1);
       list.add(user2);
       list.add(user3);
       list.add(user4);
       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
       String str1 = JSON.toJSONString(list);
       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
       String str2 = JSON.toJSONString(user1);
       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);
       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
       User jp_user1=JSON.parseObject(str2,User.class);
       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);
       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));
       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
  }
}</code></pre>
<p>这种工具类，我们只需要掌握使用就好了，在使用的时候再根据具体的业务去找对应的实现。</p>
<h2 id="8、整合SSM框架"><a href="#8、整合SSM框架" class="headerlink" title="8、整合SSM框架"></a>8、整合SSM框架</h2><h3 id="8-1、搭建环境"><a href="#8-1、搭建环境" class="headerlink" title="8.1、搭建环境"></a>8.1、搭建环境</h3><ol>
<li><p>创建数据库</p>
<pre><code class="sql">CREATE DATABASE `ssmbuild`;
USE `ssmbuild`;
DROP TABLE IF EXISTS `books`;
CREATE TABLE `books` (
`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,
`bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,
`bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,
`detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,
KEY `bookID` (`bookID`)
) ENGINE=INNODB DEFAULT CHARSET=utf8
INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES
(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),
(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),
(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);</code></pre>
</li>
<li><p>新建一Maven项目！ssmbuild ， 添加web的支持</p>
</li>
<li><p>导入相关的pom依赖！</p>
<pre><code class="xml">&lt;!--依赖： Junit,数据库驱动， 连接池，servlet，jsp，mybatis spring mybatis-spring springmvc--&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li><p>Maven资源过滤设置</p>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;</code></pre>
</li>
<li><p>连接数据库</p>
</li>
<li><p>建立基本结构和配置框架！</p>
<ul>
<li>com.kuang.pojo</li>
<li>com.kuang.dao</li>
<li>com.kuang.service</li>
<li>com.kuang.controller</li>
<li>mybatis-config.xml</li>
<li>applicationContext.xml</li>
</ul>
</li>
</ol>
<h3 id="8-2、编写Mybatis层"><a href="#8-2、编写Mybatis层" class="headerlink" title="8.2、编写Mybatis层"></a>8.2、编写Mybatis层</h3><ol>
<li><p>数据库配置文件 database.properties</p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
user=root   //用c3p0时不能用uername否则会报错
password=root</code></pre>
</li>
<li><p>编写MyBatis的核心配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
   &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
   &lt;typeAliases&gt;
       &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
   &lt;/typeAliases&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;com/kuang/dao/BookMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
</li>
<li><p>编写实体类</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;
}</code></pre>
</li>
<li><p>编写Dao层的 Mapper接口！</p>
<pre><code class="java">public interface BookMapper {
    //增加一本书
    int addBook(Books books);
    //删除一本书
    int deleteBookById(@Param(&quot;bookId&quot;) int id);
    //更新一本书
    int updateBook(Books books);
    //查询一本书
    Books queryBookById(@Param(&quot;bookId&quot;) int id);
    //查询全部书
    List&lt;Books&gt; queryAllBook();
    //根据书名模糊查询一本书
     List&lt;Books&gt; queryBookByName(@Param(&quot;bookName&quot;) String bookName);
}</code></pre>
</li>
<li><p>编写对应的Mapper.xml 文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt;
    &lt;!--增加一个Book--&gt;
    &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;
        insert into books (bookName,bookCounts,detail)
        values (#{bookName},#{bookCounts},#{detail});
    &lt;/insert&gt;
     &lt;!--根据id删除一个Book--&gt;
    &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;
        delete from books where bookID = #{bookID}
    &lt;/delete&gt;
    &lt;!--更新Book--&gt;
    &lt;update id=&quot;updateBookById&quot; parameterType=&quot;Books&quot;&gt;
        update books
        set bookName=#{bookName},bookCounts=#{bookCounts},detail=#{detail}
        where bookID=#{bookID};
    &lt;/update&gt;
    &lt;!--根据id查询,返回一个Book--&gt;
    &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;
        select * from books 
        where bookID = #{bookID}
    &lt;/select&gt;
    &lt;!--查询全部Book--&gt;
    &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt;
        select * from books;
    &lt;/select&gt;
    &lt;!--根据bookName查询,返回一个Book--&gt;
    &lt;select id=&quot;queryBookByName&quot; resultType=&quot;Books&quot;&gt;
        select * from books where bookName like &quot;%&quot;#{bookName}&quot;%&quot;
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
</li>
<li><p>编写service层</p>
<pre><code class="java">public interface BookService {
    //增加一本书
 int addBook(Books books);
    //删除一本书
    int deleteBookById(int id);
    //更新一本书
    int updateBook(Books books);
    //查询一本书
    Books queryBookById(int id);
    //查询全部书
    List&lt;Books&gt; queryAllBook();
    //根据书名模糊查询一本书
     List&lt;Books&gt; queryBookByName(String bookName);
}</code></pre>
<pre><code class="java">public class BookServiceImpl implements BookService{
    //service调dao层:  组合Dao    可添加业务
    private BookMapper bookMapper;
    public void setBookMapper(BookMapper bookMapper) {
        this.bookMapper = bookMapper;
    }
    @Override
    public int addBook(Books books) {
        return bookMapper.addBook(books);
    }
    @Override
    public int deleteBookById(int id) {
        return bookMapper.deleteBookById(id);
    }
    @Override
    public int updateBookById(Books books) {
        return bookMapper.updateBookById(books);
    }
    @Override
    public Books queryBookById(int id) {
        return bookMapper.queryBookById(id);
    }
    @Override
    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }
    @Override
    public List&lt;Books&gt; queryBookByName(String bookName) {
        return bookMapper.queryBookByName(bookName);
    }
}</code></pre>
</li>
</ol>
<h3 id="8-3、编写Spring层"><a href="#8-3、编写Spring层" class="headerlink" title="8.3、编写Spring层"></a>8.3、编写Spring层</h3><ol>
<li><p>配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p>
</li>
<li><p>编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
   &lt;!-- 配置整合mybatis --&gt;
   &lt;!-- 1.关联数据库文件 --&gt;
   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
   &lt;!-- 2.数据库连接池 --&gt;
   &lt;!--数据库连接池
       dbcp 半自动化操作 不能自动连接
       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）
   --&gt;
   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
       &lt;!-- 配置连接池属性 --&gt;
       &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;
       &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;
       &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;
       &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
       &lt;!-- c3p0连接池的私有属性 --&gt;
       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
       &lt;!-- 关闭连接后不自动commit --&gt;
       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
       &lt;!-- 获取连接超时时间 --&gt;
       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
       &lt;!-- 当获取连接失败重试次数 --&gt;
       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
   &lt;/bean&gt;
   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;
   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
       &lt;!-- 注入数据库连接池 --&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;
       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
   &lt;/bean&gt;
   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;
   &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;
   &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
       &lt;!-- 注入sqlSessionFactory --&gt;
       &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
       &lt;!-- 给出需要扫描Dao接口包 --&gt;
       &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>Spring整合service层</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/tx
   http://www.springframework.org/schema/tx/spring-tx.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
   &lt;!-- 扫描service相关的bean --&gt;
   &lt;context:component-scan base-package=&quot;com.kuang.service&quot; /&gt;
   &lt;!--BookServiceImpl注入到IOC容器中--&gt;
   &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;
       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;
   &lt;/bean&gt;
   &lt;!-- 配置事务管理器 --&gt;
   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
       &lt;!-- 注入数据库连接池 --&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
   &lt;/bean&gt;
    &lt;!-- aop事务支持--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.su.dao.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;</code></pre>
</li>
</ol>
<h3 id="8-4、SpringMVC层"><a href="#8-4、SpringMVC层" class="headerlink" title="8.4、SpringMVC层"></a>8.4、SpringMVC层</h3><ol>
<li><p>配置web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
        version=&quot;4.0&quot;&gt;
   &lt;!--DispatcherServlet--&gt;
   &lt;servlet&gt;
       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;  
           &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
   &lt;!--encodingFilter--&gt;
   &lt;filter&gt;
       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
       &lt;filter-class&gt;
          org.springframework.web.filter.CharacterEncodingFilter
       &lt;/filter-class&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;encoding&lt;/param-name&gt;
           &lt;param-value&gt;utf-8&lt;/param-value&gt;
       &lt;/init-param&gt;
   &lt;/filter&gt;
   &lt;filter-mapping&gt;
       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/filter-mapping&gt;
   &lt;!--Session过期时间--&gt;
   &lt;session-config&gt;
       &lt;session-timeout&gt;15&lt;/session-timeout&gt;
   &lt;/session-config&gt;
&lt;/web-app&gt;</code></pre>
</li>
<li><p>配置spring-mvc.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/mvc
   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
   &lt;!-- 配置SpringMVC --&gt;
   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;
   &lt;mvc:annotation-driven /&gt;
   &lt;!-- 2.静态资源默认servlet配置--&gt;
   &lt;mvc:default-servlet-handler/&gt;
   &lt;!-- 3.扫描web相关的bean --&gt;
   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;
   &lt;!-- 4.配置jsp 显示ViewResolver视图解析器 --&gt;
   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</li>
<li><p>Spring配置整合文件，applicationContext.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;</code></pre>
</li>
</ol>
<p>配置文件暂时结束</p>
<p>1、BookController 类编写 ， 方法一：查询全部书籍</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController {
   @Autowired
   @Qualifier(&quot;BookServiceImpl&quot;)
   private BookService bookService;
   @RequestMapping(&quot;/allBook&quot;)
   public String list(Model model) {
       List&lt;Books&gt; list = bookService.queryAllBook();
       model.addAttribute(&quot;list&quot;, list);
       return &quot;allBook&quot;;
  }
}</code></pre>
<p>2、编写首页 <strong>index.jsp</strong></p>
<pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;首页&lt;/title&gt;
   &lt;style type=&quot;text/css&quot;&gt;
       a {
           text-decoration: none;
           color: black;
           font-size: 18px;
      }
       h3 {
           width: 180px;
           height: 38px;
           margin: 100px auto;
           text-align: center;
           line-height: 38px;
           background: deepskyblue;
           border-radius: 4px;
      }
   &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;
   &lt;a href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;
&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>3、书籍列表页面 <strong>allbook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;书籍列表&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;row&quot;&gt;
       &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增书籍&lt;/a&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;显示全部书籍&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;%--  查询书籍  --%&gt;
            &lt;form class=&quot;form-inline&quot; action=&quot;${pageContext.request.contextPath}/book/queryBook&quot; method=&quot;post&quot; style=&quot;float: right&quot;&gt;
                &lt;span style=&quot;color: red; font-weight: bold&quot;&gt;${error}&lt;/span&gt;
                &lt;input type=&quot;text&quot; name=&quot;queryBookName&quot; placeholder=&quot;请输入要查询的书籍名称&quot; required&gt;
                &lt;input type=&quot;submit&quot; value=&quot;查询&quot; class=&quot;btn btn-primary&quot;&gt;
            &lt;/form&gt;
        &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;table class=&quot;table table-hover table-striped&quot;&gt;
               &lt;thead&gt;
               &lt;tr&gt;
                   &lt;th&gt;书籍编号&lt;/th&gt;
                   &lt;th&gt;书籍名字&lt;/th&gt;
                   &lt;th&gt;书籍数量&lt;/th&gt;
                   &lt;th&gt;书籍详情&lt;/th&gt;
                   &lt;th&gt;操作&lt;/th&gt;
               &lt;/tr&gt;
               &lt;/thead&gt;
               &lt;tbody&gt;
               &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get(&#39;list&#39;)}&quot;&gt;
                   &lt;tr&gt;
                       &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                       &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                       &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                       &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                       &lt;td&gt;
                           &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.getBookID()}&quot;&gt;更改&lt;/a&gt; |
                           &lt;a href=&quot;${pageContext.request.contextPath}/book/deleteBook/${book.getBookID()}&quot;&gt;删除&lt;/a&gt;
                       &lt;/td&gt;
                   &lt;/tr&gt;
               &lt;/c:forEach&gt;
               &lt;/tbody&gt;
           &lt;/table&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p><strong>错误</strong>：</p>
<p> java.sql.SQLException: Access denied for user ‘22315’@’localhost’ (using password: YES)</p>
<p><img src="https://img-blog.csdnimg.cn/20201119192225102.png" alt="在这里插入图片描述"></p>
<p>4、BookController 类编写 ， 方法二：添加书籍</p>
<pre><code class="java">@RequestMapping(&quot;/toAddBook&quot;)
public String toAddPaper() {
   return &quot;addBook&quot;;
}
@RequestMapping(&quot;/addBook&quot;)
public String addPaper(Books books) {
   System.out.println(books);
   bookService.addBook(books);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<p>5、添加书籍页面：<strong>addBook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;新增书籍&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;新增书籍&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;form action=&quot;${pageContext.request.contextPath}/book/addBook&quot; method=&quot;post&quot;&gt;
      书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
      书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
      书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
       &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
   &lt;/form&gt;
&lt;/div&gt;</code></pre>
<p>6、BookController 类编写 ， 方法三：修改书籍</p>
<pre><code class="java">@RequestMapping(&quot;/toUpdateBook&quot;)
public String toUpdateBook(Model model, int id) {
   Books books = bookService.queryBookById(id);
   System.out.println(books);
   model.addAttribute(&quot;book&quot;,books );
   return &quot;updateBook&quot;;
}
@RequestMapping(&quot;/updateBook&quot;)
public String updateBook(Model model, Books book) {
   System.out.println(&quot;=====&gt;&quot;+books);
   bookService.updateBook(book);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<p>7、修改书籍页面 <strong>updateBook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;修改信息&lt;/title&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
   &lt;!-- 引入 Bootstrap --&gt;
   &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row clearfix&quot;&gt;
       &lt;div class=&quot;col-md-12 column&quot;&gt;
           &lt;div class=&quot;page-header&quot;&gt;
               &lt;h1&gt;
                   &lt;small&gt;修改信息&lt;/small&gt;
               &lt;/h1&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
  &lt;form action=&quot;${pageContext.request.contextPath}/book/updateBook&quot; method=&quot;post&quot;&gt;
          &lt;!--注意注意注意！！！   隐藏域为了获取 books的 id --&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; class=&quot;form-control&quot; value=&quot;${Qbooks.bookID}&quot;&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;书籍名称：&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;bookName&quot; class=&quot;form-control&quot; value=&quot;${Qbooks.bookName}&quot; required&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;书籍数量：&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; class=&quot;form-control&quot; value=&quot;${Qbooks.bookCounts}&quot; required&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;书籍描述：&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;detail&quot; class=&quot;form-control&quot; value=&quot;${Qbooks.detail}&quot; required&gt;
        &lt;/div&gt;
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre>
<p>注意点： 修改书籍时要传入id</p>
<p>8、BookController 类编写 ， 方法四：删除书籍</p>
<pre><code class="java">@RequestMapping(&quot;/del/{bookId}&quot;)
public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) {
   bookService.deleteBookById(id);
   return &quot;redirect:/book/allBook&quot;;
}</code></pre>
<p>9、按书名查询书籍(找不到则显示全部书籍,并报错)</p>
<pre><code class="java">///查询书籍
@RequestMapping(&quot;/queryBook&quot;)
public String queryBook(String queryBookName,Model model){
    //        boolean q = false;
    List&lt;Books&gt; list = bookService.queryBookByName(queryBookName);
    for (Books books : list) {
        //红色输出
        System.err.println(&quot;queryBookName==&gt;&quot;+books);
    }
    if (list.size() == 0){
        list = bookService.queryAllBook();
        model.addAttribute(&quot;error&quot;,&quot;未查到&quot;);
        System.out.println(&quot;===未查到===&quot;);
    }
    model.addAttribute(&quot;list&quot;,list);
    return &quot;allBook&quot;;
}</code></pre>
<p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！</p>
<p><img src="https://img-blog.csdnimg.cn/20201120155352255.png" alt="在这里插入图片描述"></p>
<h2 id="9、Ajax技术"><a href="#9、Ajax技术" class="headerlink" title="9、Ajax技术"></a>9、Ajax技术</h2><ul>
<li><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。<ul>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
</ul>
</li>
<li>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</li>
</ul>
<h3 id="9-1、伪造Ajax"><a href="#9-1、伪造Ajax" class="headerlink" title="9.1、伪造Ajax"></a>9.1、伪造Ajax</h3><p>我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签</p>
<p>1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！</p>
<p>2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p>
<pre><code class="jsp">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
   window.onload = function(){
       var myDate = new Date();
       document.getElementById(&#39;currentTime&#39;).innerText = myDate.getTime();
  };
   function LoadPage(){
       var targetUrl =  document.getElementById(&#39;url&#39;).value;
       console.log(targetUrl);
       document.getElementById(&quot;iframePosition&quot;).src = targetUrl;
  }
&lt;/script&gt;
&lt;div&gt;
   &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;
   &lt;p&gt;
       &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt;
       &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt;
   &lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
   &lt;h3&gt;加载页面位置：&lt;/h3&gt;
   &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>利用AJAX可以做：</strong></p>
<ul>
<li>注册时，输入用户名自动检测用户是否已经存在。</li>
<li>登陆时，提示用户名密码错误</li>
<li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li>
<li>….等等</li>
</ul>
<h3 id="9-2、jQuery-ajax"><a href="#9-2、jQuery-ajax" class="headerlink" title="9.2、jQuery.ajax"></a>9.2、jQuery.ajax</h3><p>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</p>
<p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p>
<p>jQuery 提供多个与 AJAX 有关的方法。</p>
<p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p>
<p>jQuery 不是生产者，而是大自然搬运工。</p>
<p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p>
<pre><code class="javascript">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</code></pre>
<p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p>
<p>1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
   &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;
    &lt;!--让spring不处理静态资源--&gt;
   &lt;mvc:default-servlet-handler /&gt;
   &lt;mvc:annotation-driven /&gt;
   &lt;!-- 视图解析器 --&gt;
   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
         id=&quot;internalResourceViewResolver&quot;&gt;
       &lt;!-- 前缀 --&gt;
       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
       &lt;!-- 后缀 --&gt;
       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>2、编写一个AjaxController</p>
<pre><code class="java">@Controller
public class AjaxController {
   @RequestMapping(&quot;/a1&quot;)
   public void ajax1(String name , HttpServletResponse response) throws IOException {
       if (&quot;admin&quot;.equals(name)){
           response.getWriter().print(&quot;true&quot;);
      }else{
           response.getWriter().print(&quot;false&quot;);
      }
  }
}</code></pre>
<p>3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p>
<pre><code class="javascript">&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>4、编写index.jsp测试</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;$Title$&lt;/title&gt;
        &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;
        &lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            function a1(){
                $.post({
                    url:&quot;${pageContext.request.contextPath}/a1&quot;,
                    data:{&#39;name&#39;:$(&quot;#txtName&quot;).val()},
                    success:function (data,status) {
                        alert(data);
                        alert(status);
                    }
                });
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%--onblur：失去焦点触发事件--%&gt;
        用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p>
<p><strong>Springmvc实现</strong></p>
<p>实体类user</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
   private String name;
   private int age;
   private String sex;
}</code></pre>
<p>我们来获取一个集合对象，展示到前端页面</p>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2(){
   List&lt;User&gt; list = new ArrayList&lt;User&gt;();
   list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));
   list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));
   list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));
   return list; //由于@RestController注解，将list转成json格式返回
}</code></pre>
<p>前端页面</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;
&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;
   &lt;tr&gt;
       &lt;td&gt;姓名&lt;/td&gt;
       &lt;td&gt;年龄&lt;/td&gt;
       &lt;td&gt;性别&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tbody id=&quot;content&quot;&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
   $(function () {
       $(&quot;#btn&quot;).click(function () {
           $.post(&quot;${pageContext.request.contextPath}/a2&quot;,function (data) {
               console.log(data)
               var html=&quot;&quot;;
               for (var i = 0; i &lt;data.length ; i++) {
                   html+= &quot;&lt;tr&gt;&quot; +
                       &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                       &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                       &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                       &quot;&lt;/tr&gt;&quot;
              }
               $(&quot;#content&quot;).html(html);
          });
      })
  })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p>
<p><strong>注册提示效果</strong></p>
<p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p>
<p>我们写一个Controller</p>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String pwd){
   String msg = &quot;&quot;;
   //模拟数据库中存在数据
   if (name!=null){
       if (&quot;admin&quot;.equals(name)){
           msg = &quot;OK&quot;;
      }else {
           msg = &quot;用户名输入错误&quot;;
      }
  }
   if (pwd!=null){
       if (&quot;123456&quot;.equals(pwd)){
           msg = &quot;OK&quot;;
      }else {
           msg = &quot;密码输入有误&quot;;
      }
  }
   return msg; //由于@RestController注解，将msg转成json格式返回
}</code></pre>
<p>前端页面 login.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;ajax&lt;/title&gt;
   &lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
   &lt;script&gt;
       function a1(){
           $.post({
               url:&quot;${pageContext.request.contextPath}/a3&quot;,
               data:{&#39;name&#39;:$(&quot;#name&quot;).val()},
               success:function (data) {
                   if (data.toString()==&#39;OK&#39;){
                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);
                  }else {
                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);
                  }
                   $(&quot;#userInfo&quot;).html(data);
              }
          });
      }
       function a2(){
           $.post({
               url:&quot;${pageContext.request.contextPath}/a3&quot;,
               data:{&#39;pwd&#39;:$(&quot;#pwd&quot;).val()},
               success:function (data) {
                   if (data.toString()==&#39;OK&#39;){
                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);
                  }else {
                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);
                  }
                   $(&quot;#pwdInfo&quot;).html(data);
              }
          });
      }
   &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;
   &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
  密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;
   &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>【记得处理json乱码问题】</p>
<p><strong>获取baidu接口Demo</strong></p>
<pre><code class="jsp">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
   &lt;title&gt;JSONP百度搜索&lt;/title&gt;
   &lt;style&gt;
       #q{
           width: 500px;
           height: 30px;
           border:1px solid #ddd;
           line-height: 30px;
           display: block;
           margin: 0 auto;
           padding: 0 10px;
           font-size: 14px;
      }
       #ul{
           width: 520px;
           list-style: none;
           margin: 0 auto;
           padding: 0;
           border:1px solid #ddd;
           margin-top: -1px;
           display: none;
      }
       #ul li{
           line-height: 30px;
           padding: 0 10px;
      }
       #ul li:hover{
           background-color: #f60;
           color: #fff;
      }
   &lt;/style&gt;
   &lt;script&gt;
       // 2.步骤二
       // 定义demo函数 (分析接口、数据)
       function demo(data){
           var Ul = document.getElementById(&#39;ul&#39;);
           var html = &#39;&#39;;
           // 如果搜索数据存在 把内容添加进去
           if (data.s.length) {
               // 隐藏掉的ul显示出来
               Ul.style.display = &#39;block&#39;;
               // 搜索到的数据循环追加到li里
               for(var i = 0;i&lt;data.s.length;i++){
                   html += &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;/li&gt;&#39;;
              }
               // 循环的li写入ul
               Ul.innerHTML = html;
          }
      }
       // 1.步骤一
       window.onload = function(){
           // 获取输入框和ul
           var Q = document.getElementById(&#39;q&#39;);
           var Ul = document.getElementById(&#39;ul&#39;);
           // 事件鼠标抬起时候
           Q.onkeyup = function(){
               // 如果输入框不等于空
               if (this.value != &#39;&#39;) {
                   // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
                   // 创建标签
                   var script = document.createElement(&#39;script&#39;);
                   //给定要跨域的地址 赋值给src
                   //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址
                   script.src = &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#39;+this.value+&#39;&amp;cb=demo&#39;;
                   // 将组合好的带src的script标签追加到body里
                   document.body.appendChild(script);
              }
          }
      }
   &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;
&lt;ul id=&quot;ul&quot;&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201120220207316.png" alt="在这里插入图片描述"></p>
<h2 id="10、拦截器"><a href="#10、拦截器" class="headerlink" title="10、拦截器"></a>10、拦截器</h2><h3 id="10-1、概述"><a href="#10-1、概述" class="headerlink" title="10.1、概述"></a>10.1、概述</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<p><strong>过滤器</strong></p>
<ul>
<li>servlet规范中的一部分，任何java web工程都可以使用</li>
<li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
<p><strong>拦截器</strong></p>
<ul>
<li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li>
</ul>
<h3 id="10-2、自定义拦截器"><a href="#10-2、自定义拦截器" class="headerlink" title="10.2、自定义拦截器"></a>10.2、自定义拦截器</h3><p>那如何实现拦截器呢？</p>
<p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<p>1、编写一个拦截器</p>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor {
   //在请求处理的方法之前执行
   //如果返回true执行下一个拦截器
   //如果返回false就不执行下一个拦截器
   public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
       System.out.println(&quot;------------处理前------------&quot;);
       return true;
  }
   //在请求处理方法执行之后执行
   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
       System.out.println(&quot;------------处理后------------&quot;);
  }
   //在dispatcherServlet处理后执行,做清理工作.
   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
       System.out.println(&quot;------------清理------------&quot;);
  }
}</code></pre>
<p>2、在springmvc的配置文件中配置拦截器</p>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
   &lt;mvc:interceptor&gt;
       &lt;!--/** 包括路径及其子路径--&gt;
       &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
       &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
       &lt;mvc:mapping path=&quot;/**&quot;/&gt;
       &lt;!--bean配置的就是拦截器--&gt;
       &lt;bean class=&quot;com.susu.interceptor.MyInterceptor&quot;/&gt;
   &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
<p>3、编写一个Controller，接收请求</p>
<pre><code class="java">//测试拦截器的控制器
@Controller
public class InterceptorController {
   @RequestMapping(&quot;/interceptor&quot;)
   @ResponseBody
   public String testFunction() {
       System.out.println(&quot;控制器中的方法执行了&quot;);
       return &quot;hello&quot;;
  }
}
</code></pre>
<p>4、前端 index.jsp</p>
<pre><code class="jsp">&lt;a href=&quot;${pageContext.request.contextPath}/interceptor&quot;&gt;拦截器测试&lt;/a&gt;</code></pre>
<p>启动tomcat 测试一下！</p>
<h3 id="10-3、-验证用户是否登录-认证用户"><a href="#10-3、-验证用户是否登录-认证用户" class="headerlink" title="10.3、 验证用户是否登录 (认证用户)"></a>10.3、 验证用户是否登录 (认证用户)</h3><p><strong>实现思路</strong></p>
<p>1、有一个登陆页面，需要写一个controller访问页面。</p>
<p>2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></p>
<p>3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p>
<p><strong>测试：</strong></p>
<p>1、编写一个登陆页面 login.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;h1&gt;登录页面&lt;/h1&gt;
&lt;hr&gt;
&lt;body&gt;
&lt;form action=&quot;${pageContext.request.contextPath}/user/login&quot;&gt;
  用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
  密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;
   &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>2、编写一个Controller处理请求</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
   //跳转到登陆页面
   @RequestMapping(&quot;/jumplogin&quot;)
   public String jumpLogin() throws Exception {
       return &quot;login&quot;;
  }
   //跳转到成功页面
   @RequestMapping(&quot;/jumpSuccess&quot;)
   public String jumpSuccess() throws Exception {
       return &quot;success&quot;;
  }
   //登陆提交
   @RequestMapping(&quot;/login&quot;)
   public String login(HttpSession session, String username, String pwd) throws Exception {
       // 向session记录用户身份信息
       System.out.println(&quot;接收前端===&quot;+username);
       session.setAttribute(&quot;user&quot;, username);
       return &quot;success&quot;;
  }
   //退出登陆
   @RequestMapping(&quot;logout&quot;)
   public String logout(HttpSession session) throws Exception {
       // session 过期
       session.invalidate();
       return &quot;login&quot;;
  }
}</code></pre>
<p>3、编写一个登陆成功的页面 success.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;登录成功页面&lt;/h1&gt;
&lt;hr&gt;
${user}
&lt;a href=&quot;${pageContext.request.contextPath}/user/logout&quot;&gt;注销&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
 &lt;head&gt;
   &lt;title&gt;$Title$&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;h1&gt;首页&lt;/h1&gt;
 &lt;hr&gt;
&lt;%--登录--%&gt;
 &lt;a href=&quot;${pageContext.request.contextPath}/user/jumplogin&quot;&gt;登录&lt;/a&gt;
 &lt;a href=&quot;${pageContext.request.contextPath}/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>5、编写用户登录拦截器</p>
<pre><code class="java">public class LoginInterceptor implements HandlerInterceptor {
   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {
       // 如果是登陆页面则放行
       System.out.println(&quot;uri: &quot; + request.getRequestURI());
       if (request.getRequestURI().contains(&quot;login&quot;)) {
           return true;
      }
       HttpSession session = request.getSession();
       // 如果用户已登陆也放行
       if(session.getAttribute(&quot;user&quot;) != null) {
           return true;
      }
       // 用户没有登陆跳转到登陆页面
       request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
       return false;
  }
   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
  }
   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
  }
}</code></pre>
<p>6、在Springmvc的配置文件中注册拦截器</p>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
   &lt;mvc:interceptor&gt;
       &lt;mvc:mapping path=&quot;/**&quot;/&gt;
       &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt;
   &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
<p>7、再次重启Tomcat测试！</p>
<p><strong>OK，测试登录拦截功能无误.</strong></p>
<h2 id="11、文件上传-文件下载"><a href="#11、文件上传-文件下载" class="headerlink" title="11、文件上传+文件下载"></a>11、文件上传+文件下载</h2><h3 id="11-1、准备工作"><a href="#11-1、准备工作" class="headerlink" title="11.1、准备工作"></a>11.1、准备工作</h3><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p>
<p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="jsp">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
   &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
   &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
<p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li>
<li>而Spring MVC则提供了更简单的封装。</li>
<li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li>
<li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</li>
<li>CommonsMultipartResolver。因此，<strong>SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件</strong>。</li>
</ul>
<h3 id="11-2、文件上传"><a href="#11-2、文件上传" class="headerlink" title="11.2、文件上传"></a>11.2、文件上传</h3><p>1、 导包</p>
<pre><code class="xml">&lt;!--文件上传--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
   &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--servlet-api导入高版本的--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
   &lt;version&gt;4.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>2、 配置bean：multipartResolver</p>
<p>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>CommonsMultipartFile 的 常用方法：</p>
<ul>
<li><p><strong>String getOriginalFilename()：获取上传文件的原名</strong></p>
</li>
<li><p><strong>InputStream getInputStream()：获取文件流</strong></p>
</li>
<li><p><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></p>
<p>我们去实际测试一下</p>
</li>
</ul>
<p>3、编写前端页面</p>
<pre><code class="jsp">form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
&lt;/form&gt;</code></pre>
<p>4、<strong>Controller</strong></p>
<pre><code class="java">@Controller
public class FileController {
    //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
    //批量上传CommonsMultipartFile则为数组即可
    @RequestMapping(&quot;/upload&quot;)
    public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException {
        //获取文件名 : file.getOriginalFilename();
        String uploadFileName = file.getOriginalFilename();
        //如果文件名为空，直接回到首页！
        if (&quot;&quot;.equals(uploadFileName)){
            return &quot;redirect:/index.jsp&quot;;
        }
        System.out.println(&quot;上传文件名 : &quot;+uploadFileName);
        //上传路径保存设置
        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
        //如果路径不存在，创建一个
        File realPath = new File(path);
        if (!realPath.exists()){
            realPath.mkdir();
        }
        System.out.println(&quot;上传文件保存地址：&quot;+realPath);
        InputStream is = file.getInputStream(); //文件输入流
        OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流
        //读取写出
        int len=0;
        byte[] buffer = new byte[1024];
        while ((len=is.read(buffer))!=-1){
            os.write(buffer,0,len);
            os.flush();
        }
        os.close();
        is.close();
        return &quot;redirect:/index.jsp&quot;;
    }
}</code></pre>
<p>5、测试上传文件，OK！</p>
<p><strong>采用file.Transto 来保存上传的文件</strong></p>
<p>1、编写Controller</p>
<pre><code class="java">/*
* 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException {
    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists()){
        realPath.mkdir();
    }
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);
    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));
    return &quot;redirect:/index.jsp&quot;;
}</code></pre>
<p>2、前端表单提交地址修改</p>
<p>3、访问提交测试，OK！</p>
<h3 id="11-3-、文件下载"><a href="#11-3-、文件下载" class="headerlink" title="11.3 、文件下载"></a>11.3 、文件下载</h3><p><strong>文件下载步骤：</strong></p>
<p>1、设置 response 响应头</p>
<p>2、读取文件 — InputStream</p>
<p>3、写出文件 — OutputStream</p>
<p>4、执行操作</p>
<p>5、关闭流 （先开后关）</p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;基础语法.jpg&quot;;
    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
                       &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));
    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();
    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1){
        out.write(buff, 0, index);
        out.flush();
    }
    out.close();
    input.close();
    return null;
}</code></pre>
<p>前端</p>
<pre><code class="html">&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;</code></pre>
<p>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</p>
<p><img src="https://img-blog.csdnimg.cn/20201121114345339.png" alt="在这里插入图片描述"> </p>
]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式 "></a>设计模式 <a id="more"></a></h1><h1 id="1、Java设计模式"><a href="#1、Java设计模式" class="headerlink" title="1、Java设计模式"></a>1、Java设计模式</h1><h2 id="1-1、原型设计模式问题"><a href="#1-1、原型设计模式问题" class="headerlink" title="1.1、原型设计模式问题"></a>1.1、原型设计模式问题</h2><ol>
<li>有请用UML类图画出原型模式核心角色</li>
<li>原型设计模式的深拷贝和浅拷贝是什么?并写出深拷贝的两种方式的源码</li>
<li>在Spring框架中哪里使用到原型模式，并对源码进行分析</li>
<li>设计模式的七大设计原则核心思想</li>
<li>能够以类图的说明设计原则</li>
<li>在项目实际开发中，你在哪里用到了ocp原则</li>
</ol>
<h2 id="1-2、设计模式的目的"><a href="#1-2、设计模式的目的" class="headerlink" title="1.2、设计模式的目的"></a>1.2、设计模式的目的</h2><ul>
<li>代码重用性（相同功能的代码，不用多次编写）</li>
<li>可读性（编程规范性，便于其他程序员阅读和理解）</li>
<li>可扩展性（当需要增加新的功能时，非常的方便）</li>
<li>可靠性（当我们增加新的功能后，对原来的功能没有影响）</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ul>
<h1 id="2、设计模式的七大原则"><a href="#2、设计模式的七大原则" class="headerlink" title="2、设计模式的七大原则"></a>2、设计模式的七大原则</h1><ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则 </li>
<li>开闭原则</li>
<li>迪米特原则</li>
<li>合成复用原则</li>
</ul>
<h2 id="2-1、单一职责原则"><a href="#2-1、单一职责原则" class="headerlink" title="2.1、单一职责原则"></a>2.1、单一职责原则</h2><p><strong>基本介绍</strong></p>
<p>​    对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2.当职责1需求变更时而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p>
<pre><code class="java">class Vehicle2{
    public void run(String vehicle){
        System.out.println(vehicle + &quot;公路运行&quot;);
    }
    public void runAir(String vehicle){
        System.out.println(vehicle + &quot;在天空中运行&quot;);
    }
    public void runWater(String vehicle){
        System.out.println(vehicle + &quot;在水中运行&quot;);
    }

}</code></pre>
<h2 id="2-2、接口隔离原则"><a href="#2-2、接口隔离原则" class="headerlink" title="2.2、接口隔离原则"></a>2.2、接口隔离原则</h2><p><strong>基本介绍</strong></p>
<p>​    客户端不应该依赖他不需要的接口。即一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p><strong>实例：</strong></p>
<p>​    类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210107210502179.png" alt="image-20210107210502179"></p>
<p><strong>改进：</strong></p>
<p>​    将接口Interface1拆分为独立的3个接口，类A和类C分别与他们需要的接口建立依赖关系。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210107210658648.png" alt="image-20210107210658648"></p>
<h2 id="2-3、依赖倒转原则"><a href="#2-3、依赖倒转原则" class="headerlink" title="2.3、依赖倒转原则"></a>2.3、依赖倒转原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>高层模块不应该依赖底层模块，二者应该依赖其抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定得多，以抽象为基础搭建的架构要比以细节为基础的架构稳定得多。在Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li>
</ol>
<p><strong>实例：</strong></p>
<pre><code class="java">//方式1
package inversion;

public class DependecyInversion {
    public static void main(String[] args){
    Person person = new Person();
    person.receive(new Email());
    }
}

class Email{
    public String getInfo(){
        return &quot;电子邮件信息：Hello，world&quot;;
    }
}

//完成person接收信息的功能
class Person{
    public void receive(Email email){
        System.out.println(email.getInfo());
    }
}</code></pre>
<p><strong>分析：</strong></p>
<ol>
<li><p>简单，容易被想到</p>
</li>
<li><p>如果我们获取的对象是 微信，短信等，则新增类，同时Person也要增加相应的接收方法。</p>
</li>
<li><p><strong>解决思路：</strong>引入一个抽象的接口IReceiver，表示接收者，这样Person类和接口IReceiver发生依赖</p>
<p>因为Email，微信，等等属于接口IReceiver的范围，他们各自实现IReceiver接口就行，这样就符合依赖倒转原则。</p>
</li>
</ol>
<pre><code class="java">//方式2
package inversion2;

public class DependecyInversion {
    public static void main(String[] args){
    Person person = new Person();

    person.receiver(new Email());
    person.receiver(new WeiXin());
    }
}
//定义一个接口
interface IReceiver{
    public String getInfo();
}

class Email implements IReceiver{
    public String getInfo(){

        return &quot;电子邮件信息：Hello，world&quot;;
    }
}

//增加WeiXin
class WeiXin implements IReceiver{
    public String getInfo(){
        return &quot;微信信息：Hello，ok&quot;;
    }
}

//完成person接收信息的功能
class Person{
    public void receiver(IReceiver receiver){
        System.out.println(receiver.getInfo());
    }
}</code></pre>
<p><strong>依赖倒转原则注意事项和细节：</strong></p>
<ol>
<li>底层模块尽量都要有抽象类和接口，或者两者都有，程序稳定性会更好。</li>
<li>变量的声明尽量是抽象类和接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<h2 id="2-4、里氏替换原则"><a href="#2-4、里氏替换原则" class="headerlink" title="2.4、里氏替换原则"></a>2.4、里氏替换原则</h2><p><strong>OO中的继承性的思考和说明</strong></p>
<ol>
<li>继承包含这样的一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然他不强制要求所有子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>集成在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及子类的功能都有可能产生故障。</li>
</ol>
<p><strong>基本介绍</strong></p>
<ol>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替代成o2时，程序P没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须透明的使用其子类的对象。</li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</li>
<li>里氏替换原则告诉我们，级城市加上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</li>
</ol>
<p><strong>案例：</strong></p>
<pre><code class="java">package liskov;

public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(&quot;11-3=&quot;+a.func1(11,3));

        System.out.println(&quot;-------------------&quot;);

        B b = new B();
        System.out.println(&quot;11-3=&quot;+b.func1(11,3));
        System.out.println(&quot;11+3=&quot;+b.func2(11,3));
    }

//A类：返回两个数的差
static class A{

    public int func1(int num1,int num2){
            return num1-num2;
        }
}
//B类继承A类,并重写了func1
//新增一个功能func2
static class B extends A{
    public int func1(int a,int b){
        return a + b;
    }
    public int func2(int a,int b){
        return func1(a,b) +9;
    }
}
}</code></pre>
<p><strong>分析:</strong></p>
<ol>
<li>我们发现原本运行正常的功能发生了错误，原因就是类B无意间重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。</li>
<li>通常的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系替代。</li>
</ol>
<pre><code class="java">package liskov.improve;
public class Liskov2 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(&quot;11-3=&quot;+a.func1(11,3));

        System.out.println(&quot;-------------------&quot;);

        B b = new B();
        System.out.println(&quot;11+3=&quot;+b.func1(11,3));
        System.out.println(&quot;11+3+9=&quot;+b.func2(11,3));
        //使用组合仍可可以使用到A类的方法
        System.out.println(&quot;11-3=&quot;+b.func3(11,3));
    }
//创建一个更加基础的基类
    static class Base{
       //把更加基础的方法和成员写到Base类中

    }
    //A类：返回两个数的差
    static class A extends Base {

        public int func1(int num1,int num2){
            return num1-num2;
        }
    }
    //B类继承A类,并重写了func1
    static class B extends Base{
        //如果B类需要用到A类的方法，使用组合的方式
        private A a = new A();
        public int func1(int a,int b){
            return a + b;
        }
        public int func2(int a,int b){
            return func1(a,b) +9;
        }
    //仍然像想使用A的方法
        public int func3(int a,int b){
            return this.a.func1(a,b);
        }
    }
}</code></pre>
<h2 id="2-5、开闭原则"><a href="#2-5、开闭原则" class="headerlink" title="2.5、开闭原则"></a>2.5、开闭原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>开闭原则是编程中最基础，最重要的设计原则。</li>
<li>一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。</li>
<li>当软件需要变化时，尽量<strong>通过扩展软件实体的行为</strong>来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>编程中遵循其他规则，以及使用设计模式的目的就是遵循开闭原则。</li>
</ol>
<p><strong>实例：</strong></p>
<pre><code class="java">//方式1
package ocp;

public class Ocp {
    public static void main(String[] args) {
    GraphicEditor graphicEditor = new GraphicEditor();
    graphicEditor.drawShape(new Rectangle());
    graphicEditor.drawShape(new Circle());

    }
}
//这是一个用于绘图的类
class GraphicEditor{
    //接收Shape对象，然后根据type的值，来绘制不同的图形
    public void drawShape(Shape s){
        if (s.m_type==1)
            drawRectangle(s);
        else if (s.m_type==2)
            drawCircle(s);
    }
    public void drawRectangle(Shape r){
        System.out.println(&quot;绘制矩形&quot;);
    }
    public void drawCircle(Shape r){
        System.out.println(&quot;绘制圆形&quot;);
    }

}
class Shape{
    int m_type;
}

class Rectangle extends Shape{
    Rectangle(){
        super.m_type=1;
    }
}
class Circle extends  Shape{
    Circle(){
        super.m_type=2;
    }
}
</code></pre>
<p><strong>方式1的优缺点</strong></p>
<ol>
<li>优点是比较好理解，简单易操作</li>
<li>缺点是违反了设计模式的ocp原则，即对外开放，对修改关闭。即当我们给类增加新功能时，尽量不修改代码，或者尽可能的少修改代码。</li>
<li>比如我们这是要增加一个图形类三角形，我们需要做一下修改，需要修改的地方比较多。</li>
</ol>
<pre><code class="java">//改进1:增加新的图形类，并继承Shape类，并在判断语句中添加相应的判断。
package ocp;

public class Ocp {
    public static void main(String[] args) {
    GraphicEditor graphicEditor = new GraphicEditor();
    graphicEditor.drawShape(new Rectangle());
    graphicEditor.drawShape(new Circle());
    graphicEditor.drawTriangle(new Triangle());

    }
}
//这是一个用于绘图的类
class GraphicEditor{
    //接收Shape对象，然后根据type的值，来绘制不同的图形
    public void drawShape(Shape s){
        if (s.m_type==1)
            drawRectangle(s);
        else if (s.m_type==2)
            drawCircle(s);
        else if (s.m_type==3)
            drawTriangle(s);
    }
    public void drawRectangle(Shape r){
        System.out.println(&quot;绘制矩形&quot;);
    }
    public void drawCircle(Shape r){
        System.out.println(&quot;绘制圆形&quot;);
    }
    public void drawTriangle(Shape r){
        System.out.println(&quot;绘制三角形&quot;);
    }

}
class Shape{
    int m_type;
}

class Rectangle extends Shape{
    Rectangle(){
        super.m_type=1;
    }
}
class Circle extends  Shape{
    Circle(){
        super.m_type=2;
    }
}
class Triangle extends  Shape{
    Triangle(){
        super.m_type=3;
    }
}</code></pre>
<p><strong>方法1的改进的思路分析</strong></p>
<p>​    把创建的Shape类做成抽象类，并提供一个抽象方法draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类去继承Shape，并实现draw方法即可。</p>
<pre><code class="java">//改进2:把创建的Shape类做成抽象类，并提供抽象方法draw，让子类去实现即可。
package ocp.improve;

class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();

        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle());

    }
}
//这是一个用于绘图的类
class GraphicEditor{
    //接收Shape对象，调用draw方法
    public void drawShape(Shape s){
        s.draw();
    }

}
abstract class Shape{


    public abstract void draw();
}

class Rectangle extends Shape{
    Rectangle(){

    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制矩形&quot;);
    }
}
class Circle extends  Shape{
    Circle(){

    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制圆形&quot;);
    }
}
class Triangle extends  Shape{
    Triangle(){

    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制三角形&quot;);
    }
}</code></pre>
<h2 id="2-6、迪米特法则"><a href="#2-6、迪米特法则" class="headerlink" title="2.6、迪米特法则"></a>2.6、迪米特法则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类和类关系越密切，耦合度越大</li>
<li>迪米特法则又称<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。</li>
<li>只与直接的朋友通信。</li>
<li><strong>直接的朋友：</strong>每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<p><strong>实例：</strong>有一个学校，下属有各个学院和总部，现要求打印学校总部成员工ID和学院员工的id。</p>
<pre><code class="java">package demeter;

import java.util.ArrayList;
import java.util.List;

public class demeter1 {
    public static void main(String[] args) {
    SchoolManger schoolManger = new SchoolManger();
    schoolManger.printAllEmployee(new CollegeManger());
    }
}

//学校总部员工类
class Employee{
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}
//学院员工类
class CollegeEmployee{
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}
//管理学院员工的管理类
class CollegeManger{
    public List&lt;CollegeEmployee&gt; getAllEmployee(){
        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;CollegeEmployee&gt;();
        for (int i = 0; i &lt; 10; i++) {
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId(&quot;学院员工id= &quot;+i);
            list.add(emp);
        }
        return list;
    }
}
//学校管理类
class SchoolManger {
    //返回学校总部员工
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Employee emp = new Employee();
            emp.setId(&quot;学校总部员工id= &quot;+i);
            list.add(emp);
        }
        return list;
    }

//该方法完成输出学校总部和学院员工信息（id）
    void printAllEmployee(CollegeManger sub){
        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();
        System.out.println(&quot;------分公司员工-------&quot;);
        for (CollegeEmployee e :list1) {
            System.out.println(e.getId());
        }
        List&lt;Employee&gt; list2 = this.getAllEmployee();
        System.out.println(&quot;-------学院总部员工-------&quot;);
        for (Employee e:list2) {
            System.out.println(e.getId());
        }
    }


}</code></pre>
<p><strong>分析：</strong></p>
<p>​    SchoolManger类的直接朋友有哪些？ Employee,CollegeManger</p>
<p>​    CollegeEmployee不是直接朋友，而是一个陌生类，违背了迪米特法则。</p>
<p><strong>改进思路</strong></p>
<ol>
<li>前面设计的问题在于SchoolManger中 ，CollEmployee类并不是SchoolManger类的直接朋友。</li>
<li>按照迪米特法则，应该避免类中出现这样的非直接朋友关系的耦合。</li>
</ol>
<pre><code class="java">package demeter.improve;

import java.util.ArrayList;
import java.util.List;

public class demeter1 {
    public static void main(String[] args) {
    SchoolManger schoolManger = new SchoolManger();
    schoolManger.printAllEmployee(new CollegeManger());
    }
}

//学校总部员工类
class Employee{
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//学院员工类
class CollegeEmployee{
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//管理学院员工的管理类
class CollegeManger{
    public List&lt;CollegeEmployee&gt; getAllEmployee(){
        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;CollegeEmployee&gt;();
        for (int i = 0; i &lt; 10; i++) {
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId(&quot;学院员工id= &quot;+i);
            list.add(emp);
        }
        return list;
    }
    //输出学院员工的信息
    public void printEmployee(){
        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();
        System.out.println(&quot;------分公司员工-------&quot;);
        for (CollegeEmployee e :list1) {
            System.out.println(e.getId());
        }
    }
}

//学校管理类
class SchoolManger {
    //返回学校总部员工
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Employee emp = new Employee();
            emp.setId(&quot;学校总部员工id= &quot;+i);
            list.add(emp);
        }
        return list;
    }

//该方法完成输出学校总部和学院员工信息（id）
    void printAllEmployee(CollegeManger sub){
        //输出学院员工
        sub.printEmployee();

        List&lt;Employee&gt; list2 = this.getAllEmployee();
        System.out.println(&quot;-------学院总部员工-------&quot;);
        for (Employee e:list2) {
            System.out.println(e.getId());
        }
    }


}</code></pre>
<p><strong>分析：</strong></p>
<ol>
<li>将输出学院的员工方法，封装到CollegeManger</li>
</ol>
<p><strong>迪米特法则注意事项和细节</strong></p>
<ol>
<li>迪米特法则的核心就是降低类之间的耦合</li>
<li>注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求减低类间（对象间）的耦合关系，并不是要求完全没有依赖关系。</li>
</ol>
<h2 id="2-7、合成复用原则"><a href="#2-7、合成复用原则" class="headerlink" title="2.7、合成复用原则"></a>2.7、合成复用原则</h2><p><strong>基本介绍</strong></p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108134655716.png" alt="image-20210108134655716"></p>
<p><strong>设计原则核心思想：</strong></p>
<ol>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<h1 id="3、UML类图"><a href="#3、UML类图" class="headerlink" title="3、UML类图"></a>3、UML类图</h1><h2 id="3-1、UML基本介绍"><a href="#3-1、UML基本介绍" class="headerlink" title="3.1、UML基本介绍"></a>3.1、UML基本介绍</h2><ol>
<li>UML统一建模语言，是一种用于软件系统分析和设计的语言工具，他用与帮助软件开发人员进行思考和记录思路的结果。</li>
<li>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类，接口，实现，泛华，依赖，组合，聚合等</li>
<li>使用UML来建模，常用的工具有Rational Rose，也可以使用一些插件来建模。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108141956726.png" alt="image-20210108141956726"></p>
<p><strong>UML图</strong></p>
<p>​    画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理。</p>
<p><strong>UML图分类</strong></p>
<ol>
<li>用例图</li>
<li>静态结构图：类图，对象图，包图，组件图，部署图</li>
<li>行为动态图：交互图（时序图和协作图），状态图，活动图</li>
</ol>
<p><strong>说明：</strong></p>
<ol>
<li>类图是描述类和类之间的关系的，是UML图中最核心的</li>
<li>在讲解设计模式时，我们必然会实用类图，为了让学员们能够把设计模式学到位，需要先给大家讲解类图</li>
</ol>
<h2 id="3-2、UML类图"><a href="#3-2、UML类图" class="headerlink" title="3.2、UML类图"></a>3.2、UML类图</h2><ol>
<li>用于描述系统中中的类（对象）之间的各种静态关系。</li>
<li>类之间的关系：依赖，泛化（继承），实现，关联，聚合与组合</li>
<li>类图简单举例</li>
</ol>
<pre><code class="java">public class Person{
    private Integer id;
    private String name;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}</code></pre>
<p>代码转化为类图</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108144336538.png" alt="image-20210108144336538"></p>
<h3 id="3-2-1、依赖关系"><a href="#3-2-1、依赖关系" class="headerlink" title="3.2.1、依赖关系"></a>3.2.1、依赖关系</h3><p>​    只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了。</p>
<pre><code class="java">public class PersonServiceBean{
    public PersonDao personDao;//类
    public void save(Person person){

    }
    public IDCard getIDCard(Integer personid){

    }
    public void modify(){
        Department department = new Department();
    }
}
public class PersonDao{}
public class IDCard{}
public class Person{}
public class Department{}</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108150012386.png" alt="image-20210108150012386"></p>
<p><strong>小结：</strong></p>
<ol>
<li>类中用到了对方</li>
<li>如果是类的成员属性</li>
<li>如果是方法的返回类型</li>
<li>是方法接受的参数类型</li>
<li>方法中使用到</li>
</ol>
<h3 id="3-2-2、泛化关系"><a href="#3-2-2、泛化关系" class="headerlink" title="3.2.2、泛化关系"></a>3.2.2、泛化关系</h3><p>泛化关系其实就是继承关系，它是依赖关系的特例</p>
<pre><code class="java">public abstract class DaoSuppert{
    public void save(Object entity){

    }
    public void delete(Object id){

    }
}
public class PersonServiceBean extends DaoSuppert{

}</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108151856745.png" alt="image-20210108151856745"></p>
<p><strong>小结：</strong></p>
<ol>
<li>泛化关系实际上就是继承关系</li>
<li>如果A类继承了B类，我们就说A和B存在泛化关系</li>
</ol>
<h3 id="3-2-3、实现关系"><a href="#3-2-3、实现关系" class="headerlink" title="3.2.3、实现关系"></a>3.2.3、实现关系</h3><p>实现关系实际上就是A类实现B类，它是依赖关系的特例</p>
<pre><code class="java">public interface PersonService{
    public void delete(Integer id);
}
public class PersonServiceBean implements PersonService{
    public void delete(Integer id){

    }
}</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108153007576.png" alt="image-20210108153007576"></p>
<h3 id="3-2-4、关联关系"><a href="#3-2-4、关联关系" class="headerlink" title="3.2.4、关联关系"></a>3.2.4、关联关系</h3><p>​    关联关系实际上就是类和类之间的联系，它是依赖关系的特例</p>
<p>​    关联关系具有导航性：即双向关系或单向关系</p>
<p>​    关联关系具有多重性：如“1”（表示有且仅有一个），“0….”（表示0个或者多个），</p>
<p>“0,1”（表示0个或者1个），“n….m”（表示n到m个都可以），“m….”（表示至少m个）。</p>
<pre><code class="java">//单向一对一关系
public class Person{
    private IDCard card;
}
public class IDCard{

}
//双向一对一关系
public class Person{
    private IDCard card;
}
public class IDCard{
    private Person person;
}</code></pre>
<h3 id="3-2-5、聚合关系"><a href="#3-2-5、聚合关系" class="headerlink" title="3.2.5、聚合关系"></a>3.2.5、聚合关系</h3><p>​    聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以它具有关联关系的导航性和多重性。</p>
<p>如：一台电脑由键盘，显示器，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示。</p>
<pre><code class="java">public class Computer{
    private Mouse mouse;//鼠标可以和Computer分离
    private Monitor monitor;//显示器可以和Computer分离

    public void setMouse(Mouse mouse){
        this.mouse = mouse;
    }
    public void setMonitor(Monitor monitor){
        this.monitor = monitor;
    }  
}</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108155115574.png" alt="image-20210108155115574"></p>
<p>如果Mouse，Monitor和Computer是不可分离的，则升级为<strong>组合关系</strong></p>
<pre><code class="java">public class Computer{
    private Mouse = new Mouse();
    private Monitor = new Monitor();
}
public class Client{
    public static void main(String[] args){
        Computer computer = new Computer();
    }
}</code></pre>
<h3 id="3-2-6、组合关系"><a href="#3-2-6、组合关系" class="headerlink" title="3.2.6、组合关系"></a>3.2.6、组合关系</h3><p>组合关系：也使整体与部分的关系，但是整体与部分不可分开。</p>
<p><strong>案例：</strong></p>
<p>​    在程序中我们定义实体：Person与IDCard，Head，那么Head和Person就是组合，IDCard和Person就是聚合。</p>
<pre><code class="java">public class Person{
    private IDCard idcard;//聚合关系
    private Head head = new Head();//组合关系
}
public class IDCard{

}
public class Head{

}</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210108161621202.png" alt="image-20210108161621202"> </p>
<h1 id="4、设计模式概述"><a href="#4、设计模式概述" class="headerlink" title="4、设计模式概述"></a>4、设计模式概述</h1><h2 id="4-1、设计模式介绍"><a href="#4-1、设计模式介绍" class="headerlink" title="4.1、设计模式介绍"></a>4.1、设计模式介绍</h2><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长一段时间的试验和错误总结出来的。</li>
<li>设计模式是本质提高软件的维护性，通用性和扩展性，并降低软件的复杂度。</li>
<li>设计模式并不局限于某种预言，java,php,c++都有设计模式。</li>
</ol>
<h2 id="4-2、设计模式类型"><a href="#4-2、设计模式类型" class="headerlink" title="4.2、设计模式类型"></a>4.2、设计模式类型</h2><p>设计模式分为三种类型，共23种。</p>
<ol>
<li><strong>创建者模式：单例模式</strong>，抽象工厂模式，原型模式，建造者模式，<strong>工厂模式</strong>。</li>
<li><strong>结构型模式：</strong>适配器模式 ，桥接模式，<strong>装饰模式</strong>，组合模式，外观模式，享元模式，<strong>代理模式</strong>。</li>
<li><strong>行为型模式：</strong>模板方法模式，命令模式，访问者模式，迭代器模式，<strong>观察者模式</strong>，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）</li>
</ol>
<h2 id="4-3、单例模式"><a href="#4-3、单例模式" class="headerlink" title="4.3、单例模式"></a>4.3、单例模式</h2><h3 id="4-3-1、单例设计模式介绍"><a href="#4-3-1、单例设计模式介绍" class="headerlink" title="4.3.1、单例设计模式介绍"></a>4.3.1、<strong>单例设计模式介绍</strong></h3><p>​    所谓类的单例模式，就是采取一定的方法保证整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<p>​    比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这时就会使用到单例模式。</p>
<h3 id="4-3-2、单例设计模式的八种方式"><a href="#4-3-2、单例设计模式的八种方式" class="headerlink" title="4.3.2、单例设计模式的八种方式"></a>4.3.2、单例设计模式的八种方式</h3><ol>
<li><strong>饿汉式（静态常量）</strong></li>
<li><strong>饿汉式（静态代码块）</strong></li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="4-3-3、饿汉式（静态常量）"><a href="#4-3-3、饿汉式（静态常量）" class="headerlink" title="4.3.3、饿汉式（静态常量）"></a>4.3.3、饿汉式（静态常量）</h3><p><strong>步骤如下：</strong></p>
<ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
<li>代码实现</li>
</ol>
<pre><code class="java">package singleton.type1;

import java.sql.SQLOutput;

public class SingletonTest01 {
    public static void main(String[] args) {
    //测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同
    }
}
//饿汉式（静态常量）
class Singleton{

    //1.构造器私有化，外部不能new
    private Singleton(){

    }

    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();

    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>优点：这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步问题。</li>
<li>缺点：在类加载的时候就完成实例化，没有达到Lazy Loading（懒加载）的效果，如果从始至终从未使用过这个实力，则会造成内存的浪费。</li>
<li>这种方式基于classloder机制避免了多线程的同步问题，不过instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果</li>
<li>结论：这种单例模式可用，可能造成内存浪费。</li>
</ol>
<h3 id="4-3-4、饿汉式（静态代码块）"><a href="#4-3-4、饿汉式（静态代码块）" class="headerlink" title="4.3.4、饿汉式（静态代码块）"></a>4.3.4、饿汉式（静态代码块）</h3><pre><code class="java">public class SingletonTest02 {
    public static void main(String[] args) {
    //测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同
    }
}
//饿汉式（静态代码块）
class Singleton{

    //1.构造器私有化，外部不能new
    private Singleton(){

    }

    //2.本类内部创建对象实例
    private  static Singleton instance ;

    static{
        //在静态代码块中，创建单例对象
        instance = new Singleton();
    }

    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){

        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式和上面的方式其实相似，只不过是将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面的是一样的。</li>
<li>结论：这种单例模式可以用，但是可能造成内存浪费。</li>
</ol>
<h3 id="4-3-5、懒汉式（线程不安全）"><a href="#4-3-5、懒汉式（线程不安全）" class="headerlink" title="4.3.5、懒汉式（线程不安全）"></a>4.3.5、懒汉式（线程不安全）</h3><pre><code class="java">package singleton.type3;

public class SingletonTest03 {
    public static void main(String[] args) {

        System.out.println(&quot;懒汉式1，线程不安全&quot;);
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同

    }
}

class Singleton {
    private static Singleton instance;

    private Singleton(){

    }

    //提供一个静态的公有方法，当使用到该方法时，采取创建instance
    //即懒汉式

    public static  Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>起到了Lazy Loading（懒加载）的效果，但是只能在单线程下使用。</li>
<li>如果在多线程下，一个线程进入了if（singlethon==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可以使用这种方式。</li>
<li>结论：在实际开发中，不要使用这种方式</li>
</ol>
<h3 id="4-3-6、懒汉式（线程安全，同步方法）"><a href="#4-3-6、懒汉式（线程安全，同步方法）" class="headerlink" title="4.3.6、懒汉式（线程安全，同步方法）"></a>4.3.6、懒汉式（线程安全，同步方法）</h3><pre><code class="java">package singleton.type4;

public class SingletonTest04 {
    public static void main(String[] args) {

        System.out.println(&quot;懒汉式2，线程安全，同步方法&quot;);
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同

    }
}
//懒汉式（线程安全，同步方法）
class Singleton {
    private static Singleton instance;

    private Singleton(){

    }

    //提供一个静态的公有方法，加入了同步处理的代码，解决线程安全问题
    //即懒汉式

    public static synchronized Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>解决了线程不安全问题</li>
<li>效率太低了，每个线程在想获得类的实例的时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return进行了。方法进行同步效率太低</li>
<li>结论;在实际开发中，不推荐使用这种方法。</li>
</ol>
<h3 id="4-3-7、懒汉式（线程安全，同步代码块）"><a href="#4-3-7、懒汉式（线程安全，同步代码块）" class="headerlink" title="4.3.7、懒汉式（线程安全，同步代码块）"></a>4.3.7、懒汉式（线程安全，同步代码块）</h3><pre><code class="java">package singleton.type4;

public class SingletonTest04 {
    public static void main(String[] args) {

        System.out.println(&quot;懒汉式3，线程安全，同步方法&quot;);
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同

    }
}
//懒汉式（线程安全，同步方法）
class Singleton {
    private static Singleton instance;

    private Singleton(){

    }

    //提供一个静态的公有方法，在if判断时加入了同步处理的代码，解决线程安全问题
    //即懒汉式

    public static Singleton getInstance(){
        if (instance == null){

           synchronized (Singlethon.class){
               singlethon = new Singlethon();
           }
        }
        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的代码块。</li>
<li>但是这种同步并不能起到线程同步的作用。跟第三种实现方式遇到的情形一致，假如一个线程进入了if（singlethon==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</li>
<li>结论：在实际开发中，不能使用这种方式。</li>
</ol>
<h3 id="4-3-8、双重检查"><a href="#4-3-8、双重检查" class="headerlink" title="4.3.8、双重检查"></a>4.3.8、双重检查</h3><pre><code class="java">package singleton.type6;

public class SingletonTest05 {
    public static void main(String[] args) {

        System.out.println(&quot;双重检查&quot;);
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同

    }
}

//双重检查
class Singleton {
    private static volatile Singleton instance;

    private Singleton(){

    }

    //提供一个静态的公有方法，加入双重检查的代码，解决线程安全问题，解决懒加载问题。
    //同时保证了效率。
    public static synchronized Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>Double-Check概念是多线程开发中常使用到的，如代码所示，我们进行了两次if（singleton == null）检查，这样就可以保证线程安全了。</li>
<li>这样，实例化代码代码只执行了一次，后面再次访问时，判断if（singleton == null），直接return实例化对象，也避免了重复进行方法同步。</li>
<li>线程安全，延迟加载，效率较高</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式</li>
</ol>
<h3 id="4-3-9、静态内部类"><a href="#4-3-9、静态内部类" class="headerlink" title="4.3.9、静态内部类"></a>4.3.9、静态内部类</h3><pre><code class="java">package singleton.type7;

public class SingletonTest07 {
    public static void main(String[] args) {

        System.out.println(&quot;静态内部类完成单例模式&quot;);
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance==instance2);//true

        System.out.println(&quot;instance.hashCode=&quot;+ instance.hashCode());
        System.out.println(&quot;instance2.hashCode=&quot;+ instance2.hashCode());
        //hashCode相同

    }
}

//静态内部类
class Singleton {
    private static volatile Singleton instance;

    private Singleton(){

    }
    //写一个静态内部类，该类中有一个静态属性 Singleton
    private static class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }
    //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
    public static synchronized Singleton getInstance(){

        return SingletonInstance.INSTANCE;
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程</li>
<li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化的时候，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化</li>
<li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li>
<li>优点：避免了线程不安全，利用静态内部类的特点实现延迟加载，效率高</li>
<li>结论: 推荐使用</li>
</ol>
<h3 id="4-3-10、枚举"><a href="#4-3-10、枚举" class="headerlink" title="4.3.10、枚举"></a>4.3.10、枚举</h3><pre><code class="java">package singleton.type8;

import java.sql.SQLOutput;

public class SingletonTest08 {
    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance==instance2);

        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());

        instance.sayok();
    }

}

//使用枚举，可以实现单例
enum Singleton{
    INSTANCE;//属性
    public void sayok(){
        System.out.println(&quot;ok~&quot;);
    }
}</code></pre>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li>
<li>结论：推荐使用</li>
</ol>
<h3 id="4-3-11、单例模式在JDK应用中的源码分析"><a href="#4-3-11、单例模式在JDK应用中的源码分析" class="headerlink" title="4.3.11、单例模式在JDK应用中的源码分析"></a>4.3.11、单例模式在JDK应用中的源码分析</h3><p>在JDK中，java.lang.Runtime就是经典的单例模式</p>
<pre><code class="java">public class Runtime {
    private static final Runtime currentRuntime = new Runtime();

    private static Version version;

    public static Runtime getRuntime() {
        return currentRuntime;
    }
    private Runtime() {}
}</code></pre>
<h3 id="4-3-12、单例模式的注意事项和细节说明"><a href="#4-3-12、单例模式的注意事项和细节说明" class="headerlink" title="4.3.12、单例模式的注意事项和细节说明"></a>4.3.12、单例模式的注意事项和细节说明</h3><ol>
<li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new。</li>
<li>单例模式使用的场景：需要频繁创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常使用到的对象，工具类对象，频繁访问数据库或文件的对象（数据源，Session工厂等）</li>
</ol>
<h2 id="4-4、工厂设计模式"><a href="#4-4、工厂设计模式" class="headerlink" title="4.4、工厂设计模式"></a>4.4、工厂设计模式</h2><h3 id="4-4-1、简单工厂模式"><a href="#4-4-1、简单工厂模式" class="headerlink" title="4.4.1、简单工厂模式"></a>4.4.1、简单工厂模式</h3><p><strong>实例</strong></p>
<p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li>披萨的种类很多，比如（GreekPizz，CheesePizz等）</li>
<li>披萨的制作有 prepare,bake,cut,box</li>
<li>完成披萨店订购功能</li>
</ol>
<p><strong>传统方法</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210109181410834.png" alt="image-20210109181410834"></p>
<pre><code class="java">//传统方法
//将Pizza类做成抽象类
public abstract class Pizza {
    protected String name;
    //准备原材料，不同的披萨不一样，所以做成抽象方法
    public abstract void prepare();

    public void bake(){
        System.out.println(name +&quot;baking&quot;);
    }

    public void cut(){
        System.out.println(name +&quot;cutting&quot;);
    }

    public void box(){
        System.out.println(name +&quot;boxing&quot;);
    }

    public void setName(String name){
        this.name = name;
    }

}</code></pre>
<pre><code class="java">public class CheesePizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println(&quot;给奶酪披萨准备原材料&quot;);
    }
}
</code></pre>
<pre><code class="java">public class GreekPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println(&quot;给希腊披萨准备原材料&quot;);
    }
}</code></pre>
<pre><code class="java">public class OrderPizza {
    //构造器
    public OrderPizza(){
        Pizza pizza = null;

        String orderType;
        do {
            orderType = gettype();
            if (orderType.equals(&quot;greek&quot;)){
                pizza = new GreekPizza();
                pizza.setName(&quot;希腊披萨&quot;);
            }else if (orderType.equals(&quot;cheese&quot;)){
                pizza = new CheesePizza();
                pizza.setName(&quot;奶酪菩萨&quot;);
            }else {
                break;
            }
            //输出pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while(true);

    }

    //写一个方法，可以获取客户希望订购的披萨种类
    private String gettype(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }


}</code></pre>
<pre><code class="java">//相当于一个客户端，发出披萨的订购任务
public class PizzaStore {
    public static void main(String[] args) {
    new OrderPizza();
    }
}</code></pre>
<p><strong>传统方法的优缺点：</strong></p>
<ol>
<li>优点是比较好理解，简单易操作</li>
<li>缺点是违反了设计模式的ocp原则，即对外扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码。</li>
<li>比如我们这时要增加一个Pizza的种类（Pepper披萨），我们需要做如下修改。</li>
</ol>
<pre><code class="java">//添加一个PepperPizza类，继承Pizza类，并重写prepare
package factory.simplefactory.pizzastore.pizza;

public class PepperPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println(&quot;给胡椒披萨准备原材料&quot;);
    }
}</code></pre>
<pre><code class="java">//在OrderPizza中添加PepperPizza的判断逻辑
package factory.simplefactory.pizzastore.order;

import factory.simplefactory.pizzastore.pizza.CheesePizza;
import factory.simplefactory.pizzastore.pizza.GreekPizza;
import factory.simplefactory.pizzastore.pizza.PepperPizza;
import factory.simplefactory.pizzastore.pizza.PepperPizza;
import factory.simplefactory.pizzastore.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza {
    //构造器
    public OrderPizza(){
        Pizza pizza = null;

        String orderType;
        do {
            orderType = gettype();
            if (orderType.equals(&quot;greek&quot;)){
                pizza = new GreekPizza();
                pizza.setName(&quot;希腊披萨&quot;);
            }else if (orderType.equals(&quot;cheese&quot;)){
                pizza = new CheesePizza();
                pizza.setName(&quot;奶酪菩萨&quot;);
            }else if (orderType.equals(&quot;pepper&quot;)){
                pizza = new PepperPizza();
                pizza.setName(&quot;胡椒披萨&quot;);
            }
            else {
                break;
            }
            //输出pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while(true);

    }

    //写一个方法，可以获取客户希望订购的披萨种类
    private String gettype(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }


}</code></pre>
<ol start="4">
<li>改进思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类即可，其他有创建到Pizza对象的代码就不需要修改了。（简单工厂模式）</li>
</ol>
<p><strong>简单工厂模式基本介绍</strong></p>
<ol>
<li>简单工厂模式是属于创建者模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪种品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</li>
<li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。</li>
<li>在软件开发中，当我们会用到大量的创建某种，某类或者某批对象时，就会使用到工厂模式。</li>
</ol>
<p><strong>简单工厂模式的设计方案</strong></p>
<p>定义一个可以实例化Pizza对象的类，封装创建对象的代码。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210112172914146.png" alt="image-20210112172914146"></p>
<pre><code class="java">package factory.simplefactory.pizzastore.order;

import factory.simplefactory.pizzastore.pizza.CheesePizza;
import factory.simplefactory.pizzastore.pizza.GreekPizza;
import factory.simplefactory.pizzastore.pizza.PepperPizza;
import factory.simplefactory.pizzastore.pizza.Pizza;

//简单工厂类
public class SimpleFactory {
    //根据orderType，返回对应的Pizza对象
    public Pizza createPizza(String orderType){

        Pizza pizza = null;
        System.out.println(&quot;使用简单工厂模式&quot;);

        if (orderType.equals(&quot;greek&quot;)){
            pizza = new GreekPizza();
            pizza.setName(&quot;希腊披萨&quot;);
        }else if (orderType.equals(&quot;cheese&quot;)){
            pizza = new CheesePizza();
            pizza.setName(&quot;奶酪菩萨&quot;);
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new PepperPizza();
            pizza.setName(&quot;胡椒披萨&quot;);
        }
        return pizza;
    }

}
</code></pre>
<pre><code class="java">package factory.simplefactory.pizzastore.order;

import factory.simplefactory.pizzastore.pizza.CheesePizza;
import factory.simplefactory.pizzastore.pizza.GreekPizza;
import factory.simplefactory.pizzastore.pizza.PepperPizza;
import factory.simplefactory.pizzastore.pizza.PepperPizza;
import factory.simplefactory.pizzastore.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza {
    //定义一个简单工厂对象
    SimpleFactory simpleFactory;
    Pizza pizza = null;

    //构造器
    public OrderPizza(SimpleFactory simpleFactory){

        setFactory(simpleFactory);
    }

    public void setFactory(SimpleFactory simpleFactory){

        String orderType = &quot;&quot;; //用户输入的

        this.simpleFactory = this.simpleFactory;//设置简单工厂对象

        do {
            orderType = gettype();
            pizza = this.simpleFactory.createPizza(orderType);

            //输出Pizza
            if (pizza!= null){//订购成功

                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();

            } else {
                System.out.println(&quot;订购披萨失败&quot;);
                break;
            }
        }while (true);

    }

    //写一个方法，可以获取客户希望订购的披萨种类
    private String gettype(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }


}


</code></pre>
<pre><code class="java">package factory.simplefactory.pizzastore.order;

//相当于一个客户端，发出披萨的订购任务
public class PizzaStore {
    public static void main(String[] args) {
    //new OrderPizza();

        //使用简单工厂模式
        new OrderPizza(new SimpleFactory());
        System.out.println(&quot;退出程序&quot;);
    }
}
</code></pre>
<p><strong>简单工厂模式也称静态工厂模式</strong></p>
<pre><code class="java">//将工厂类改为静态类 
public static Pizza createPizza2(String orderType){

        Pizza pizza = null;
        System.out.println(&quot;使用简单工厂模式&quot;);

        if (orderType.equals(&quot;greek&quot;)){
            pizza = new GreekPizza();
            pizza.setName(&quot;希腊披萨&quot;);
        }else if (orderType.equals(&quot;cheese&quot;)){
            pizza = new CheesePizza();
            pizza.setName(&quot;奶酪菩萨&quot;);
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new PepperPizza();
            pizza.setName(&quot;胡椒披萨&quot;);
        }
        return pizza;
    }</code></pre>
<pre><code class="java">package factory.simplefactory.pizzastore.order;

import factory.simplefactory.pizzastore.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza2 {


    Pizza pizza = null;
    String orderType = &quot;&quot;;

    //构造器
    public OrderPizza2(){

        do {
            orderType = gettype();
            pizza =SimpleFactory.createPizza2(orderType);

            //输出Pizza
            if (pizza!= null){//订购成功

                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();

            } else {
                System.out.println(&quot;订购披萨失败&quot;);
                break;
            }
        }while (true);

    }


    private String gettype(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }
}
</code></pre>
<h3 id="4-4-2、工厂方法模式"><a href="#4-4-2、工厂方法模式" class="headerlink" title="4.4.2、工厂方法模式"></a>4.4.2、工厂方法模式</h3><p><strong>工厂方法模式介绍</strong></p>
<p>​    工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</p>
<p>​    工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<strong>对象的实例化推迟到子类</strong></p>
<p><strong>新的需求案例</strong></p>
<p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如，北京的奶酪pizza，北京的胡椒pizza，或者伦敦的奶酪pizza，伦敦的胡椒pizza。</p>
<p><strong>思路一</strong></p>
<p>使用简单工厂模式类，比如BJPizzaSimpleFactory，LDPizzaSimpleFactory等等，从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性，可扩展性都不是特别好。</p>
<p><strong>思路二</strong></p>
<p>使用工厂方法模式</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210112222111362.png" alt="image-20210112222111362"></p>
<pre><code class="java">//创建四种披萨
package factory.factorymethod.pizzastore.pizza;

public class BJCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName(&quot;北京的奶酪pizza&quot;);
        System.out.println(&quot;北京的奶酪pizza 准备原材料&quot;);
    }
}

package factory.factorymethod.pizzastore.pizza;

public class BJPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName(&quot;北京的胡椒pizza&quot;);
        System.out.println(&quot;北京的胡椒pizza 准备原材料&quot;);
    }
}

package factory.factorymethod.pizzastore.pizza;

public class LDCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName(&quot;伦敦的奶酪pizza&quot;);
        System.out.println(&quot;伦敦的奶酪pizza 准备原材料&quot;);
    }
}

package factory.factorymethod.pizzastore.pizza;

public class LDPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName(&quot;伦敦的胡椒pizza&quot;);
        System.out.println(&quot;伦敦的胡椒pizza 准备原材料&quot;);
    }
}</code></pre>
<pre><code class="java">package factory.factorymethod.pizzastore.order;

import factory.factorymethod.pizzastore.pizza.Pizza;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public abstract class OrderPizza {

    //定义一个抽象方法，createPizza，各个工厂子类自己实现
    abstract Pizza createPizza(String orderType);


    //构造器
    public OrderPizza(){
        Pizza pizza = null;

        String orderType;
        do {
            orderType = gettype();
            pizza = createPizza(orderType);//抽象方法，有工厂子类完成


            //输出pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while(true);

    }
    //写一个方法，可以获取客户希望订购的披萨种类
    private String gettype(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }
}</code></pre>
<pre><code class="java">package factory.factorymethod.pizzastore.order;

import factory.factorymethod.pizzastore.pizza.BJCheesePizza;
import factory.factorymethod.pizzastore.pizza.BJPepperPizza;
import factory.factorymethod.pizzastore.pizza.Pizza;
public class BJOrderPizza extends OrderPizza {
    @Override
    Pizza createPizza(String orderType) {
        factory.factorymethod.pizzastore.pizza.Pizza pizza = null;
        if (orderType.equals(&quot;cheese&quot;)){
            pizza = new BJCheesePizza();
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}</code></pre>
<pre><code class="java">package factory.factorymethod.pizzastore.order;
import factory.factorymethod.pizzastore.pizza.*;
public class LDOrderPizza extends OrderPizza {
    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals(&quot;cheese&quot;)){
            pizza = new LDCheesePizza();
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}</code></pre>
<h3 id="4-4-3、抽象工厂模式"><a href="#4-4-3、抽象工厂模式" class="headerlink" title="4.4.3、抽象工厂模式"></a>4.4.3、抽象工厂模式</h3><p><strong>基本介绍</strong></p>
<ol>
<li>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。</li>
<li>抽象工厂模式可以将简单工厂和工厂方法模式进行整合。</li>
<li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。</li>
<li>将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂变成了工厂簇，更利于代码的维护和发展。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210115193954740.png" alt="image-20210115193954740"></p>
<pre><code class="java">package factory.absfactory.pizzastore.pizza;

public class BJCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName(&quot;北京的奶酪pizza&quot;);
        System.out.println(&quot;北京的奶酪pizza 准备原材料&quot;);
    }
}


package factory.absfactory.pizzastore.pizza;

public class BJPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName(&quot;北京的胡椒pizza&quot;);
        System.out.println(&quot;北京的胡椒pizza 准备原材料&quot;);
    }
}


package factory.absfactory.pizzastore.pizza;

public class LDCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName(&quot;伦敦的奶酪pizza&quot;);
        System.out.println(&quot;伦敦的奶酪pizza 准备原材料&quot;);
    }
}


package factory.absfactory.pizzastore.pizza;

public class LDPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName(&quot;伦敦的胡椒pizza&quot;);
        System.out.println(&quot;伦敦的胡椒pizza 准备原材料&quot;);
    }
}
</code></pre>
<pre><code class="java">package factory.absfactory.pizzastore.order;
import factory.absfactory.pizzastore.pizza.LDCheesePizza;
import factory.absfactory.pizzastore.pizza.LDPepperPizza;
import factory.absfactory.pizzastore.pizza.Pizza;

//伦敦工厂子类
public class LDFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println(&quot;使用的是抽象工厂模式&quot;);
        Pizza pizza = null;
        if (orderType.equals(&quot;cheese&quot;)){
            pizza = new LDCheesePizza();
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new LDPepperPizza();
        }

        return pizza;
    }
}


package factory.absfactory.pizzastore.order;

import factory.absfactory.pizzastore.pizza.BJCheesePizza;
import factory.absfactory.pizzastore.pizza.BJPepperPizza;
import factory.absfactory.pizzastore.pizza.Pizza;

//北京工厂子类
public class BJFzctory implements AbsFactory {
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println(&quot;使用的是抽象工厂模式&quot;);

        Pizza pizza = null;

        if (orderType.equals(&quot;cheese&quot;)){
            pizza = new BJCheesePizza();
        }else if (orderType.equals(&quot;pepper&quot;)){
            pizza = new BJPepperPizza();
        }

        return pizza;
    }
}
</code></pre>
<pre><code class="java">package factory.absfactory.pizzastore.order;

import factory.absfactory.pizzastore.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza {


    AbsFactory factory;


    public  OrderPizza(AbsFactory absFactory){
        setFactory(factory);
    }

    private void setFactory(AbsFactory factory) {
        Pizza pizza = null;
        String orderType = &quot;&quot;;//用户输入
        this.factory = factory;

        do {
            orderType = getType();
            //factory 可能是北京的工厂子类，也有可能是伦敦的工厂子类
            pizza = factory.createPizza(orderType);

            if (pizza != null){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();

            }else{
                System.out.println(&quot;订购失败&quot;);
                break;
            }
        }while(true);
    }


    //写一个方法，可以获取客户希望订购的披萨种类
    private String getType(){
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println(&quot;input pizza 种类:&quot;);
            String str = strin.readLine();
            return str;
        }catch (IOException e){
            e.printStackTrace();
            return &quot;&quot;;
        }
    }
}
</code></pre>
<pre><code class="java">package factory.absfactory.pizzastore.order;

import factory.absfactory.pizzastore.pizza.Pizza;


//一个抽象工厂模式的抽象层（接口）

public interface AbsFactory {

    //让下面的工厂子类来具体实现
    public Pizza createPizza(String orderType);
}</code></pre>
<pre><code class="java">package factory.absfactory.pizzastore.order;

public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza(new BJFzctory());
    }
}</code></pre>
<h3 id="4-4-4、工厂模式在JDK中的源码分析"><a href="#4-4-4、工厂模式在JDK中的源码分析" class="headerlink" title="4.4.4、工厂模式在JDK中的源码分析"></a>4.4.4、工厂模式在JDK中的源码分析</h3><p>Calendar.getInstance()中使用了简单工厂模式</p>
<pre><code class="java">package factory;

import java.util.Calendar;

public class Factory {
    public static void main(String[] args) {
         Calendar cal= Calendar.getInstance();
    }
}
</code></pre>
<pre><code class="java">public static Calendar getInstance(TimeZone zone,
                                       Locale aLocale)
    {
        return createCalendar(zone, aLocale);
    }

    private static TimeZone defaultTimeZone(Locale l) {
        TimeZone defaultTZ = TimeZone.getDefault();
        String shortTZID = l.getUnicodeLocaleType(&quot;tz&quot;);
        return shortTZID != null ?
            TimeZoneNameUtility.convertLDMLShortID(shortTZID)
                .map(TimeZone::getTimeZone)
                .orElse(defaultTZ) :
            defaultTZ;
    }

    private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
    {
        CalendarProvider provider =
            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                                 .getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {

            }
        }

        Calendar cal = null;

        if (aLocale.hasExtensions()) {
            String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);
            if (caltype != null) {
                switch (caltype) {
                case &quot;buddhist&quot;:
                cal = new BuddhistCalendar(zone, aLocale);
                    break;
                case &quot;japanese&quot;:
                    cal = new JapaneseImperialCalendar(zone, aLocale);
                    break;
                case &quot;gregory&quot;:
                    cal = new GregorianCalendar(zone, aLocale);
                    break;
                }
            }
        }
        if (cal == null) {

            if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {
                cal = new BuddhistCalendar(zone, aLocale);
            } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;
                       &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {
                cal = new JapaneseImperialCalendar(zone, aLocale);
            } else {
                cal = new GregorianCalendar(zone, aLocale);
            }
        }
        return cal;
    }</code></pre>
<h3 id="4-4-5、工厂模式小结"><a href="#4-4-5、工厂模式小结" class="headerlink" title="4.4.5、工厂模式小结"></a>4.4.5、工厂模式小结</h3><ol>
<li><p>工厂模式的意义</p>
<p>将实例化对象的代码提取出来，方到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p>
</li>
<li><p>三种工厂模式</p>
</li>
<li><p>设计模式的依赖抽象原则。</p>
<ul>
<li>创建对象实例时，不要直接new类，而是把这个new类的动作放到一个工厂的方法中，并返回。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现interface（接口）</li>
<li>不要覆盖基类中已经实现的方法。</li>
</ul>
</li>
</ol>
<h2 id="4-5、原型模式"><a href="#4-5、原型模式" class="headerlink" title="4.5、原型模式"></a>4.5、原型模式</h2><p><strong>克隆羊问题</strong></p>
<p>现在有一只羊tom，姓名为：tom，年龄为：1，颜色为：白色，请编写程序创建和tom羊属性完全相同的10只羊。</p>
<p><strong>传统方法</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210115215617906.png" alt="image-20210115215617906"></p>
<pre><code class="java">package prototype;

public class Sheep {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getColor() {
        return color;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return &quot;Sheep{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, color=&#39;&quot; + color + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
</code></pre>
<pre><code class="java">package prototype;

public class Client {
    public static void main(String[] args) {
        //传统方法解决

        Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;白色&quot;);

        Sheep sheep1 = new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor());
        Sheep sheep2 = new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor());

        System.out.println(sheep);
        System.out.println(sheep1);
        System.out.println(sheep2);

    }
}
</code></pre>
<p><strong>传统方法的优缺点</strong></p>
<ol>
<li>优点是比较好理解，简单易操作</li>
<li>在创建新对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂是，效率较低。</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活。</li>
<li>改进的思路分析。</li>
</ol>
<p><strong>思路：</strong></p>
<p>Java中Object类是所有类的根类，Object类提供了一个clone（）方法，该方法可以将一个Java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力—–&gt;原型模式</p>
<p><strong>原型模式-基本介绍</strong></p>
<ol>
<li>原型模式是指：用原型模式指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</li>
<li>原型模式是一中创建型设计模式，允许一个对象在创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是：将一个原型对象传给哪个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实施创建，即 对象.clone（）</li>
<li>形象的理解:孙大圣拔出猴毛，变出其他孙大圣。</li>
</ol>
<p><strong>原理结构图说明</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210116153258208.png" alt="image-20210116153258208"></p>
<ol>
<li>Prototype:原型类，声明一个克隆自己的接口</li>
<li>ConcretePrototype:具体的原型类，实现一个克隆自己的操作。</li>
<li>Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）</li>
</ol>
<pre><code class="java">package prototype.improve;

public class Sheep implements Cloneable {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getColor() {
        return color;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return &quot;Sheep{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, color=&#39;&quot; + color + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    //克隆该实例，使用默认的clone方法来完成
    @Override
    protected Object clone()  {


        Sheep sheep = null;

        try{
            sheep = (Sheep)super.clone();

        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        return sheep;
    }
}
</code></pre>
<pre><code class="java">package prototype.improve;

public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;原型模式完成对象的复制&quot;);
        Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;白色&quot;);

        Sheep sheep1 = (Sheep)sheep.clone();
        Sheep sheep2 = (Sheep)sheep.clone();
        Sheep sheep3 = (Sheep)sheep.clone();


        System.out.println(&quot;sheep2 = &quot; + sheep2);
        System.out.println(&quot;sheep3 = &quot; + sheep3);
    }
}</code></pre>
<h3 id="4-5-1、原型模式在Spring框架中源码分析"><a href="#4-5-1、原型模式在Spring框架中源码分析" class="headerlink" title="4.5.1、原型模式在Spring框架中源码分析"></a>4.5.1、原型模式在Spring框架中源码分析</h3><p><strong>Spring中原型bean的创建，就是原型模式的应用</strong></p>
<h3 id="4-5-2、浅拷贝和深拷贝"><a href="#4-5-2、浅拷贝和深拷贝" class="headerlink" title="4.5.2、浅拷贝和深拷贝"></a>4.5.2、浅拷贝和深拷贝</h3><p><strong>浅拷贝的介绍</strong></p>
<ol>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li>
<li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个独享的该成员变量值。</li>
<li>前面我们的克隆羊就是浅拷贝</li>
<li>浅拷贝是使用默认的clone（）方法来实现</li>
</ol>
<pre><code class="java">sheep = (Sheep)super.clone();</code></pre>
<p><strong>深拷贝的介绍</strong></p>
<ol>
<li>复制对象的所有基本数据类型的成员变量值</li>
<li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。</li>
<li>方法一深拷贝实现方式：重写clone方法来实现深拷贝</li>
<li>方法二深拷贝实现方式：通过对象序列化实现深拷贝</li>
</ol>
<pre><code class="java">//方式一
//先对基本数据类型进行处理，即对基本数据类型（属性）和String的克隆
deep = supper.clone();
//对引用数据类型的属性，进行单独的处理。
//转类型.clone();</code></pre>
<pre><code class="java">//方式二
//通过对象的序列化实现
//创建流对象
//序列化，将对象以流的方式输出
//反序列化，将对象读回来</code></pre>
<h3 id="4-5-3、原型模式的注意事项和细节"><a href="#4-5-3、原型模式的注意事项和细节" class="headerlink" title="4.5.3、原型模式的注意事项和细节"></a>4.5.3、原型模式的注意事项和细节</h3><ol>
<li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li>
<li>不用重新初始化对象，而是动态的获得对象运行时的状态。</li>
<li>如果原始对象发生变化（添加或者减少属性），其他克隆对象的也会发生相应的编号，无需修改代码。</li>
<li>在实现深克隆的时候可能会需要比较复杂的代码。</li>
<li><strong>缺点：</strong>需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。</li>
</ol>
<h2 id="4-6、建造者模式"><a href="#4-6、建造者模式" class="headerlink" title="4.6、建造者模式"></a>4.6、建造者模式</h2><p><strong>盖房项目需求</strong></p>
<ol>
<li>需要建房子：这一过程为打桩，砌墙，封顶</li>
<li>房子各有各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210116160348988.png" alt="image-20210116160348988"></p>
<p><strong>传统方法</strong></p>
<pre><code class="java">package builder;

public abstract class AbstractHouse {

    //打地基
    public abstract void builderBasic();
    //砌墙
    public abstract void builderWalls();
    //封顶
    public abstract void roofed();

    public void build(){
        builderBasic();
        builderWalls();
        roofed();
    }

}
</code></pre>
<pre><code class="java">package builder;

public class CommonHouse extends AbstractHouse{
    @Override
    public void builderBasic() {
        System.out.println(&quot;给普通房子打地基&quot;);

    }

    @Override
    public void builderWalls() {
        System.out.println(&quot;给普通房子砌墙&quot;);
    }

    @Override
    public void roofed() {
        System.out.println(&quot;给普通房子封顶&quot;);
    }
}
</code></pre>
<pre><code class="java">package builder;

public class Client {
    public static void main(String[] args) {
        CommonHouse commonHouse = new CommonHouse();
        commonHouse.build();
    }
}
</code></pre>
<p><strong>传统方法解决盖房子需求问题分析</strong></p>
<ol>
<li>优点是比较好理解，简单易操作</li>
<li>设计的程序结构，过于简单，没有设计缓存层对象，对程序的扩展和维护不好，也就是说，这种设计方案，把产品（房子）和创建商品的过程（建房子过程）封装在一起，耦合性加强了。</li>
<li>解决方案：将产品和产品建造过程解耦—&gt;建造者模式</li>
</ol>
<h3 id="4-6-1、-建造者模式基本介绍"><a href="#4-6-1、-建造者模式基本介绍" class="headerlink" title="4.6.1、 建造者模式基本介绍"></a>4.6.1、 建造者模式基本介绍</h3><ol>
<li>建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li>
<li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节。</li>
</ol>
<p><strong>建造者模式的四个角色</strong></p>
<ol>
<li>Product（产品角色）：一个具体的产品对象。</li>
<li>Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类。</li>
<li>ConcreBuilder（具体建造者）：实现接口，构建和装配各个部件。</li>
<li>Director（指挥者）：构建一个使用Builder接口的对象。它主要适用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程。二是：负责控制产品对象的生产过程。</li>
</ol>
<h3 id="4-6-2、建造者模式应用实例"><a href="#4-6-2、建造者模式应用实例" class="headerlink" title="4.6.2、建造者模式应用实例"></a>4.6.2、建造者模式应用实例</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210116170912763.png" alt="image-20210116170912763"></p>
<pre><code class="java">package builder.improve;

//产品---&gt;Product
public class House {
    private String baise;
    private String wall;
    private String roofed;

    public String getBaise() {
        return baise;
    }

    public String getWall() {
        return wall;
    }

    public String getRoofed() {
        return roofed;
    }

    public void setBaise(String baise) {
        this.baise = baise;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public void setRoofed(String roofed) {
        this.roofed = roofed;
    }
}
</code></pre>
<pre><code class="java">package builder.improve;

public class HighBuilding extends HouseBuilder{
    @Override
    public void builderBasic() {
        System.out.println(&quot;高楼的地基100米&quot;);
    }

    @Override
    public void builderWalls() {
        System.out.println(&quot;高楼的砌墙20cm&quot;);
    }

    @Override
    public void roofed() {
        System.out.println(&quot;高楼的透明屋顶&quot;);
    }
}
</code></pre>
<pre><code class="java">package builder.improve;

public class CommonHouse  extends HouseBuilder{

    @Override
    public void builderBasic() {
        System.out.println(&quot;给普通房子打地基5米&quot;);
    }

    @Override
    public void builderWalls() {
        System.out.println(&quot;普通房子砌墙10cm&quot;);
    }

    @Override
    public void roofed() {
        System.out.println(&quot;普通房子屋顶&quot;);
    }
}
</code></pre>
<pre><code class="java">package builder.improve;

//抽象的建造者
public abstract class HouseBuilder {

    protected House house = new House();


    //将建造流程写好，抽象的方法
    public abstract void builderBasic();
    public abstract void builderWalls();
    public abstract void roofed();

    //建造房子完成后，将产品（房子）返回

    public House builderHouse(){
        return house;
    }

}
</code></pre>
<pre><code class="java">package builder.improve;
//指挥者，这里去动态的指定制作流程，返回产品
public class HouseDirector {

    HouseBuilder houseBuilder = null;

    //构造器传入houseBuilder
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }


    //通过setter传入houseBuilder

    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }


    //如何处理建造房子的流程，交给指挥者
    public House constructHouse(){
        houseBuilder.builderBasic();
        houseBuilder.builderWalls();
        houseBuilder.roofed();
        return houseBuilder.builderHouse();

    }

}
</code></pre>
<pre><code class="java">package builder.improve;

public class Client {
    public static void main(String[] args) {

        //盖普通的房子
        CommonHouse commonHouse = new CommonHouse();
        //准备创建房子的指挥者
        HouseDirector houseDirector = new HouseDirector(commonHouse);

        //完成盖房子，返回产品（房子）
        House house = houseDirector.constructHouse();

        //System.out.println(&quot;输出流程&quot;);


        //盖高楼
        HighBuilding highBuilding = new HighBuilding();
        //重置建造者
        houseDirector.setHouseBuilder(highBuilding);
        //完成盖房子，返回产品（高楼）
        houseDirector.constructHouse();
    }
}
</code></pre>
<h3 id="4-6-3、建造者模式在JDK的应用和源码分析"><a href="#4-6-3、建造者模式在JDK的应用和源码分析" class="headerlink" title="4.6.3、建造者模式在JDK的应用和源码分析"></a>4.6.3、建造者模式在JDK的应用和源码分析</h3><p><strong>java.lang.StringBuilder中的建造者模式</strong></p>
<p><strong>角色分析</strong></p>
<ul>
<li>Appendable接口中定义了多个append方法（抽象方法），即Appendable为抽象建造者，定义了抽象方法。</li>
<li>AbstractStringBuilder 实现了Appendable接口的方法，这里的AbstractStringBuilder已经是建造者，只是不能实例化。</li>
<li>StringBuilder 即充当了指挥者角色，同时又充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成。而StringBuilder继承了AbstractStringBuilder</li>
</ul>
<h3 id="4-6-4、建造者模式的注意事项和细节"><a href="#4-6-4、建造者模式的注意事项和细节" class="headerlink" title="4.6.4、建造者模式的注意事项和细节"></a>4.6.4、建造者模式的注意事项和细节</h3><ol>
<li><p>客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得不同的创建过程可以创建不同的产品对象。</p>
</li>
<li><p>每一个具体创建者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或者增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</p>
</li>
<li><p>可以更加精细的控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
</li>
<li><p>增加新的具体创造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则。</p>
</li>
<li><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性比较大，则不适合使用建造者模式，因此其使用范围收到一定的限制。</p>
</li>
<li><p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统吧变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。</p>
</li>
<li><p><strong>抽象工厂类和建造者模式</strong></p>
<p>抽象工厂类模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
</li>
</ol>
<h2 id="4-7、适配器模式"><a href="#4-7、适配器模式" class="headerlink" title="4.7、适配器模式"></a>4.7、适配器模式</h2><h3 id="4-7-1、适配器基本介绍"><a href="#4-7-1、适配器基本介绍" class="headerlink" title="4.7.1、适配器基本介绍"></a>4.7.1、适配器基本介绍</h3><ol>
<li>适配器模式（Adapter  Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不能匹配不能工作的两个类可以协同工作，其别名叫包装器（Wrapper）</li>
<li>适配器模式属于结构型模式</li>
<li>主要分为三类：类适配器模式，对象适配器模式，接口适配器模式</li>
</ol>
<h3 id="4-7-2、适配器模式工作原理"><a href="#4-7-2、适配器模式工作原理" class="headerlink" title="4.7.2、适配器模式工作原理"></a>4.7.2、适配器模式工作原理</h3><ol>
<li>适配器模式：将一个类的接口转换成另一个接口，让原本接口不兼容的类可以兼容</li>
<li>从用户的角度看不到被适配者，是解耦的</li>
<li>用户调用适配器转换出来的目标接口方法，适配器再调用被适配者的相关接口方法。</li>
<li>用户收到反馈结果，感觉只是和目标接口交互，如图</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210119155046603.png" alt="image-20210119155046603"></p>
<h3 id="4-7-3、类适配器模式"><a href="#4-7-3、类适配器模式" class="headerlink" title="4.7.3、类适配器模式"></a>4.7.3、类适配器模式</h3><p><strong>类适配器模式介绍</strong></p>
<p>基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配</p>
<p><strong>类适配器应用实例</strong></p>
<ol>
<li><p>应用实例说明</p>
<p>以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于src（即被适配者），我们的目的dst（即 目标）是5V直流电</p>
</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210119163516119.png" alt="image-20210119163516119"></p>
<pre><code class="java">package adapter.classadapter;
//被适配类
public class Voltage220V {
    //输出220V电压
    public int output220V(){
        int src = 220;
        System.out.println(&quot;电压=&quot; + src + &quot;伏&quot;);
        return src;
    }
}
</code></pre>
<pre><code class="java">package adapter.classadapter;

//适配接口
public interface IVoltage5V {
    public int output5V();
}
</code></pre>
<pre><code class="java">package adapter.classadapter;

//适配器类继承被适配的类
public class VoltageAdapter extends Voltage220V implements IVoltage5V{
    @Override
    public int output5V() {

        //获取到220V的电压
        int srcV = output220V();
        int dstV = srcV / 44;   //转成5V
        return dstV;
    }
}</code></pre>
<pre><code class="java">package adapter.classadapter;

public class Phone {
    //充电
    public void charging(IVoltage5V iVoltage5V){

        if (iVoltage5V.output5V()==5){
            System.out.println(&quot;电压5V，可以充电~~&quot;);
        }else if (iVoltage5V.output5V()&gt;5){
            System.out.println(&quot;电压大于5V，不能充电&quot;);
        }

    }
}
</code></pre>
<pre><code class="java">package adapter.classadapter;

public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;======类适配器模式=======&quot;);

        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());

    }
}
</code></pre>
<p><strong>类适配器模式注意事项和细节</strong></p>
<ol>
<li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定的局限性</li>
<li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li>
<li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li>
</ol>
<h3 id="4-7-4、对象适配器模式"><a href="#4-7-4、对象适配器模式" class="headerlink" title="4.7.4、对象适配器模式"></a>4.7.4、对象适配器模式</h3><p><strong>对象适配器模式介绍</strong></p>
<ol>
<li>基本思路和类的适配器模式相同，只是将Adapter类作修改，而不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src–&gt;dst的适配。</li>
<li>根据“合成复用原则”，在系统中尽量使用关联来替代继承关系，因此大部分结构模型都是对象结构型模式。</li>
<li><strong>对象适配器模式是适配器模式常用的一种</strong></li>
</ol>
<p><strong>对象适配器模式应用实例</strong></p>
<ol>
<li>以生活中充电器的例子来讲解适配器，充电桩本身相当于Adapter，220V交流电相当于src（即被适配者），我们的目的dst（即目标）是5V直流电，使用<strong>对象适配器模式完成</strong></li>
<li>思路分析：只需要修改适配器即可，如下</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210119190653652.png" alt="image-20210119190653652"></p>
<pre><code class="java">package adapter.objectadapter;

//适配器类继承被适配的类
public class VoltageAdapter implements IVoltage5V {

    private Voltage220V voltage220V;



    //通过构造器，传入一个Voltage220V  实例
    public VoltageAdapter(Voltage220V voltage220V) {

        this.voltage220V = voltage220V;
    }




    @Override
    public int output5V() {
        int dst = 0;
        if (null != voltage220V){
            int src = voltage220V.output220V();//获取220V 电压
            System.out.println(&quot;使用对象适配器，进行适配~~&quot;);

            dst = src / 44;
            System.out.println(&quot;适配完成，输出的电压=&quot;+ dst);
        }
        return dst;
    }
}

</code></pre>
<pre><code class="java">package adapter.objectadapter;

public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;======对象适配器模式=======&quot;);

        Phone phone = new Phone();
        phone.charging(new VoltageAdapter(new Voltage220V()));

    }
}
</code></pre>
<p><strong>对象适配器模式注意事项和细节</strong></p>
<ol>
<li><p>对象适配器和类适配器其实算是同一种思想，只不过是实现方式不同。</p>
<p>根据合成复用原则，使用组合来替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。</p>
</li>
<li><p>使用成本更低，更灵活。</p>
</li>
</ol>
<h3 id="4-7-5、接口适配器模式"><a href="#4-7-5、接口适配器模式" class="headerlink" title="4.7.5、接口适配器模式"></a>4.7.5、接口适配器模式</h3><p><strong>接口适配器模式介绍</strong></p>
<ol>
<li>一些书籍称为：适配器模式或缺省适配器模式。</li>
<li>当不需要全部实现接口提供的方法时，可以先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择的覆盖父类的某些方法来实现需求。</li>
<li>适用于一个接口不想使用其所有方法的情况。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210120170102033.png" alt="image-20210120170102033"></p>
<pre><code class="java">package adapter.interfaceadapter;

public interface Interface4 {
    public void m1();
    public void m2();
    public void m3();
    public void m4();

}
</code></pre>
<pre><code class="JAVA">package adapter.interfaceadapter;
//在Absadapter 我们将Interface4的方法进行默认实现
public abstract class Absadapter implements Interface4{

    //默认实现
    @Override
    public void m1() {

    }

    @Override
    public void m2() {

    }

    @Override
    public void m3() {

    }

    @Override
    public void m4() {

    }
}
</code></pre>
<pre><code class="JAVA">package adapter.interfaceadapter;

public class Client {
    public static void main(String[] args) {
        Absadapter absadapter = new Absadapter(){
           //只需要去覆盖我们需要使用的接口方法

            @Override
            public void m1() {
                System.out.println(&quot;使用了m1的方法&quot;);
            }
        };
        absadapter.m1();
    }
}
</code></pre>
<h3 id="4-7-6、适配器模式在SpringMVC框架应用的源码分析"><a href="#4-7-6、适配器模式在SpringMVC框架应用的源码分析" class="headerlink" title="4.7.6、适配器模式在SpringMVC框架应用的源码分析"></a>4.7.6、适配器模式在SpringMVC框架应用的源码分析</h3><ol>
<li>SpringMVC中的HandlerAdapter，就是用了适配器模式</li>
<li>SpringMVC处理请求的流程回顾</li>
<li>使用HanderAdapter的原因分析</li>
</ol>
<p>可以看到处理器的类型不同，有多种实现方式，那么调用方式就不是确定的，如果需要就直接调用Controller方法，需要调用的时候就得不断使用if  else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。</p>
<ol start="4">
<li>动手写SpringMVC通过适配器设计模式获取到对应的Controller的源码。</li>
</ol>
<p><strong>说明</strong></p>
<ul>
<li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类。</li>
<li>适配器代替了controller执行相应的方法。</li>
<li>扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</li>
</ul>
<h3 id="4-7-7、适配器模式的注意事项和细节"><a href="#4-7-7、适配器模式的注意事项和细节" class="headerlink" title="4.7.7、适配器模式的注意事项和细节"></a>4.7.7、适配器模式的注意事项和细节</h3><ol>
<li><p>三种命名方式，是根据src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</p>
</li>
<li><p>类适配器：以类给到，在Adapter里，就是将src当做类，继承。</p>
<p>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有。</p>
<p>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现。</p>
</li>
<li><p>Adapter模式最大的作用还是将原本不兼容的接口融合到一起工作。</p>
</li>
<li><p>实际开发中，实现起来不拘泥于我们讲解的三种经典方式。</p>
</li>
</ol>
<h2 id="4-8、桥接模式"><a href="#4-8、桥接模式" class="headerlink" title="4.8、桥接模式"></a>4.8、桥接模式</h2><p><strong>手机操作问题</strong></p>
<p>现在对不同手机类型的不同手机品牌实现操作编程（比如：开机，关机，上网，打电话等）</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210120181500740.png" alt="image-20210120181500740"></p>
<p><strong>传统方案解决手机操作问题分析</strong></p>
<ol>
<li>扩展性问题（类爆炸），如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li>
<li>违反单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护版本。</li>
<li>解决方案–使用桥接模式。</li>
</ol>
<h3 id="4-8-1、桥接模式的基本介绍"><a href="#4-8-1、桥接模式的基本介绍" class="headerlink" title="4.8.1、桥接模式的基本介绍"></a>4.8.1、桥接模式的基本介绍</h3><ol>
<li>桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类的层次中，使两个层次可以独立改变。</li>
<li>是一种结构型设计模式。</li>
<li>Bridge模式基于类的最小设计原则，通过使用封装，聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及对他们的功能扩展。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210120191608744.png" alt="image-20210120191608744"></p>
<h3 id="4-8-2、桥接模式实现案例"><a href="#4-8-2、桥接模式实现案例" class="headerlink" title="4.8.2、桥接模式实现案例"></a>4.8.2、桥接模式实现案例</h3><pre><code class="java">package bridge;
//接口
public interface Brand {
    void open();
    void close();
    void call();
}
</code></pre>
<pre><code class="java">package bridge;

public class XiaoMi implements Brand{
    @Override
    public void open() {
        System.out.println(&quot;小米手机开机了&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;小米手机关机了&quot;);
    }

    @Override
    public void call() {
        System.out.println(&quot;小米手机打电话&quot;);
    }
}
</code></pre>
<pre><code class="java">package bridge;

public class Vivo implements Brand{
    @Override
    public void open() {
        System.out.println(&quot;Vivo手机开机了&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;Vivo手机关机了&quot;);
    }

    @Override
    public void call() {
        System.out.println(&quot;Vivo手机打电话&quot;);
    }
}
</code></pre>
<pre><code class="java">package bridge;

public abstract class Phone {
    //组合品牌
    private Brand brand;
    //构造器
    public Phone(Brand brand) {
        this.brand = brand;
    }

    protected  void open(){
        this.brand.open();
    }
    protected void close(){
        this.brand.close();
    }
    protected void call(){
        this.brand.call();
    }

}
</code></pre>
<pre><code class="java">package bridge;
//折叠式手机类，继承抽象类Phone
public class FoldedPhone extends Phone{

    //构造器
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        super.open();
        System.out.println(&quot;折叠样式手机&quot;);
    }

    @Override
    protected void close() {
        super.close();
        System.out.println(&quot;折叠样式手机&quot;);
    }

    @Override
    protected void call() {
        super.call();
        System.out.println(&quot;折叠样式手机&quot;);
    }
}
</code></pre>
<pre><code class="java">package bridge;

public class Client {
    public static void main(String[] args) {
        //获取折叠式手机（样式 + 品牌）

        Phone phone1 = new FoldedPhone(new XiaoMi());

        phone1.call();
        phone1.open();
        phone1.close();

        System.out.println(&quot;================================&quot;);


        Phone phone2 = new FoldedPhone(new Vivo());

        phone2.call();
        phone2.open();
        phone2.close();
    }
}
</code></pre>
<p><strong>功能扩展，需要添加一个新的样式时</strong></p>
<pre><code class="java">package bridge;

public class UpRightPhone extends Phone{


    public UpRightPhone(Brand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        super.open();
        System.out.println(&quot;直立样式手机&quot;);
    }

    @Override
    protected void close() {
        super.close();
        System.out.println(&quot;直立样式手机&quot;);
    }

    @Override
    protected void call() {
        super.call();
        System.out.println(&quot;直立样式手机&quot;);
    }
}
</code></pre>
<h3 id="4-8-3、桥接模式在JDBC的源码剖析"><a href="#4-8-3、桥接模式在JDBC的源码剖析" class="headerlink" title="4.8.3、桥接模式在JDBC的源码剖析"></a>4.8.3、桥接模式在JDBC的源码剖析</h3><ol>
<li>jdbc的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当做实现类接口。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210121150137151.png" alt="image-20210121150137151"></p>
<h3 id="4-8-4、桥接模式的注意事项和细节"><a href="#4-8-4、桥接模式的注意事项和细节" class="headerlink" title="4.8.4、桥接模式的注意事项和细节"></a>4.8.4、桥接模式的注意事项和细节</h3><ol>
<li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实体部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li>
<li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由具体业务来完成。</li>
<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li>
<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者对抽象进行设计和编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的而维度，因此其使用范围有一定的的局限性，即需要有这样的应用场景。</li>
</ol>
<p><strong>桥接模式其他应用场景</strong></p>
<ol>
<li>对于那些不希望使用继承或因为多层次集成导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
<li>常见的应用场景<ul>
<li>JDBC驱动程序</li>
<li>银行转账系统<ul>
<li>转账分类：网上转账，柜台转账，ATM转账</li>
<li>转账用户类型：普通用户，银卡用户，金卡用户</li>
</ul>
</li>
<li>消息管理<ul>
<li>消息类型：即时消息，延时消息</li>
<li>消息分类：手机短信，邮件信息，QQ消息</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="4-9、装饰者模式"><a href="#4-9、装饰者模式" class="headerlink" title="4.9、装饰者模式"></a>4.9、装饰者模式</h2><p><strong>项目需求：星巴克咖啡订单项目（咖啡馆）</strong></p>
<ol>
<li>咖啡种类/单品咖啡：Espresso（意大利浓咖啡），ShortBlack，LongBlack（美式咖啡），Decaf（无因咖啡）</li>
<li>调料：Milk，Soy（豆浆），Chocolate</li>
<li>要求在扩展新的咖啡种类时，具有良好的扩展性，改动方便，维护方便</li>
<li>使用OO的来计算不同种类咖啡的费用：客户可以点单品咖啡，也可以点单品咖啡+调料组合。</li>
</ol>
<p><strong>方案一：较差的方案</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210121155242620.png" alt="image-20210121155242620"></p>
<p><strong>方案一：解决星巴克咖啡订单问题分析</strong></p>
<ol>
<li>Drink是一个抽象类，表示饮料。</li>
<li>des是对咖啡的描述，比如咖啡的名字。</li>
<li>cost（）方法就是计算费用，Drink类中做成一个抽象方法。</li>
<li>Decaf就是单品咖啡，继承Drink，实现cost。</li>
<li>Espress&amp;&amp;Milk   就是单品咖啡+调料，这种和组合很多。</li>
<li>问题：这样设计，会有很多的类，当我们增加一个单品咖啡，或者一个新的调料，类的数量会剧增，造成类爆炸。</li>
</ol>
<p><strong>方案二：较好的方案</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122130929692.png" alt="image-20210122130929692"></p>
<p><strong>方案二问题分析</strong></p>
<ol>
<li>方案2可以控制类的数量，不至于造成类爆炸问题。</li>
<li>在增加或者删除调料种类时，代码的维护量还是很大。</li>
<li>考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应的int</li>
<li>考虑可以使用装饰者模式</li>
</ol>
<h3 id="4-9-1、装饰者模式的定义"><a href="#4-9-1、装饰者模式的定义" class="headerlink" title="4.9.1、装饰者模式的定义"></a>4.9.1、装饰者模式的定义</h3><ol>
<li>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（ocp）</li>
<li>这里提到的动态地将新功能附加到对象和ocp原则，在后面的应用实例上会以代码的形式体现，请同学们注意体会。</li>
</ol>
<h3 id="4-9-2、装饰者模式原理"><a href="#4-9-2、装饰者模式原理" class="headerlink" title="4.9.2、装饰者模式原理"></a>4.9.2、装饰者模式原理</h3><ol>
<li>装饰者模式就像打包一个快递。</li>
</ol>
<ul>
<li>主体：比如，陶瓷，衣服（Component）</li>
<li>包装：比如，报纸填充，塑料泡沫，纸板，木板（Decorator）</li>
</ul>
<ol start="2">
<li><p>Component</p>
<p>主体：比如类似前面的Drink</p>
</li>
<li><p>ConcreteComponent和DecoratorConcreteComponent：具体的主体，比如前面的各个单品咖啡。</p>
<p>Decorator：装饰者，比如各种调料。</p>
</li>
<li><p>在如图Component与ConcreteComponent之间，如果ConcreteComponent类很多，还可以设计一个缓冲层，将共有的部分提取出来，抽象层是一个类。</p>
</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122133858614.png" alt="image-20210122133858614"></p>
<p><strong>用装饰者模式设计的方案</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122134420759.png" alt="image-20210122134420759"></p>
<p><strong>装饰者模式下的订单：两份巧克力 + 一份牛奶的LongBlack</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122134714083.png" alt="image-20210122134714083"></p>
<p><strong>说明：</strong></p>
<ol>
<li>Milk包含了LongBlack</li>
<li>一份Chocolate包含了（Milk + LongBlack）</li>
<li>一份Chocolate包含了（Chocolate + Milk + LongBlack）</li>
<li>这样不管是什么形式的单品咖啡 + 调料组合，通过递归方式可以方便的组合和维护。</li>
</ol>
<pre><code class="java">package decorator;

public abstract class Drink {
    public String des;
    private float price = 0.0f;

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    //计算费用的抽象方法
    //子类来实现
    public abstract float cost();
}
</code></pre>
<pre><code class="java">package decorator;

public class Coffee extends Drink{
    @Override
    public float cost() {
        return super.getPrice();
    }
}
</code></pre>
<pre><code class="java">package decorator;

public class LongBlack extends Coffee{
    public LongBlack() {
        setDes(&quot;LongBlack&quot;);
        setPrice(5.0f);
    }
}


package decorator;

public class Espresso extends Coffee{
    public Espresso() {
        setDes(&quot;意大利咖啡&quot;);
        setPrice(6.0f);
    }
}



package decorator;

public class ShortBlack extends Coffee{
    public ShortBlack() {
        setDes(&quot;ShortBlack&quot;);
        setPrice(4.0f);
    }
}
</code></pre>
<pre><code class="java">package decorator;

public class Decorator extends Drink{

    private Drink obj;

    public Decorator(Drink obj) {//组合

        this.obj = obj;
    }

    @Override
    public String getDes() {
        //obj.getDes() 输出被装饰者的信息
        return super.des + &quot;&quot; + super.getPrice() + &quot;&amp;&amp;&quot; + obj.getDes();
    }

    @Override
    public float cost() {
        //getPrice 自己价格
        return super.getPrice() + obj.cost();
    }
}
</code></pre>
<pre><code class="java">package decorator;

public class Milk extends Decorator{
    public Milk(Drink obj) {
        super(obj);
        setDes(&quot;牛奶&quot;);
        setPrice(2.0f);
    }
}


package decorator;

public class Soy extends Decorator{
    public Soy(Drink obj) {
        super(obj);
        setDes(&quot;豆浆&quot;);
        setPrice(1.5f);
    }
}


package decorator;

public class Chorolate extends Decorator{
    public Chorolate(Drink obj) {
        super(obj);
        setDes(&quot;巧克力&quot;);
        setPrice(3.0f);//调味品的价格
    }
}


</code></pre>
<pre><code class="java">package decorator;

public class CoffeeBar {
    public static void main(String[] args) {

        //装饰者模式下的订单：2份巧克力 + 1份牛奶的LongBlack

        //1. 点1份LongBlack
        Drink order = new LongBlack();
        System.out.println(&quot;费用1=&quot; + order.cost());
        System.out.println(&quot;描述：&quot; + order.getDes());

        //2.order加1份牛奶
        order = new Milk(order);

        System.out.println(&quot;order 加入1份牛奶费用= &quot; + order.cost());
        System.out.println(&quot;order 加入1份牛奶描述: &quot; + order.getDes());

        //order 加入1份巧克力
        order = new Chorolate(order);
        System.out.println(&quot;order 加入1份牛奶 加入1份巧克力 费用 = &quot; + order.cost());
        System.out.println(&quot;order 加入1份牛奶 加入1份巧克力 描述 &quot; + order.getDes());


        //再加1份巧克力
        order = new Chorolate(order);
        System.out.println(&quot;order 加入1份牛奶 加入2份巧克力 费用 = &quot; + order.cost());
        System.out.println(&quot;order 加入1份牛奶 加入2份巧克力 描述 &quot; + order.getDes());


    }
}
</code></pre>
<h3 id="4-9-3、装饰者模式在JDK应用中的源码分析"><a href="#4-9-3、装饰者模式在JDK应用中的源码分析" class="headerlink" title="4.9.3、装饰者模式在JDK应用中的源码分析"></a>4.9.3、装饰者模式在JDK应用中的源码分析</h3><ol>
<li>Java的IO结构，FilterInputStream就是一个装饰者</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122161917360.png" alt="image-20210122161917360"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122162839804.png" alt="image-20210122162839804"></p>
<h2 id="4-10、组合模式"><a href="#4-10、组合模式" class="headerlink" title="4.10、组合模式"></a>4.10、组合模式</h2><p><strong>学校院系展示需求</strong></p>
<p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122163320051.png" alt="image-20210122163320051"></p>
<p> 传统方案直接继承</p>
<p><strong>传统方案解决学校院系展示存在的问题分析</strong></p>
<ol>
<li>将学院看作是学校的子类，系使学员的子类，这样实际上是站在组织大小来进行分层次的</li>
<li>实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好地实现管理的操作，比如对学院，系的添加，删除，遍历等。</li>
<li>解决方案：把学校，院，系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作–&gt;组合模式</li>
</ol>
<h3 id="4-10-1、组合模式的基本介绍"><a href="#4-10-1、组合模式的基本介绍" class="headerlink" title="4.10.1、组合模式的基本介绍"></a>4.10.1、组合模式的基本介绍</h3><p><strong>基本介绍</strong></p>
<ol>
<li>组合模式（Composite  Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示”整体–部分”的层次关系</li>
<li>组合模式依据树形结构来组合对象，用来表示部分及整体层次。</li>
<li>这种类型的设计模是属于结构型模式</li>
<li>组合模式使用的用户对单个对象和组合对象的访问具有一致性，即：组合能让客户一致的方式处理个别对象以及组合对象。</li>
</ol>
<p><strong>组合模式解决的问题</strong></p>
<ol>
<li>组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123095431829.png" alt="image-20210123095431829"></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123110116950.png" alt="image-20210123110116950"></p>
<h3 id="4-10-2、组合模式解决学校院系展示问题"><a href="#4-10-2、组合模式解决学校院系展示问题" class="headerlink" title="4.10.2、组合模式解决学校院系展示问题"></a>4.10.2、组合模式解决学校院系展示问题</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210122232754887.png" alt="image-20210122232754887"></p>
<pre><code class="java">package composite;

public abstract class OrganizationComponent {
    private String name;//名字
    private String des;//说明

    protected void add(OrganizationComponent organizationComponent){
        //默认实现
        throw new UnsupportedOperationException();
    }
    protected void remove(OrganizationComponent organizationComponent){
        //默认实现
        throw new UnsupportedOperationException();
    }

    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    //方法print，做成抽象的,子类都需要实现
    protected abstract void print();
}
</code></pre>
<pre><code class="java">package composite;

import java.util.ArrayList;
import java.util.List;

//University 就是Composite，可以管理College
public class University extends OrganizationComponent{

    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();

    //构造器
    public University(String name, String des) {
        super(name, des);

    }
    //重写add

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }
    //重写remove


    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }
    //重写getName


    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
    //print方法，就是输出University包含的学院
    @Override
    protected void print() {
        System.out.println(&quot;---------&quot; + getName()+&quot;---------&quot;);
        //遍历organizationComponents
        for (OrganizationComponent organizationComponent:organizationComponents
             ) {organizationComponent.print();

        }
    }
}
</code></pre>
<pre><code class="java">package composite;

import java.util.ArrayList;
import java.util.List;

public class College extends OrganizationComponent{
    //List中存放的是Department
    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();

    //构造器

    public College(String name, String des) {
        super(name, des);
    }


    //重写add

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        //将来的实际业务中，Colleage的add方法和University的add不一定相同
        organizationComponents.add(organizationComponent);
    }
    //重写remove


    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }
    //重写getName


    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
    //print方法，就是输出University包含的学院
    @Override
    protected void print() {
        System.out.println(&quot;---------&quot; + getName()+&quot;---------&quot;);
        //遍历organizationComponents
        for (OrganizationComponent organizationComponent:organizationComponents
        ) {organizationComponent.print();

        }
    }
}
</code></pre>
<pre><code class="java">package composite;

public class Department extends OrganizationComponent{
    public Department(String name, String des) {
        super(name, des);
    }
    //add和remove就不用重写了

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    @Override
    protected void print() {
        System.out.println(getName());
    }
}
</code></pre>
<pre><code class="java">package composite;

public class Client {
    public static void main(String[] args) {

        //从大到小创建对象
         OrganizationComponent university= new University(&quot;清华大学&quot;,&quot;中国顶级大学&quot;);

         //创建学院
        OrganizationComponent computerCollege = new College(&quot;计算机学院&quot;,&quot;计算机学院&quot;);
        OrganizationComponent infoEngineerCollege = new College(&quot;信息工程学院&quot;,&quot;信息工程学院&quot;);

        //创建各个学院下的系（专业）
        computerCollege.add(new Department(&quot;软件工程&quot;,&quot;软件工程不错&quot;));
        computerCollege.add(new Department(&quot;网络工程&quot;,&quot;网络工程不错&quot;));
        computerCollege.add(new Department(&quot;计算机科学与技术&quot;,&quot;计算机科学与技术不错&quot;));

        //
        infoEngineerCollege.add(new Department(&quot;通信工程&quot;,&quot;通信工程不好学&quot;));
        infoEngineerCollege.add(new Department(&quot;信息工程&quot;,&quot;信息工程好学&quot;));

        //将学院加入到学校
        university.add(computerCollege);
        university.add(infoEngineerCollege);

        university.print();
    }
}
</code></pre>
<h3 id="4-10-3、组合模式在JDK集合的源码分析"><a href="#4-10-3、组合模式在JDK集合的源码分析" class="headerlink" title="4.10.3、组合模式在JDK集合的源码分析"></a>4.10.3、组合模式在JDK集合的源码分析</h3><ol>
<li>Java的集合类 HashMap就使用了组合模式</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123102850710.png" alt="image-20210123102850710"></p>
<ul>
<li>Map就是一个抽象的构建（类似我们的Component）</li>
<li>HashMap是一个中间的构建（Composite），实现了相关的方法（put，putall）</li>
<li>Node是HashMap的静态内部类，类似Leaf叶子节点，没有put，putall方法。</li>
</ul>
<h3 id="4-10-4、组合模式的注意事项和字节"><a href="#4-10-4、组合模式的注意事项和字节" class="headerlink" title="4.10.4、组合模式的注意事项和字节"></a>4.10.4、组合模式的注意事项和字节</h3><ol>
<li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li>
<li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动</li>
<li>方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。</li>
<li>需要遍历组织结构，或者处理的对象具有树形结构时，非常适合使用组合模式。</li>
<li>要求较高的抽象性，<strong>如果叶子节点和叶子有很多差异时，比如很多方法和属性都不一样</strong>，不适合使用组合模式。</li>
</ol>
<h2 id="4-11、外观模式"><a href="#4-11、外观模式" class="headerlink" title="4.11、外观模式"></a>4.11、外观模式</h2><p><strong>影院管理项目</strong></p>
<p>组建一个家庭影院：</p>
<p>DVD播放器，投影仪，自动屏幕，环绕立体声，爆米花机，要求完成使用家庭影院的功能，其过程为：</p>
<ul>
<li>直接用遥控器：统筹各类开关</li>
<li>开爆米花机</li>
<li>放下屏幕</li>
<li>开投影仪</li>
<li>开音响</li>
<li>开DVD，选dvd</li>
<li>去拿爆米花</li>
<li>调暗灯光</li>
<li>播放</li>
<li>观影结束后，关闭各种设备</li>
</ul>
<p><strong>传统方式解决影院管理</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123111041464.png" alt="image-20210123111041464"><strong>传统方式解决影院管理问题分析</strong></p>
<ol>
<li>在ClientTest的main方法中，创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程。</li>
<li>不利于在ClientTest中，去维护对子系统的操作。</li>
<li>解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供四个方法ready，play，pause，end），用来访问子系统中的一群接口。</li>
<li>也就是说就是通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节–&gt;外观模式</li>
</ol>
<h3 id="4-11-1、外观模式基本介绍"><a href="#4-11-1、外观模式基本介绍" class="headerlink" title="4.11.1、外观模式基本介绍"></a>4.11.1、外观模式基本介绍</h3><ol>
<li>外观模式（Facade），也叫“过程模式”：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得一子系统更加容易使用。</li>
<li>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关系这个子系统的内部细节。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123112859703.png" alt="image-20210123112859703"></p>
<p><strong>原理类图说明</strong></p>
<ol>
<li>外观类（Facade）：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象。</li>
<li>调用者（Client）：外观接口的调用者</li>
<li>子系统的集合：指模块或者子系统，处理Facade对象指派的任务，他是功能的提供者</li>
</ol>
<h3 id="4-11-2、外观模式解决影院管理"><a href="#4-11-2、外观模式解决影院管理" class="headerlink" title="4.11.2、外观模式解决影院管理"></a>4.11.2、外观模式解决影院管理</h3><ol>
<li>外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口，而不用调用多个接口才可以达到目的。比如：在PC端安装软件的时候经常有一键安装选项（省去选择安装目录，安装的组件等等）还有就是手机的重启功能（把开机和关机合为一个操作）</li>
<li>外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。</li>
</ol>
<pre><code class="java">package Facade;

public class DVDPlayer {
    //使用单例模式（饿汉式）

    private static DVDPlayer instance = new DVDPlayer();

    public static DVDPlayer getInstance(){
        return instance;
    }


    public void on(){
        System.out.println(&quot;dvd on&quot;);
    }

    public void off(){
        System.out.println(&quot;dvd off&quot;);
    }

    public void play(){
        System.out.println(&quot;dvd is playing&quot;);
    }


    //......


    public void pause(){
        System.out.println(&quot;dvd is pause&quot;);
    }
}
</code></pre>
<pre><code class="java">package Facade;

public class Popcorn {
    private static Popcorn instance = new Popcorn();

    public static Popcorn getInstance(){
        return instance;
    }

    public void on(){
        System.out.println(&quot;popcorn on&quot;);
    }

    public void off(){
        System.out.println(&quot;popcorn off&quot;);
    }

    public void pop(){
        System.out.println(&quot;popcorn is poping&quot;);
    }

}
</code></pre>
<pre><code class="java">package Facade;

public class Projector {
    private static Projector instance = new Projector();

    public static Projector getInstance(){
        return instance;
    }

    public void on(){
        System.out.println(&quot;projector on&quot;);
    }

    public void off(){
        System.out.println(&quot;projector off&quot;);
    }

    public void focus(){
        System.out.println(&quot;projector is focus&quot;);
    }


    //....
}
</code></pre>
<pre><code class="java">package Facade;

public class Screen {
    private static Screen instance = new Screen();

    public static Screen getInstance(){
        return instance;
    }

    public void up(){
        System.out.println(&quot;screen up&quot;);
    }

    public void down(){
        System.out.println(&quot;screen down&quot;);
    }

}
</code></pre>
<pre><code class="java">package Facade;

public class Stereo {
    private static Stereo instance = new Stereo();

    public static Stereo getInstance() {
        return instance;
    }

    public void on(){
        System.out.println(&quot;stereo on&quot;);
    }

    public void off(){
        System.out.println(&quot;stereo off&quot;);
    }
    //立体声调大
    public void up(){
        System.out.println(&quot;stereo up&quot;);
    }

    //......
}
</code></pre>
<pre><code class="java">package Facade;

public class TheaterLight {
    private static TheaterLight instance = new TheaterLight();

    public static TheaterLight getInstance() {
        return instance;
    }

    public void on(){
        System.out.println(&quot;theaterlight on&quot;);
    }

    public void off(){
        System.out.println(&quot;theaterlight off&quot;);
    }

    public void dim(){
        System.out.println(&quot;theaterlight dim&quot;);
    }

    public void bright(){
        System.out.println(&quot;theaterlight bright&quot;);
    }
}
</code></pre>
<pre><code class="java">package Facade;

public class HomeTheaterFacade {

    //定义各个子系统对象
    private TheaterLight theaterLight;
    private Popcorn popcorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;
    private DVDPlayer dvdPlayer;

    public HomeTheaterFacade() {
        this.theaterLight = TheaterLight.getInstance();
        this.popcorn = Popcorn.getInstance();
        this.stereo = Stereo.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
        this.dvdPlayer = DVDPlayer.getInstance();
    }


    //操作分成4步

    public void ready(){
        popcorn.on();
        popcorn.pop();
        screen.down();
        projector.on();
        stereo.on();
        dvdPlayer.on();
        theaterLight.dim();
    }

    public void play(){
        dvdPlayer.play();
    }

    public void pause(){
        dvdPlayer.pause();
    }

    public void end(){
        popcorn.off();
        theaterLight.bright();
        screen.up();
        projector.off();
        stereo.off();
        dvdPlayer.off();
    }
}
</code></pre>
<pre><code class="java">package Facade;

public class Client {
    public static void main(String[] args) {
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();

        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.pause();
        homeTheaterFacade.end();
    }
}
</code></pre>
<h3 id="4-11-3、外观模式在MyBatis框架应用的源码分析"><a href="#4-11-3、外观模式在MyBatis框架应用的源码分析" class="headerlink" title="4.11.3、外观模式在MyBatis框架应用的源码分析"></a>4.11.3、外观模式在MyBatis框架应用的源码分析</h3><ol>
<li>MyBatis中的Configguration去创建MetaObject对象使用到外观模式</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123142153566.png" alt="image-20210123142153566"></p>
<h3 id="4-11-4、外观模式的注意事项和细节"><a href="#4-11-4、外观模式的注意事项和细节" class="headerlink" title="4.11.4、外观模式的注意事项和细节"></a>4.11.4、外观模式的注意事项和细节</h3><ol>
<li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂度。</li>
<li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更容易维护和扩展。</li>
<li>通过合理的使用外观模式，可以帮我们更好地规划访问的层次</li>
<li>当系统需要进行分层设计时，可以考虑使用（外观模式）Facade模式</li>
<li>在维护一个一流的大型系统时可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统与Facade类交互，提高复用性。</li>
<li>不能过多的或者不合理的使用外观模式，适应外观模式好，还是直接调用模块好。要以让系统有层次，有利于维护为目的。</li>
</ol>
<h2 id="4-12、享元模式"><a href="#4-12、享元模式" class="headerlink" title="4.12、享元模式"></a>4.12、享元模式</h2><p><strong>展示网站项目需求</strong></p>
<p>小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果是不错的，也希望做这样的产品展会网站，但是要求都有些不同。</p>
<ol>
<li>有客户要求以新闻的形式发布</li>
<li>有客户要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ol>
<h3 id="4-12-1、传统方案解决网站展现问题"><a href="#4-12-1、传统方案解决网站展现问题" class="headerlink" title="4.12.1、传统方案解决网站展现问题"></a>4.12.1、传统方案解决网站展现问题</h3><ol>
<li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li>
<li>给每个网站租用一个空间</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123144554642.png" alt="image-20210123144554642"></p>
<p><strong>传统方案解决网站展现项目分析</strong></p>
<ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同的网站的实例对象很多，造成服务器的资源浪费。</li>
<li>解决思路：<strong>整合到一个网站中，共享其相关的代码和数据，对于硬盘，内存，cpu，数据库空间等服务器资源都可以达到共享，减少服务器资源</strong>。</li>
<li>对于代码来说，由于是一份实例，维护和扩展都很容易。</li>
<li>上面说的解决思路就可以使用享元模式来解决。</li>
</ol>
<h3 id="4-12-2、享元模式的基本介绍"><a href="#4-12-2、享元模式的基本介绍" class="headerlink" title="4.12.2、享元模式的基本介绍"></a>4.12.2、享元模式的基本介绍</h3><ol>
<li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效的支持大量细粒度的对象。</li>
<li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</li>
<li>享元模式能够解决<strong>重复对象的内存浪费问题，当系统中有大量相似对象，需要缓冲池时，不需总是创建对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。</strong></li>
<li>享元模式经典的应用场景就是池技术了，<strong>String常量池，数据库连接池，缓冲池</strong>等等都是享元模式的应用，享元模式是池技术的重要实现方式。</li>
</ol>
<p><strong>享元模式的原理类图</strong></p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123152953104.png" alt="image-20210123152953104"></p>
<p><strong>说明</strong></p>
<ol>
<li>FlyWeight是抽象的享元角色，他是产品的抽象类，同时定义出对象的<strong>外部状态和内部状态</strong>的接口和实现</li>
<li>ConcreteFlyweight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。</li>
<li>UnsharedconcreteFlyweight是不可共享的角色，一般不会出现在享元工厂。</li>
<li>FlyweightFactory 享元工厂类，用于构建一个池容器（集合），同时提供从池内获取对象方法。</li>
</ol>
<p><strong>内部状态和外部状态</strong></p>
<p>比如围棋，五子棋，跳棋，他们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别是位置的不同，当我们落子后，落子颜色是定的，但是位置是变化的，所以棋子坐标就是棋子的外部状态。</p>
<ol>
<li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：<strong>内部状态和外部状态</strong>。</li>
<li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li>
<li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的，不可共享的状态。</li>
<li>举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难维持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。</li>
</ol>
<h3 id="4-12-3、享元模式解决网站展现项目"><a href="#4-12-3、享元模式解决网站展现项目" class="headerlink" title="4.12.3、享元模式解决网站展现项目"></a>4.12.3、享元模式解决网站展现项目</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123194158319.png" alt="image-20210123194158319"></p>
<pre><code class="java">package flyweight;

public abstract class WebSite {
    public abstract void use(User user);//抽象方法
}
</code></pre>
<pre><code class="java">package flyweight;

//具体的网站
public class ConcreteWebSite extends WebSite{

    //共享的部分，内部状态
    private String type = &quot;&quot;;//网站发布的形式（类型）

    //构造器
    public ConcreteWebSite(String type) {
        this.type = type;
    }

    @Override
    public void use(User user) {
        System.out.println(&quot;网站的发布形式:&quot; +type + user.getName() +&quot;在使用中..&quot;);
    }
}
</code></pre>
<pre><code class="java">package flyweight;

public class User {


    public User(String name) {
        this.name = name;
    }

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<pre><code class="java">package flyweight;

import java.util.HashMap;

//网站工厂类，根据需求返回一个网站
public class WebSiteFactory {


    //集合，充当池的作用
    private HashMap&lt;String ,ConcreteWebSite&gt; pool = new HashMap&lt;&gt;();

    //根据网站的类型，返回一个网站，如果没有就创建一个网站，并放入池中，并返回
    public WebSite getWebSiteCategory(String type){
        if (!pool.containsKey(type)){
            //就创建一个网站，并放入池中
            pool.put(type,new ConcreteWebSite(type));
        }
        return (WebSite)pool.get(type);
    }

    //获取网站分类的总数(池中有多少个网站类型)
    public int  getWebSiteCount(){
        return pool.size();
    }
}
</code></pre>
<pre><code class="java">package flyweight;

public class Client {
    public static void main(String[] args) {

        //创建一个工厂类
        WebSiteFactory factory = new WebSiteFactory();

        //客户要一个以新闻形式发布的网站
        WebSite webSite1 = factory.getWebSiteCategory(&quot;新闻&quot;);

        webSite1.use(new User(&quot;Tom&quot;));

        //客户要一个以博客形式发布的网站
        WebSite webSite2 = factory.getWebSiteCategory(&quot;博客&quot;);
        webSite2.use(new User(&quot;Jack&quot;));

        WebSite webSite3 = factory.getWebSiteCategory(&quot;博客&quot;);
        webSite2.use(new User(&quot;Smith&quot;));

        System.out.println(&quot;网站的分类共=&quot; + factory.getWebSiteCount());


    }
}
</code></pre>
<h3 id="4-12-4、享元模式在KDK-Interger的应用源码分析"><a href="#4-12-4、享元模式在KDK-Interger的应用源码分析" class="headerlink" title="4.12.4、享元模式在KDK-Interger的应用源码分析"></a>4.12.4、享元模式在KDK-Interger的应用源码分析</h3><ol>
<li>Interger中的享元模式</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210123195446898.png" alt="image-20210123195446898"></p>
<p><strong>小结</strong></p>
<ol>
<li>在valueOf方法中，先判断值是否在IntegerCache中，如果不在，就创建新的Integer（new），否则，就直接从缓存池中返回。</li>
<li>valueOf方法，就是使用到享元模式</li>
<li>如果使用valueOf方法，得到一个Integer实例，范围在-128–127之间，执行速度比new要快。</li>
</ol>
<h3 id="4-12-5、享元模式的注意事项和细节"><a href="#4-12-5、享元模式的注意事项和细节" class="headerlink" title="4.12.5、享元模式的注意事项和细节"></a>4.12.5、享元模式的注意事项和细节</h3><ol>
<li>在享元模式这样理解，“享”就是表示分享，“元”表示对象</li>
<li>系统中有大量对象，这些对象消耗大量内存，并且这些对象的状态大部分可以外部化是，我们就可以考虑使用享元模式</li>
<li>用唯一标识码判断，，如果内存中有，则返回这个唯一标志码所标识的对象，用HashMap/HashTable存储。</li>
<li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率。</li>
<li>享元模式提高了系统的复杂度。<strong>需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，</strong>这是我们使用享元模式需要注意的地方。</li>
<li>使用享元模式时，<strong>注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</strong>。</li>
<li>享元模式经典的应用场景是需要缓冲池的场景，比如String常量池，数据库连接池。</li>
</ol>
<h2 id="4-13、代理模式"><a href="#4-13、代理模式" class="headerlink" title="4.13、代理模式"></a>4.13、代理模式</h2><h3 id="4-13-1、代理模式的基本介绍"><a href="#4-13-1、代理模式的基本介绍" class="headerlink" title="4.13.1、代理模式的基本介绍"></a>4.13.1、代理模式的基本介绍</h3><ol>
<li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问，即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现的基础上增强额外的功能操作，即扩展目标对象的功能。</li>
<li>被代理的对象可以是远程对象，创建开销大的对象或者需要安全控制的对象</li>
<li>代理模式有不同的形式，主要是三种：<strong>静态代理，动态代理，Cglib代理（可以在内存中动态创建对象，不需要实现接口）</strong></li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210124105501434.png" alt="image-20210124105501434"></p>
<h3 id="4-13-2、静态代理"><a href="#4-13-2、静态代理" class="headerlink" title="4.13.2、静态代理"></a>4.13.2、静态代理</h3><p><strong>静态代理模式的介绍</strong></p>
<p>静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者继承相同的接口</p>
<p><strong>应用实例</strong></p>
<ol>
<li>定义一个接口ITeacherDao</li>
<li>目标对象TeacherDao实现接口ITeacherDAo</li>
<li>使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao</li>
<li>调用的时候通过调用代理对象的方法来调用目标对象</li>
<li><strong>特别提醒：</strong>代理对象与目标对象要实现相同的接口，然后通过调用相同的的方法来调用目标对象的方法。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210124123713473.png" alt="image-20210124123713473"></p>
<pre><code class="java">package staticproxy;


//接口
public interface ITeacherDao {
    void teach();
}
</code></pre>
<pre><code class="java">package staticproxy;

public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println(&quot;老师正在授课&quot;);
    }
}
</code></pre>
<pre><code class="java">package staticproxy;
//代理对象，静态代理
public class TeacherDaoProxy implements ITeacherDao{
    private ITeacherDao target;//目标对象，通过接口来聚合

    //构造器
    public TeacherDaoProxy(ITeacherDao target) {
        this.target = target;
    }

    @Override
    public void teach() {
        System.out.println(&quot;代理开始,完成某些操作....&quot;);
        target.teach();
        System.out.println(&quot;提交....&quot;);
    }
}
</code></pre>
<pre><code class="java">package staticproxy;

public class Client {
    public static void main(String[] args) {
        //创建目标对象（被代理对象）
        TeacherDao teacherDao = new TeacherDao();


        //创建代理对象，同时将被代理对象传递给代理对象
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);

        //通过代理对象，调用到被代理对象的方法
        //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法
        teacherDaoProxy.teach();

    }
}
</code></pre>
<p><strong>静态代理优缺点</strong></p>
<ol>
<li>优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展</li>
<li>缺点：因为代理模式需要与目标对象实现一样的借口，所以会有很多代理类</li>
<li>一旦接口增加方法，目标对象与代理对象都要维护</li>
</ol>
<h3 id="4-13-3、动态代理"><a href="#4-13-3、动态代理" class="headerlink" title="4.13.3、动态代理"></a>4.13.3、动态代理</h3><p><strong>动态代理模式的基本介绍</strong></p>
<ol>
<li>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。</li>
<li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象。</li>
<li>动态代理：JDK代理，接口代理</li>
</ol>
<p><strong>JDK中生成代理对象的API</strong></p>
<ol>
<li>代理类所在包：java.reflect.Proxy</li>
<li>JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接受三个参数，完整的写法是：</li>
</ol>
<pre><code class="java">static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,invocationHandler h)</code></pre>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210124140843142.png" alt="image-20210124140843142"></p>
<pre><code class="java">package Proxy.dynamic;
//接口
public interface  ITeacherDao {

    void teach();//授课方法
}
</code></pre>
<pre><code class="java">package Proxy.dynamic;

public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println(&quot;老师在授课中&quot;);
    }
}
</code></pre>
<pre><code class="java">package Proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {
    //维护一个目标对象，Object
    private Object target;

    //构造器，对target进行初始化

    public ProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象，生成一个代理对象
    public Object getProxyInstance(){
        /*
        * 说明
        * public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        *
        *
        * 1.ClassLoader loader:指定当前目标对象使用的类加载器，获取加载器的方法固定
        * 2.Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型
        * 3.InvocationHandler h：事情处理，执行目标对象的方法时，会触发事情处理器方法，会把当前执行的目标对象方法作为参数传入。
        *
        */

        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(&quot;JDK代理开始~~&quot;);
                //反射机制调用目标对象的方法
                Object returnVal = method.invoke(target,args);
                System.out.println(&quot;JDK代理提交&quot;);
                return returnVal;
            }
        });
    }
}
</code></pre>
<pre><code class="java">package Proxy.dynamic;

public class Client {
    public static void main(String[] args) {

        //创建目标对象
        ITeacherDao target = new TeacherDao();

        //给目标对象,创建代理对象，可以转成ITeacherDao
        ITeacherDao proxyInstance =(ITeacherDao) new ProxyFactory(target).getProxyInstance();
        //proxyInstance = class com.sun.proxy.$Proxy0从这里看出，内存中动态生成的代理对象
        System.out.println(&quot;proxyInstance = &quot; +proxyInstance.getClass());

        //通过代理对象，调用目标对象的方法
        proxyInstance.teach();
    }
}</code></pre>
<h3 id="4-13-4、Cglib代理"><a href="#4-13-4、Cglib代理" class="headerlink" title="4.13.4、Cglib代理"></a>4.13.4、Cglib代理</h3><p><strong>Cglib代理模式的基本介绍</strong></p>
<ol>
<li>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单纯的对象，并没有实现任何接口，这个时候可使用目标对象子类来实现代理。—-&gt;Chlib代理</li>
<li>Cglib代理也叫子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。</li>
<li>Cglib是一个强大的高性能的代码生成包，他可以在运行期扩展Java类与实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截。</li>
<li>在AOP编程中如何选择代理模式<ul>
<li>目标对象需要实现接口，用JDK代理</li>
<li>目标对象不需要实现接口，用Cglib代理</li>
</ul>
</li>
<li>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</li>
</ol>
<p><strong>Cglib代理模式实现步骤</strong></p>
<ol>
<li><p>需要引入Cglib的jar文件。</p>
</li>
<li><p>在内存中动态构建子类，注意代理的类不能为final，否则会报错（java.lang.IllegalArgumentException）</p>
</li>
<li><p>目标对象的方法如果为final/static,那么就不会被拦截，既不会执行目标对象额外的业务方法</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210125132608017.png" alt="image-20210125132608017"></p>
</li>
</ol>
<h3 id="4-13-5、代理模式（Proxy）的变体"><a href="#4-13-5、代理模式（Proxy）的变体" class="headerlink" title="4.13.5、代理模式（Proxy）的变体"></a>4.13.5、代理模式（Proxy）的变体</h3><p><strong>1. 防火墙代理</strong></p>
<p>内网通过代理穿透防火墙，实现对公司的访问。</p>
<p><strong>2. 缓存代理</strong></p>
<p>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源就OK，如果取不到资源，就去公网或者数据库取，然后缓存。</p>
<p><strong>3.远程代理</strong></p>
<p>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p>
<p><strong>4. 同步代理</strong></p>
<p>主要使用在多线程编程中，完成对线程间同步工作。</p>
<h2 id="4-14、模板方法模式"><a href="#4-14、模板方法模式" class="headerlink" title="4.14、模板方法模式"></a>4.14、模板方法模式</h2><p><strong>豆浆制作问题</strong></p>
<ol>
<li>制作豆浆的流程  选材–&gt;添加配料–&gt;浸泡–&gt;放到豆浆机打碎</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>选材，浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的。（红豆，花生豆）</li>
</ol>
<h3 id="4-14-1、模板方法模式基本介绍"><a href="#4-14-1、模板方法模式基本介绍" class="headerlink" title="4.14.1、模板方法模式基本介绍"></a>4.14.1、模板方法模式基本介绍</h3><ol>
<li>模板方法模式（Template Method Pattern）,又叫模板模式，在一个抽象类公开定义了执行它的方法的模板，它的子类可以按需重写方法实现，但调用将以抽象类中定义的方式进行。</li>
<li>简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。</li>
<li>这种类型的设计模式属于行为型模式</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210125150616394.png" alt="image-20210125150616394"></p>
<p><strong>原理类图说明</strong></p>
<ol>
<li>AbstractClass抽象类，类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其他的抽象方法 operationr2,3,4.</li>
<li>ConcreteClass实现抽象方法operationr2,3,4，以完成算法中特点子类的步骤</li>
</ol>
<h3 id="4-14-2、模板方法模式解决豆浆制作问题"><a href="#4-14-2、模板方法模式解决豆浆制作问题" class="headerlink" title="4.14.2、模板方法模式解决豆浆制作问题"></a>4.14.2、模板方法模式解决豆浆制作问题</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210125152246729.png" alt="image-20210125152246729"></p>
<pre><code class="java">package Template;
//抽象类，表示豆浆
public abstract class SoyaMilk {

    //模板方法，make，模板方法可以做成final，不让子类去覆盖
    final void make(){
        select();
        addCondiments();
        soak();
        beat();
    }

    //选材料
    void select(){
        System.out.println(&quot;第一步，选择好的新鲜的黄豆&quot;);
    }

    //添加不同的配料，抽象方法,子类具体实现
    abstract void addCondiments();

    //浸泡
    void soak(){
        System.out.println(&quot;第三步，黄豆和配料开始浸泡，需要三个小时&quot;);
    }

    void beat(){
        System.out.println(&quot;第四步，黄豆和配料放进豆浆机去打碎&quot;);
    }
}
</code></pre>
<pre><code class="java">package Template;

public class RedBeanSoyaMilk extends SoyaMilk{
    @Override
    void addCondiments() {
        System.out.println(&quot;加入上好的红豆&quot;);

    }
}
</code></pre>
<pre><code class="java">package Template;

public class PeanutSoyaMilk extends SoyaMilk{
    @Override
    void addCondiments() {
        System.out.println(&quot;加入上好的花生&quot;);
    }
}
</code></pre>
<pre><code class="java">package Template;

public class Client {
    public static void main(String[] args) {
        //制作红豆豆浆

        System.out.println(&quot;-------制作红豆豆浆----&quot;);

        SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();

        redBeanSoyaMilk.make();




        //制作花生豆浆

        System.out.println(&quot;-------制作花生豆浆----&quot;);

        SoyaMilk peanutSoyaMilk  = new PeanutSoyaMilk();

        peanutSoyaMilk.make();
    }
}
</code></pre>
<h3 id="4-14-2、模板方法模式的钩子方法"><a href="#4-14-2、模板方法模式的钩子方法" class="headerlink" title="4.14.2、模板方法模式的钩子方法"></a>4.14.2、模板方法模式的钩子方法</h3><p><strong>模板方法模式的钩子方法</strong></p>
<ol>
<li>在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为<strong>钩子</strong>。</li>
<li>还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造。</li>
</ol>
<pre><code class="java">package Template.improve;
//抽象类，表示豆浆
public abstract class SoyaMilk {

    //模板方法，make，模板方法可以做成final，不让子类去覆盖
    final void make(){
        select();
        if (customerWantCondiments()){
            addCondiments();
        }
        soak();
        beat();
    }

    //选材料
    void select(){
        System.out.println(&quot;第一步，选择好的新鲜的黄豆&quot;);
    }

    //添加不同的配料，抽象方法,子类具体实现
    abstract void addCondiments();

    //浸泡
    void soak(){
        System.out.println(&quot;第三步，黄豆和配料开始浸泡，需要三个小时&quot;);
    }

    void beat(){
        System.out.println(&quot;第四步，黄豆和配料放进豆浆机去打碎&quot;);
    }

    //钩子方法，决定是否需要添加配料
    boolean customerWantCondiments(){
        return true;
    }

}
</code></pre>
<pre><code class="java">package Template.improve;

public class PureSoyaMilk extends SoyaMilk{
    @Override
    void addCondiments() {
    //空实现
    }

    @Override
    boolean customerWantCondiments() {
        return false;
    }
}
</code></pre>
<pre><code class="java">package Template.improve;

public class Client {
    public static void main(String[] args) {
        //制作红豆豆浆

        System.out.println(&quot;-------制作红豆豆浆----&quot;);

        SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();

        redBeanSoyaMilk.make();




        //制作花生豆浆

        System.out.println(&quot;-------制作花生豆浆----&quot;);

        SoyaMilk peanutSoyaMilk  = new PeanutSoyaMilk();

        peanutSoyaMilk.make();



        //制作纯豆浆
        System.out.println(&quot;-------制作纯豆浆----&quot;);

        SoyaMilk pureSoyaMilk = new PureSoyaMilk();

        pureSoyaMilk.make();

    }
}
</code></pre>
<h3 id="4-14-3、模板方法在Spring框架应用的源码分析"><a href="#4-14-3、模板方法在Spring框架应用的源码分析" class="headerlink" title="4.14.3、模板方法在Spring框架应用的源码分析"></a>4.14.3、模板方法在Spring框架应用的源码分析</h3><p>Spring   IOC容器初始化时运用到的模板方法模式</p>
<h3 id="4-14-4、模板方法模式的注意事项和细节"><a href="#4-14-4、模板方法模式的注意事项和细节" class="headerlink" title="4.14.4、模板方法模式的注意事项和细节"></a>4.14.4、模板方法模式的注意事项和细节</h3><ol>
<li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改，需要修改算法时，只需要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li>
<li>实现了最大化代码复用。父类模板方法和已实现的某些步骤会被子类继承而直接使用。</li>
<li>即统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li>
<li>该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。</li>
<li>一般模板方法都加上final关键字，防止子类重写模板方法。</li>
<li>模板方法模式使用场景：当要完成在某个过程，该过程执行一系列步骤，这一系列步骤的步骤基本相同，但是个别步骤在实现时可能不同，通常考虑用模板方法模式来处理。</li>
</ol>
<h2 id="4-15、命令模式"><a href="#4-15、命令模式" class="headerlink" title="4.15、命令模式"></a>4.15、命令模式</h2><p><strong>项目需求</strong></p>
<ol>
<li>我们买了一套智能家电，有照明灯，风扇，冰箱，洗衣机，我们只要在手机上安装app就可以控制对这些家电工作。</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个app，分别控制，我们希望只要一个app就可以控制全部智能家电。</li>
<li>要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给app调用，这时就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者“ 从”动作的执行者“对象中解耦出来</li>
<li>在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品。</li>
</ol>
<h3 id="4-15-1、命令模式的基本介绍"><a href="#4-15-1、命令模式的基本介绍" class="headerlink" title="4.15.1、命令模式的基本介绍"></a>4.15.1、命令模式的基本介绍</h3><ol>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要像某些对象发送请求，但是并不知道请求接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。</li>
<li>命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li>
<li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作。</li>
<li>通俗易懂的理解，将军发布命令，士兵去执行其中有几个角色，将军（命令发布者），士兵（命令的具体执行者），命令（连接将军和士兵）</li>
<li>Invoker是调用者（将军），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210126131553574.png" alt="image-20210126131553574"></p>
<p><strong>原理类图说明</strong></p>
<ol>
<li>Invoker是调用者角色</li>
<li>Command是命令角色，需要执行的所有命令都在这里，可以是接口或者抽象类。</li>
<li>Receiver：接收者角色，知道如何实施和执行一个请求相关的操作。</li>
<li>ConcreteCommand：将一个接收者对象与一个动作，调用接收者相应的操作，实现execute。</li>
</ol>
<h3 id="4-15-2、命令模式解决智能生活项目"><a href="#4-15-2、命令模式解决智能生活项目" class="headerlink" title="4.15.2、命令模式解决智能生活项目"></a>4.15.2、命令模式解决智能生活项目</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210126134630061.png" alt="image-20210126134630061"></p>
<pre><code class="java">package command;
//创建命令接口
public interface Command {
    //执行动作（操作）
    public void excute();
    //撤销动作（某个操作）
    public void undo();
}
</code></pre>
<pre><code class="java">package command;

public class LightOnCommand implements Command{

    //聚合LightReceiver
    LightReceiver light;
    //构造器
    public LightOnCommand(LightReceiver light) {
        this.light = light;
    }

    @Override
    public void excute() {
        //调用接收者的方法
        light.on();

    }

    @Override
    public void undo() {
        //调用接收者的方法
        light.off();
    }
}
</code></pre>
<pre><code class="java">package command;

public class LightOffCommand implements Command{

    //聚合LightReceiver
    LightReceiver light;
    //构造器
    public LightOffCommand(LightReceiver light) {
        this.light = light;
    }

    @Override
    public void excute() {
        //调用接收者的方法
        light.off();

    }

    @Override
    public void undo() {
        //调用接收者的方法
        light.on();
    }

}
</code></pre>
<pre><code class="java">package command;

/*没有任何命令，即空执行：用于初始化每个按钮，当调用空命令时，对象什么也不做
其实这也是一种设计模式，可以省掉对空命令的判断
* */

public class NoCommand implements Command{
    @Override
    public void excute() {

    }

    @Override
    public void undo() {

    }
}
</code></pre>
<pre><code class="java">package command;

public class LightReceiver {

    public void on(){
        System.out.println(&quot; 电灯打开了 &quot;);
    }

    public void off(){
        System.out.println(&quot; 电灯关闭了 &quot;);
    }
}
</code></pre>
<pre><code class="java">package command;

public class RemoteController {

    //开 按钮的命令数组
    Command[] onCommands;
    Command[] offCommands;

    //执行撤销命令
    Command undocommand;

    //构造器，完成对按钮的初始化
    public RemoteController(){
        onCommands = new Command[5];
        offCommands = new Command[5];

        for (int i = 0;i&lt;5;i++){
            onCommands[i] = new NoCommand();
            offCommands[i] = new NoCommand();
        }
    }

    //给按钮设置需要的命令
    public void setCommand(int no,Command onCommand,Command offCommand){
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    //按下开按钮
    public void onButtonWasPushed(int no){
        //找到你按下的开的按钮，并调用其方法
        onCommands[no].excute();
        //记录这次的操作，用于撤销
        undocommand  = onCommands[no];


    }
    //按下关按钮
    public void offButtonWasPushed(int no){
        //找到你按下的关的按钮，并调用其方法
        offCommands[no].excute();
        //记录这次的操作，用于撤销
        undocommand  = offCommands[no];
    }

    //按下撤销按钮
    public void undoButtonWasPushed(){
        undocommand.undo();
    }
}
</code></pre>
<pre><code class="java">package command;

public class Client {
    public static void main(String[] args) {

        //使用命令模式，完成通过遥控器，对电灯的操作

        //创建电灯的对象（接受者）
        LightReceiver lightReceiver = new LightReceiver();

        //创建点灯开关的开关命令
        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);


        //需要一个遥控器
        RemoteController remoteController = new RemoteController();

        //给我们的遥控器设置命令。比如no = 0是对点灯的开和关的操作
        remoteController.setCommand(0,lightOnCommand,lightOffCommand);

        System.out.println(&quot;-----------按下灯的开的按钮--------&quot;);
        remoteController.onButtonWasPushed(0);
        System.out.println(&quot;-----------按下灯的关的按钮---------&quot;);
        remoteController.offButtonWasPushed(0);

        System.out.println(&quot;------按下撤销按钮------&quot;);
        remoteController.undoButtonWasPushed();
    }
}
</code></pre>
<p><strong>增加一个TV的控制</strong></p>
<pre><code class="java">package command;

public class TVReceiver {

    public void on(){
        System.out.println(&quot; 电视打开了 &quot;);
    }

    public void off(){
        System.out.println(&quot; 电视关闭了 &quot;);
    }
}
</code></pre>
<pre><code class="java">package command;

public class TVOffCommand implements Command{

    //聚合TVReceiver
    TVReceiver tv;
    //构造器
    public TVOffCommand(TVReceiver tv) {
        this.tv = tv;
    }

    @Override
    public void excute() {
        //调用接收者的方法
        tv.off();

    }

    @Override
    public void undo() {
        //调用接收者的方法
        tv.on();
    }

}

</code></pre>
<pre><code class="java">package command;

public class TVOnCommand implements Command{

    //聚合TVReceiver
    TVReceiver tv;
    //构造器
    public TVOnCommand(TVReceiver tv) {
        this.tv = tv;
    }

    @Override
    public void excute() {
        //调用接收者的方法
        tv.on();

    }

    @Override
    public void undo() {
        //调用接收者的方法
        tv.off();
    }
}
</code></pre>
<pre><code class="java">package command;

public class Client {
    public static void main(String[] args) {

        //使用命令模式，完成通过遥控器，对电灯的操作

        //创建电灯的对象（接受者）
        LightReceiver lightReceiver = new LightReceiver();

        //创建点灯开关的开关命令
        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);


        //需要一个遥控器
        RemoteController remoteController = new RemoteController();

        //给我们的遥控器设置命令。比如no = 0是对点灯的开和关的操作
        remoteController.setCommand(0,lightOnCommand,lightOffCommand);

        System.out.println(&quot;-----------按下灯的开的按钮--------&quot;);
        remoteController.onButtonWasPushed(0);
        System.out.println(&quot;-----------按下灯的关的按钮---------&quot;);
        remoteController.offButtonWasPushed(0);

        System.out.println(&quot;------按下撤销按钮------&quot;);
        remoteController.undoButtonWasPushed();





        //操作TV
        System.out.println(&quot;使用遥控器操作电视机&quot;);
        TVReceiver tvReceiver = new TVReceiver();

        TVOffCommand tvOffCommand = new TVOffCommand(tvReceiver);
        TVOnCommand tvOnCommand = new TVOnCommand(tvReceiver);

        //给遥控器设置命令，比如no=1 是电视的开和关操作
        remoteController.setCommand(1,tvOnCommand,tvOffCommand);


        System.out.println(&quot;-----------按下电视机的开的按钮--------&quot;);
        remoteController.onButtonWasPushed(1);
        System.out.println(&quot;-----------按下电视机的关的按钮---------&quot;);
        remoteController.offButtonWasPushed(1);

        System.out.println(&quot;------按下撤销按钮------&quot;);
        remoteController.undoButtonWasPushed();
    }
}
</code></pre>
<h3 id="4-15-3、Spring框架JdbcTemplate应用的源码分析"><a href="#4-15-3、Spring框架JdbcTemplate应用的源码分析" class="headerlink" title="4.15.3、Spring框架JdbcTemplate应用的源码分析"></a>4.15.3、Spring框架JdbcTemplate应用的源码分析</h3><ol>
<li>Spring框架的JdbcTemplate就是用到了命令模式</li>
</ol>
<h3 id="4-15-4、命令模式的注意事项和细节"><a href="#4-15-4、命令模式的注意事项和细节" class="headerlink" title="4.15.4、命令模式的注意事项和细节"></a>4.15.4、命令模式的注意事项和细节</h3><ol>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁，是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：“发起请求者” 和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</li>
<li>容易设计一个命令队列。只要把命令对象放到队列，就可以多线程的执行命令</li>
<li>容易实现对请求的撤销和重做</li>
<li>命令模式的不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，者点在使用的时候要注意。</li>
<li>空命令也是一种设计模式，他为我们省去了判空的操作，在上面的事例中，如果没有空命令，我们每按下一个按键都要判空，这给我们的编码带来了一定的麻烦。</li>
<li>命令模式经典的应用场景：界面的一个按钮都是一条命令，模拟CMD（DOS命令）订单的撤销恢复，触发-反馈机制。</li>
</ol>
<h2 id="4-16、访问模式"><a href="#4-16、访问模式" class="headerlink" title="4.16、访问模式"></a>4.16、访问模式</h2><p><strong>测评系统的需求</strong></p>
<ol>
<li>将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手的评价（评价 有不同的种类，比如成功失败等）</li>
<li>传统方案：男人女人继承Person ，通过判断确定评价</li>
</ol>
<p><strong>传统方式的问题分析</strong></p>
<ol>
<li>如果系统比较小，还是ok的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了ocp原则。</li>
<li>扩展性不好，比如 增加了新的人员类型，或者管理方法，都不好做。</li>
<li>引出我们新的设计模式—&gt;访问者模式</li>
</ol>
<h3 id="4-16-1、访问者模式基本介绍"><a href="#4-16-1、访问者模式基本介绍" class="headerlink" title="4.16.1、访问者模式基本介绍"></a>4.16.1、访问者模式基本介绍</h3><p><strong>访问者模式基本介绍</strong></p>
<ol>
<li>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li>
<li>主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题。</li>
<li><strong>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。</strong></li>
<li><strong>访问者模式主要应用场景：需要对一个对象结构中的对象进行很多不同操作</strong>（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210127141449146.png" alt="image-20210127141449146"></p>
<p><strong>访问者模式的角色和职责</strong></p>
<ol>
<li>Visitor是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作。</li>
<li>ConcreteElement：是一个具体的访问值，实现每个有Visitor声明的操作，是每个操作实现的部分。</li>
<li>ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问的元素。</li>
<li>Element：定义一个accept方法，接收一个访问者对象。</li>
<li>concreteElement：为具体元素，实现了accept方法。</li>
</ol>
<h3 id="4-16-2、访问者模式应用实例"><a href="#4-16-2、访问者模式应用实例" class="headerlink" title="4.16.2、访问者模式应用实例"></a>4.16.2、访问者模式应用实例</h3><p><strong>应用实例要求</strong></p>
<p>将人分为男人和女人，对歌手进行评测，当看完某个歌手表演后，得到他们对该歌手不同的评价（评价 有不同的种类，比如 成功，失败等），请使用访问者模式来说实现。</p>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210127150957421.png" alt="image-20210127150957421"></p>
<pre><code class="java">package visitor;

public abstract class Action {
    //得到男性的测评
    public abstract void getManResult(Man man);

    //得到女性的测评
    public abstract void getWomanResult(Woman woman);
}
</code></pre>
<pre><code class="java">package visitor;

public class Man extends Person{
    @Override
    public void accept(Action action) {
        action.getManResult(this);
    }
}
</code></pre>
<pre><code class="java">package visitor;
//说明：
//1.这里我们是用到了双分派，即首先在客户端程序中，将具体状态作为参数传递给Woman中（第一次分派）
//2.然后Woman类调用作为参数的“具体方法”中方法getWomanResult，将自己（this）作为参数传入，完成了第二次分派


public class Woman extends Person{
    @Override
    public void accept(Action action) {
        action.getWomanResult(this);
    }
}
</code></pre>
<pre><code class="java">package visitor;

public abstract class Person {

    //提供一个方法，让访问者可以访问
    public abstract void accept(Action action);

}
</code></pre>
<pre><code class="java">package visitor;

public class Success extends Action{
    @Override
    public void getManResult(Man man) {
        System.out.println(&quot;男人给的评价是好&quot;);
    }

    @Override
    public void getWomanResult(Woman woman) {
        System.out.println(&quot;女人给的评价是好&quot;);
    }
}
</code></pre>
<pre><code class="java">package visitor;

public class Fail extends Action{
    @Override
    public void getManResult(Man man) {
        System.out.println(&quot;男人给的评价是差&quot;);
    }

    @Override
    public void getWomanResult(Woman woman) {
        System.out.println(&quot;女人给的评价是差&quot;);
    }
}
</code></pre>
<pre><code class="java">package visitor;
//数据结构，管理很多人（man，woman）
import java.util.LinkedList;
import java.util.List;

public class ObjectStructure {

    //维护了一个集合
    private List&lt;Person&gt; persons = new LinkedList&lt;&gt;();

    //增加到list
    public void attach(Person p){
        persons.add(p);

    }
    //移除
    public void detach(Person p){
        persons.remove(p);
    }

    //显示测评情报
    public void display(Action action){
        for (Person p:persons) {
            p.accept(action);

        }
    }
}
</code></pre>
<pre><code class="java">package visitor;

public class Client {
    public static void main(String[] args) {
        //创建ObjectStructure
        ObjectStructure objectStructure = new ObjectStructure();

        objectStructure.attach(new Man());
        objectStructure.attach(new Woman());



        //成功
        Success success = new Success();
        objectStructure.display(success);


        Fail fail = new Fail();
        objectStructure.display(fail);

    }
}
</code></pre>
<p><strong>应用案例小结</strong></p>
<ul>
<li>上面提到的双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型</li>
<li>假设我们要添加一个NoBat的状态类，考察Man类和Woman类的反映，由于使用了双分派，只需要增加一个Action子类即可在客户端调用，不需要改动任何其他类的代码。</li>
</ul>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210127171011926.png" alt="image-20210127171011926"></p>
<pre><code class="java">package visitor;

public class Client {
    public static void main(String[] args) {
        //创建ObjectStructure
        ObjectStructure objectStructure = new ObjectStructure();

        objectStructure.attach(new Man());
        objectStructure.attach(new Woman());



        //成功
        Success success = new Success();
        objectStructure.display(success);


        Fail fail = new Fail();
        objectStructure.display(fail);


        System.out.println(&quot;========给的是待定的测评======&quot;);

        Wait wait = new Wait();
        objectStructure.display(wait);


    }
}
</code></pre>
<pre><code class="java">package visitor;

public class Wait extends Action{
    @Override
    public void getManResult(Man man) {
        System.out.println(&quot;男人给的评价是该歌手待定&quot;);
    }

    @Override
    public void getWomanResult(Woman woman) {
        System.out.println(&quot;女人给法人评价是该歌手待定&quot;);
    }
}
</code></pre>
<h3 id="4-16-3、访问者模式的注意事项和细节"><a href="#4-16-3、访问者模式的注意事项和细节" class="headerlink" title="4.16.3、访问者模式的注意事项和细节"></a>4.16.3、访问者模式的注意事项和细节</h3><p><strong>优点</strong></p>
<ol>
<li>访问者模式符合单一职责原则，让程序具有优秀的扩展性，灵活性非常高。</li>
<li>访问者模式可以对功能进行统一，可以做报表，UI，拦截器与过滤器，适用于数据结构相对稳定的系统。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变得更比较困难。</li>
<li>违背了依赖倒转原则，访问者依赖的是具体的元素，而不是抽象元素。</li>
<li>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问这模式是比较合适的。</li>
</ol>
<h2 id="4-17、迭代器模式"><a href="#4-17、迭代器模式" class="headerlink" title="4.17、迭代器模式"></a>4.17、迭代器模式</h2><p><strong>具体需求</strong></p>
<p>编写程序展示一个学校院系结构：需求是这样的，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。</p>
<p><strong>传统方式的问题分析</strong></p>
<ol>
<li>将学校看作是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的。</li>
<li>实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多少个学院，一个学校有多少个系，因此这种方案，不能很好体现的遍历的操作。</li>
<li>解决方案：—&gt;迭代器</li>
</ol>
<h3 id="4-17-1、迭代器模式的基本介绍"><a href="#4-17-1、迭代器模式的基本介绍" class="headerlink" title="4.17.1、迭代器模式的基本介绍"></a>4.17.1、迭代器模式的基本介绍</h3><p><strong>基本介绍</strong></p>
<ol>
<li>迭代器模式（Iterator  Pattern）是常用的设计模式，属于行为型模式。</li>
<li>如果我们的集合元素是用不同的方式实现的，有数组，还有Java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要适用多种遍历方式而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li>
<li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法去遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部结构。</li>
</ol>
<p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210128115820823.png" alt="image-20210128115820823"></p>
<p><strong>迭代器模式的角色和职责</strong></p>
<ol>
<li>Iterator：迭代器接口，是系统提供，hasNext，next，remove。</li>
<li>ConcreteIterator：具体的迭代器类，管理迭代。</li>
<li>Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦。</li>
<li>ConcreteAggregate：具体的聚合持有对象，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合。</li>
<li>Client：客户端，通过Iterator和Aggregate依赖子类。</li>
</ol>
<h3 id="4-17-2、以迭代器模式实现案例"><a href="#4-17-2、以迭代器模式实现案例" class="headerlink" title="4.17.2、以迭代器模式实现案例"></a>4.17.2、以迭代器模式实现案例</h3><p><img src="/Mr-lee-MQ.hithub.io/Mr-lee-MQ.hithub.io/2021/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210128123356781.png" alt="image-20210128123356781"></p>
<pre><code class="java">package iterator;
//系
public class Department {
    private String name;
    private String desc;

    public Department(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}

</code></pre>
<pre><code class="java">package iterator;

import java.util.Iterator;

public class ComputerCollegeIterator implements Iterator {
    //这里我们需要知道Department是以怎样的方式存放==&gt;数组

    Department[] departments;
    int position = 0;//遍历的位置


    public ComputerCollegeIterator(Department[] department) {
        this.departments = departments;
    }

    //判断是否还有下一个元素
    @Override
    public boolean hasNext() {
        if (position &gt;= departments.length || departments[position] == null){
            return false;
        }else {

            return true;

        }
    }

    @Override
    public Object next() {

        Department department = departments[position];
        position += 1;
        return department;
    }

    //删除的方法，默认空实现
    public void remove(){



    }
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.Iterator;
import java.util.List;

public class InfoColleageIterator implements Iterator {


    List&lt;Department&gt; departmentList;//信息工程学院是以List方式存放系
    int index = -1;//索引

    public InfoColleageIterator(List&lt;Department&gt; departmentList) {
        this.departmentList = departmentList;
    }
    //判断list中还有没有下一个元素
    @Override
    public boolean hasNext() {

        if (index &gt;=departmentList.size()-1){
            return false;
        }else {
            index += 1;
            return true;
        }
    }

    @Override
    public Object next() {
        return departmentList .get(index);
    }


    public void remove(){

    }
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.Iterator;

public interface College {
    public String getName();

    //增加系的方法
    public void addDepartment(String name,String desc);

    //增加一个迭代器，遍历
    public Iterator createIterator();
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.Iterator;

public class ComputerCollege implements College {

    Department[] departments ;
    int numOfDepartment = 0;//保存当前数组的对象个数

    public ComputerCollege(){
        departments = new Department[5];

        addDepartment(&quot;Java专业&quot;,&quot;Java专业&quot;);
        addDepartment(&quot;PHP专业&quot;,&quot;PHP专业&quot;);
        addDepartment(&quot;大数据专业&quot;,&quot;大数据专业&quot;);

    }

    @Override
    public String getName() {
        return &quot;计算机学院&quot;;
    }

    @Override
    public void addDepartment(String name, String desc) {

        Department department = new Department(name, desc);
        departments[numOfDepartment ] = department ;
        numOfDepartment  += 1;

    }

    @Override
    public Iterator createIterator() {


        return new ComputerCollegeIterator(departments );
    }
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class InfoCollege implements College{


    List&lt;Department&gt; departmentList;

    public InfoCollege(){
        departmentList = new ArrayList&lt;Department&gt;();

        addDepartment(&quot;信息安全专业&quot;,&quot;信息安全专业&quot;);
        addDepartment(&quot;网络安全专业&quot;,&quot;网络安全专业&quot;);

    }


    @Override
    public String getName() {
        return &quot;信息工程学院&quot;;
    }

    @Override
    public void addDepartment(String name, String desc) {


        Department department = new Department(name, desc);
        departmentList .add(department);
    }

    @Override
    public Iterator createIterator() {
        return new InfoColleageIterator(departmentList);
    }
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.Iterator;
import java.util.List;

public class OutPutImpl {

    //学院集合
    List&lt;College&gt; collegeList;

    public OutPutImpl(List&lt;College&gt; collegeList) {
        this.collegeList = collegeList;
    }

    //遍历所有学院，然后再调用printDepartment  输出各个学院的系
    public void printCollege(){
        //从collegeList中取出所有学院
        Iterator&lt;College&gt; iterator = collegeList.iterator();

        while (iterator .hasNext()){
            College college = iterator.next();
            System.out.println(&quot;====&quot;+college.getName() +&quot;=======&quot;);
            printDepartment(college.createIterator());

        }

    }

    //输出 学院输出系

    public void printDepartment(Iterator iterator){
        while (iterator.hasNext()){
            Department  d = (Department) iterator.next();
            System.out.println(d.getName());
        }
    }
}
</code></pre>
<pre><code class="java">package iterator;

import java.util.ArrayList;
import java.util.List;

public class Client {

    public static void main(String[] args) {
        //创建学院
        List&lt;College&gt; collegeList = new ArrayList&lt;&gt;();

        ComputerCollege computerCollege = new ComputerCollege();
        InfoCollege infoCollege  = new InfoCollege();

        collegeList.add(computerCollege);
        collegeList.add(infoCollege);

        OutPutImpl outPutImpl = new OutPutImpl(collegeList);
        outPutImpl.printCollege();

    }
}
</code></pre>
<h3 id="4-17-3、迭代器模式在集合应用的源码分析"><a href="#4-17-3、迭代器模式在集合应用的源码分析" class="headerlink" title="4.17.3、迭代器模式在集合应用的源码分析"></a>4.17.3、迭代器模式在集合应用的源码分析</h3><ol>
<li>JDK的ArrayList集合中就用使用了迭代器模式</li>
</ol>
<h3 id="4-17-4、迭代器模式的注意事项和细节"><a href="#4-17-4、迭代器模式的注意事项和细节" class="headerlink" title="4.17.4、迭代器模式的注意事项和细节"></a>4.17.4、迭代器模式的注意事项和细节</h3><p><strong>优点</strong></p>
<ol>
<li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。</li>
<li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。</li>
<li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来就集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到迭代器。</li>
<li>当要展示一组相似对象，或者遍历一组相同对象时使用，适合用到迭代器模式。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理。</li>
</ol>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
